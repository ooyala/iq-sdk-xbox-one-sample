/// <loc filename="Metadata\xbox_loc_oam.xml" format="messagebundle" />
/*!
  © Microsoft. All rights reserved.

  This library is supported for use in Windows Store apps only.

  Build: 1.0.12127.0.xb_rel_1502.150201-2200
  
  Version: Microsoft.Xbox.WinJS.1.0
*/

// Activation Services
(function activationServicesInit(WinJS, XboxJS) {
    "use strict";

    WinJS.Namespace.define("XboxJS.Navigation", {
        /// <field type="String" locid="XboxJS.UI.Navigation.LocationName" helpKeyword="XboxJS.UI.Navigation.LocationName">
        /// An enumeration of location names returned as part of parseProtocolActivation()
        /// </field>
        LocationName: {
            mediaHelpUri: "mediaHelpUri",
            mediaHomeUri: "mediaHomeUri",
            mediaPlaybackUri: "mediaPlaybackUri",
            mediaSearchUri: "mediaSearchUri",
            mediaSettingsUri: "mediaSettingsUri",
            mediaDetailsUri: "mediaDetailsUri",
        },

        parseProtocolActivation: WinJS.Namespace._lazy(function () {
            var activation = null;
            if (WinJS.Utilities.hasWinRT) {
                activation = Windows.ApplicationModel.Activation;
            }

            var _defaultAuthority = "default";
            var _mediaDetailsAuthority = "media-details";
            var _mediaHelpAuthority = "media-help";
            var _mediaPlaybackAuthority = "media-playback";
            var _mediaSearchAuthority = "media-search";
            var _mediaSettingsAuthority = "media-settings";

            var _contentIdArgument = "contentId";
            var _catalogDataArgument = "catalogData";

            var _playbackPage = "playback";
            var _detailsPage = "details";

            var _contentIdKey = "contentid";
            var _deepLinkInfoKey = "deeplinkinfo";
            var _contentTypeKey = "contenttype";

            return function activationServices_parseProtocolActivation(protocolActivationEventArguments) {
                /// <signature helpKeyword="XboxJS.Navigation.parseProtocolActivation">
                /// <summary locid="XboxJS.Navigation.parseProtocolActivation">
                /// Parse a deep link messages from the system.
                /// </summary>
                /// <param name="protocolActivationEventArguments" type="Object" locid="XboxJS.Navigation.handleProtocolActivation:protocolActivationEventArguments">
                /// The event object from the WinJS.Application.onactivated event.
                /// </param>
                /// </signature>
                /// <return value="{locationName:'', options: {contentId: '', authority: '', contentType: '', catalogData: ''}}" locid="XboxJS.Navigation.parseProtocolActivation_returns">
                /// Returns undefined if protocolActivationEventArguments is not from a protocol activation or if the activation URI is unrecoginized. Otherise,
                /// returns the location name requested and the options to pass to WinJS.Navigation.navigate().
                /// </return>
                if (protocolActivationEventArguments &&
                    protocolActivationEventArguments.detail.kind === activation.ActivationKind.protocol) {

                    // Uri format: xbl-<title id>://<authority>/?contentId=123456&contentType=Movie&catalogData=<app specific data>
                    var activationUri = protocolActivationEventArguments.detail.uri;

                    // If we are instructed to go to the details page
                    var authority = activationUri.host;
                    var caseInsensitiveAuthority = authority.toLowerCase();
                    if (caseInsensitiveAuthority === _defaultAuthority.toLowerCase() ||
                        caseInsensitiveAuthority === _mediaDetailsAuthority.toLowerCase() ||
                        caseInsensitiveAuthority === _mediaHelpAuthority.toLowerCase() ||
                        caseInsensitiveAuthority === _mediaPlaybackAuthority.toLowerCase() ||
                        caseInsensitiveAuthority === _mediaSearchAuthority.toLowerCase() ||
                        caseInsensitiveAuthority === _mediaSettingsAuthority.toLowerCase()) {

                        var queryArgs = activationUri.queryParsed;
                        var locationName = "";
                        var contentId = "";
                        var deepLinkInfo = "";
                        var contentType = "";
                        for (var i = 0; i < queryArgs.size; i++) {
                            var caseInsensitiveQueryArg = queryArgs[i].name.toLowerCase();
                            switch (caseInsensitiveQueryArg) {
                                case _contentIdKey.toLowerCase():
                                    contentId = queryArgs[i].value;
                                    break;
                                case _deepLinkInfoKey.toLowerCase():
                                    deepLinkInfo = queryArgs[i].value;
                                    break;
                                case _contentTypeKey.toLowerCase():
                                    contentType = queryArgs[i].value;
                                    break;
                                default:
                                    break;
                            }
                        }

                        var locationName = this.LocationName;

                        // In case the contentId is null or empty we go to the app's homepage
                        if (!contentId)
                            locationName = locationName.mediaHomeUri;
                        else {
                            switch (caseInsensitiveAuthority) {
                                case _defaultAuthority.toLowerCase():
                                    locationName = locationName.mediaHomeUri;
                                    break;
                                case _mediaDetailsAuthority.toLowerCase():
                                    locationName = locationName.mediaDetailsUri;
                                    break;
                                case _mediaPlaybackAuthority.toLowerCase():
                                    locationName = locationName.mediaPlaybackUri;
                                    break;
                                case _mediaHelpAuthority.toLowerCase():
                                    locationName = locationName.mediaHelpUri;
                                    break;
                                case _mediaSearchAuthority.toLowerCase():
                                    locationName = locationName.mediaSearchUri;
                                    break;
                                case _mediaSettingsAuthority.toLowerCase():
                                    locationName = locationName.mediaSettingsUri;
                                    break;
                                default:
                                    // No-op for unknown authorities
                                    break;
                            }
                        }

                        if (locationName)
                            return {
                                locationName: locationName,
                                options: {
                                    contentId: contentId,
                                    authority: authority,
                                    deepLinkInfo: deepLinkInfo,
                                    contentType: contentType,
                                }
                            };
                    }
                }
            };
        })
    });
})(WinJS);


(function xboxAnimationsInit(global) {
    "use strict";

    WinJS.Namespace.define("XboxJS.UI", {
        Animation: WinJS.Namespace._lazy(function () {
            var thisWinUI = WinJS.UI;
            var mstransform = "transform";

            // Default to 11 pixel from the left (or right if RTL)
            var defaultOffset = [{ top: "0px", left: "11px", rtlflip: true }];

            var OffsetArray = WinJS.Class.define(function OffsetArray_ctor(offset, keyframe, defOffset) {
                // Constructor
                defOffset = defOffset || defaultOffset;
                if (Array.isArray(offset) && offset.length > 0) {
                    this.offsetArray = offset;
                    if (offset.length === 1) {
                        this.keyframe = checkKeyframe(offset[0], defOffset[0], keyframe);
                    }
                } else if (offset && offset.hasOwnProperty("top") && offset.hasOwnProperty("left")) {
                    this.offsetArray = [offset];
                    this.keyframe = checkKeyframe(offset, defOffset[0], keyframe);
                } else {
                    this.offsetArray = defOffset;
                    this.keyframe = chooseKeyframe(defOffset[0], keyframe);
                }
            }, { // Public Members
                getOffset: function (i) {
                    if (i >= this.offsetArray.length) {
                        i = this.offsetArray.length - 1;
                    }
                    return this.offsetArray[i];
                }
            }, { // Static Members
                supportedForProcessing: false,
            });

            function checkKeyframe(offset, defOffset, keyframe) {
                if (offset.keyframe) {
                    return offset.keyframe;
                }

                if (!keyframe ||
                    offset.left !== defOffset.left ||
                    offset.top !== defOffset.top ||
                    (offset.rtlflip && !defOffset.rtlflip)) {
                    return null;
                }

                if (!offset.rtlflip) {
                    return keyframe;
                }

                return keyframeCallback(keyframe);
            }

            function chooseKeyframe(defOffset, keyframe) {
                if (!keyframe || !defOffset.rtlflip) {
                    return keyframe;
                }

                return keyframeCallback(keyframe);
            }

            function keyframeCallback(keyframe) {
                var keyframeRtl = keyframe + "-rtl";
                return function (i, elem) {
                    return window.getComputedStyle(elem).direction === "ltr" ? keyframe : keyframeRtl;
                }
            }

            function makeArray(elements) {
                if (Array.isArray(elements) || elements instanceof NodeList || elements instanceof HTMLCollection) {
                    return elements;
                } else if (elements) {
                    return [elements];
                } else {
                    return [];
                }
            }

            var isSnapped = function () {
                if (WinJS.Utilities.hasWinRT) {
                    var appView = Windows.UI.ViewManagement.ApplicationView;
                    var snapped = Windows.UI.ViewManagement.ApplicationViewState.snapped;
                    isSnapped = function () {
                        return appView.value === snapped;
                    };
                } else {
                    isSnapped = function () { return false; }
                }
                return isSnapped();
            };

            function translateCallback(offsetArray, prefix) {
                prefix = prefix || "";
                return function (i, elem) {
                    var offset = offsetArray.getOffset(i);
                    var left = offset.left;
                    if (offset.rtlflip && window.getComputedStyle(elem).direction === "rtl") {
                        left = left.toString();
                        if (left.charAt(0) === "-") {
                            left = left.substring(1);
                        } else {
                            left = "-" + left;
                        }
                    }
                    return prefix + "translate(" + left + ", " + offset.top + ")";
                };
            }

            return {
                showCollection: function (elements, options) {
                    /// <signature helpKeyword="XboxJS.UI.Animation.showCollection">
                    /// <summary locid="XboxJS.UI.Animation.showCollection">
                    /// Execute an showCollection animation.
                    /// </summary>
                    /// <param name="elements" locid="XboxJS.UI.Animation.showCollection_p:elements">
                    /// A collection of elements to animate.
                    /// At the end of the animation, the opacity of the elements is 1.
                    /// </param>
                    /// <param name="options" locid="XboxJS.UI.Animation.showCollection_p:options">
                    /// Optional object that specifies additional parameters for the animation.
                    /// </param>
                    /// <returns type="XboxJS.Promise" locid="XboxJS.UI.Animation.showCollection_returnValue">
                    /// Promise object that completes when the animation is complete.
                    /// </returns>
                    /// </signature>

                    options = options || {};
                    var primaryElements = elements;
                    var secondaryElements = options;
                    var direction = options.direction;

                    var duration = 0;
                    var delay = 0;

                    if (!direction) {
                        direction = "left";
                    }

                    var animationPromises = [];

                    var initialPrimaryElementsItemPosition = 0;
                    var initialSecondaryElementsItemPosition = 0;
                    var initialThirdLevelElementsItemPosition = 0;

                    var primaryElementsItemDelta = 0;
                    var secondaryElementsItemDelta = 0;
                    var thirdLevelElementsItemLeftDelta = 0;

                    if (direction === "left" || direction === "up") {
                        initialPrimaryElementsItemPosition = 200;
                        initialSecondaryElementsItemPosition = 100;
                        initialThirdLevelElementsItemPosition = 0;

                        if (primaryElements.length > 4) {
                            primaryElementsItemDelta = 200;
                        } else {
                            primaryElementsItemDelta = 600;
                        }
                        secondaryElementsItemDelta = 50;
                        thirdLevelElementsItemLeftDelta = 100;
                    } else if (direction === "right" || direction === "down") {
                        initialPrimaryElementsItemPosition = -1 * 200;
                        initialSecondaryElementsItemPosition = -1 * 100;
                        initialThirdLevelElementsItemPosition = -1 * 0;

                        if (primaryElements.length > 4) {
                            primaryElementsItemDelta = 200;
                        } else {
                            primaryElementsItemDelta = 600;
                        }

                        primaryElementsItemDelta = -200;
                        secondaryElementsItemDelta = -50;
                        thirdLevelElementsItemLeftDelta = -100;
                    }

                    if (direction === "right" || direction === "left") {
                        duration = 1000;
                    } else {
                        duration = 610;
                    }

                    // Primary elements
                    if (primaryElements &&
                        primaryElements.length > 1) {
                        var primaryElementsOffsetArray;
                        var primaryElementsAnimationOffsets = [];

                        var primaryElementsItemPosition = initialPrimaryElementsItemPosition;
                        for (var i = 0, len = primaryElements.length; i < len; i++) {
                            var currentElement = primaryElements[i];
                            if (direction === "right" || direction === "left") {
                                primaryElementsAnimationOffsets.push({ left: primaryElementsItemPosition + "px", top: "0px" });
                            } else {
                                primaryElementsAnimationOffsets.push({ left: "0px", top: primaryElementsItemPosition + "px" });
                            }
                            primaryElementsItemPosition += primaryElementsItemDelta;
                        }

                        primaryElementsOffsetArray = new OffsetArray(primaryElementsAnimationOffsets, "WinJS-showCollection1", [{ top: "0px", left: "100px", rtlflip: true }]);

                        animationPromises.push(thisWinUI.executeAnimation(
                            primaryElements,
                        {
                            property: mstransform,
                            delay: delay,
                            duration: duration,
                            timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                            from: translateCallback(primaryElementsOffsetArray),
                            to: "none"
                        }));
                        animationPromises.push(thisWinUI.executeTransition(
                            primaryElements,
                        {
                            property: "opacity",
                            delay: delay,
                            duration: duration * 0.6,
                            timing: "linear",
                            from: 0,
                            to: 1
                        }));
                    }

                    // Secondary elements
                    if (secondaryElements &&
                        secondaryElements.length > 1) {
                        var secondaryElementsOffsetArray;
                        var secondaryElementsAnimationOffsets = [];

                        var secondaryElementsItemPosition = initialSecondaryElementsItemPosition;
                        for (var i = 0, len = secondaryElements.length; i < len; i++) {
                            var currentElement = secondaryElements[i];
                            if (direction === "right" || direction === "left") {
                                secondaryElementsAnimationOffsets.push({ left: secondaryElementsItemPosition + "px", top: "0px" });
                            } else {
                                secondaryElementsAnimationOffsets.push({ left: "0px", top: secondaryElementsItemPosition + "px" });
                            }
                            secondaryElementsItemPosition += secondaryElementsItemDelta;
                        }

                        secondaryElementsOffsetArray = new OffsetArray(secondaryElementsAnimationOffsets, "WinJS-showCollection2", [{ top: "0px", left: "100px", rtlflip: true }]);

                        animationPromises.push(thisWinUI.executeAnimation(
                            secondaryElements,
                            {
                                property: mstransform,
                                delay: delay,
                                duration: duration,
                                timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                                from: translateCallback(secondaryElementsOffsetArray),
                                to: "none"
                            }));
                        animationPromises.push(thisWinUI.executeTransition(
                            secondaryElements,
                            {
                                property: "opacity",
                                delay: delay,
                                duration: duration * 0.6,
                                timing: "linear",
                                from: 0,
                                to: 1
                            }));
                    }

                    return WinJS.Promise.join(animationPromises);
                }
            };
        })
    });

}(this));

(function xboxUtilitiesInit(global) {
  "use strict";

  var appxVersion = "Microsoft.Xbox.WinJS.1.0";
  var developerPrefix = "Developer.";
  if (appxVersion.indexOf(developerPrefix) === 0) {
    appxVersion = appxVersion.substring(developerPrefix.length);
  }
  var inputManager = null;
  if (WinJS.Utilities.hasWinRT && Windows.Xbox) {
      inputManager = Windows.Xbox.Input.InputManager;
  }

  var _isBackwardNavigationInternal = false;
  var _isGestureEngagedInternal = false;
  var _isTransitioningInternal = false;
  var _isVoiceEngagedInternal = false;

  if (inputManager) {
    inputManager.addEventListener("iskinectpersonengagedchanged", _handleKinectPersonEngagedChanged, false);
  }

  // Events for styling apps that are visible, but not in focus
  window.addEventListener("focusin", _handleFocusIn, false);
  window.addEventListener("focusout", _handleFocusOut, false);

  document.addEventListener("DOMContentLoaded", function attachVoiceEvents() {
    XboxJS.UI.Voice.addEventListener("listeningstart", _setVoiceEngaged, false);
    XboxJS.UI.Voice.addEventListener("listeningend", _setVoiceDisengaged, false);
    if (WinJS.Utilities.hasWinRT && Windows.Xbox) {
        Windows.Xbox.ApplicationModel.ApplicationResourceLimits.addEventListener("resourceavailabilitychanged", _handleResourceAvailabilityChanged, false);
    }
  }, false);

  function _handleKinectPersonEngagedChanged(ev) {
    if (inputManager.isKinectPersonEngaged) {
      WinJS.Utilities.addClass(document.body, "win-gestureactive");

      var eventObject = document.createEvent("CustomEvent");
      eventObject.initCustomEvent("gestureengaged", true, false, {});
      window.dispatchEvent(eventObject);
    } else {
      WinJS.Utilities.removeClass(document.body, "win-gestureactive");

      var eventObject = document.createEvent("CustomEvent");
      eventObject.initCustomEvent("gesturedisengaged", true, false, {});
      window.dispatchEvent(eventObject);
    }
  };

  function _setVoiceEngaged() {
    _isVoiceEngagedInternal = true;
  };

  function _setVoiceDisengaged() {
    _isVoiceEngagedInternal = false;
  };

  function _handleResourceAvailabilityChanged() {
      if (Windows.Xbox.ApplicationModel.ApplicationResourceLimits.resourceAvailability === Windows.Xbox.ApplicationModel.ResourceAvailability.constrained) {
          WinJS.Utilities.addClass(document.body, "win-constrained");
      } else {
          WinJS.Utilities.removeClass(document.body, "win-constrained");
      }
  };

  // Handles when focus leaves the current window in the situation where there is a snap
  // and a fill app and this app loses focus.
  function _handleFocusIn() {
    if (document.hasFocus()) {
      WinJS.Utilities.removeClass(document.body, "win-visiblebutnotfocused");
    }
  };

  function _handleFocusOut() {
    if (!document.hasFocus()) {
      WinJS.Utilities.addClass(document.body, "win-visiblebutnotfocused");
    }
  };

  // Helper function to determine if an app is snapped
  function isSnapped() {
    if (WinJS.Utilities.hasWinRT) {
      var appView = Windows.UI.ViewManagement.ApplicationView;
      var snapped = Windows.UI.ViewManagement.ApplicationViewState.snapped;
      isSnapped = function () {
        return appView.value === snapped;
      };
    } else {
      isSnapped = function () { return false; }
    }
    return isSnapped();
  };

  // Do not call this code from your application. These APIs are for use by the internal
  // use by the framework only.
  WinJS.Namespace.define("XboxJS.Utilities", {
    // An internal property to keep track of whether a forward or backward navigation was performed
    // so the correct page transition animation can be played.
    _isBackwardNavigation: {
      get: function () {
        return _isBackwardNavigationInternal;
      },
      set: function (value) {
        _isBackwardNavigationInternal = value;
      }
    },
    // An internal property used by WinJS controls to determine if Kinect is engaged or not
    _isGestureEngaged: {
      get: function () {
        if (inputManager) {
          return inputManager.isKinectPersonEngaged;
        } else {
            return _isGestureEngagedInternal;
        }
      },
      set: function (value) {
          _isGestureEngagedInternal = value;
      }
    },
    // An internal property to keep track of whether the page is currently in the middle of a transition animation
    _isTransitioning: {
      get: function () {
        return _isTransitioningInternal;
      },
      set: function (value) {
        _isTransitioningInternal = value;
      }
    },
    // An internal property used by WinJS controls to determine if Voice is engaged or not
    _isVoiceEngaged: {
      get: function () {
        return _isVoiceEngagedInternal;
      }
    },
    // A helper property to determine whether an app is in snap mode
    _isSnapped: {
      get: function () {
        return isSnapped;
      }
    }
  });

  WinJS.Namespace.define("XboxJS.UI.Voice", {
    updateVoiceAttribute: function (element, overrides, srcElement, targetElement, handler) {
      var attribute = null;

      if (!element) {
        return;
      }

      if (overrides) {
        if (overrides.enumerate) {
          attribute = "{enumerate : \'" + overrides.enumerate + "\'";
          if (srcElement) {
            attribute = attribute + ", srcElement : " + srcElement;
          }
          if (targetElement) {
            attribute = attribute + ", targetElement : " + targetElement;
          }
          if (handler) {
            attribute = attribute + ", handler : " + handler;
          }
          attribute = attribute + "}";

        } else if (overrides.phrase) {
          attribute = "{phrase : \'" + overrides.phrase + "\'";
          if (overrides.confidence) {
            attribute = attribute + ", confidence : " + overrides.confidence;
          }
          if (overrides.pronunciation) {
            attribute = attribute + ", pronunciation : \'" + overrides.pronunciation + "\'";
          }
          if (srcElement) {
            attribute = attribute + ", srcElement : " + srcElement;
          }
          if (targetElement) {
            attribute = attribute + ", targetElement : " + targetElement;
          }
          if (handler) {
            attribute = attribute + ", handler : " + handler;
          }
          attribute = attribute + "}";
        }
      } else if (srcElement) {
        attribute = "{ srcElement : " + srcElement + "";
        if (targetElement) {
          attribute = attribute + ", targetElement : " + targetElement;
        }
        if (handler) {
          attribute = attribute + ", handler : " + handler;
        }
        attribute = attribute + "}";
      }

      if (attribute) {
        element.setAttribute("data-win-voice", attribute);
      } else {
        element.removeAttribute("data-win-voice");
      }
    },

    createVoiceOnlyElement: function (parentElement, newElements) {
      for (var i = 0; i < newElements.length; i++) {
        var currentSpec = newElements[i];

        var currentElement = document.createElement("SPAN");
        currentElement.setAttribute("tabIndex", "-1");
        currentElement.setAttribute("data-win-voice", "{phrase:'" + currentSpec.phrase + "', confidence:'" + currentSpec.confidence + "', pronunciation:'" + currentSpec.pronunciation + "', targetElement: select('this')}");
        currentElement.innerText = currentSpec.phrase; // Doesn't matter if this is not localized. Since this is a voice only element, it is fine.
        if (currentSpec.className) {
          currentElement.className = currentSpec.className;
        }
        if (currentSpec.handler) {
          currentElement.addEventListener("click", currentSpec.handler);
        }

        parentElement.appendChild(currentElement);
      }
    },

    getWinJSStringName: function (id) {
      return "ms-resource://" + appxVersion + "/" + id;
    }
  });

}(this));


(function automaticFocusInit() {
    "use strict";

    // This variable is used for testing purposes only
    var __msWinJSTestEnabledInternal = __msWinJSTestEnabledInternal || undefined;

    // Adding this CSS class to an element that is not focusable by default will make that
    // element a potential focus target when the automatic focus algorithm runs.
    var _focusableClass = "win-focusable";

    var _focusChangingEvent = "focuschanging";

    var _focusRoot = null;

    // A line segment used to keep track of navigation history in the horizontal direction. For 
    // details, see the _navigateFocus method description.
    var _horizontalManifold;

    // A fake focus root is used when findNextFocusElement is called programmatically
    // and the real focusRoot is null. This is because we always want to run the focus algorithm
    // when findNextFocus is called programmatically even if the focusRoot is set to null.
    var _isFakeFocusRootSet = false;

    // A collection of child iframes that have registered for post messages. Iframes in this
    // map potential focus targets for the automatic focus algorithm.
    var _iFrameMap = {};

    // We need to remember the bounding rectangle for the last focused element in case that element
    // destroyed between calls to _navigateFocus. We need to initialize the rectangle to a non-zero
    // size so that we don't get weird math.
    var lastFocusedElement = null;

    // The maximum distance between the reference element and a valid potential element
    var _maxDistance;

    // Keeps track of whether any iframes have been registered to have their child elements participate
    // in the automatic focus algorithm.
    var _needToMessageChildIframes = false;

    // The next focus target chosen by the automatic focus algorithm can be overridden 
    // by placing this attribute on an element.
    var _overrideAutomaticFocusAttribute = "data-win-focus";

    // These factors can be tweaked to adjust which elements are favored by the focus algorithm
    var primaryAxisDistanceWeight = 10,
        secondaryAxisDistanceWeight = 1,
        percentInManifoldShadowWeight = 10000,
        percentInShadowWeight = 50,
        inShadowThreshold = 0.25;

    var strings = {
        get invalidFocusRoot() { return WinJS.Resources._getWinJSString("tv/automaticFocusInvalidFocusRoot").value; },
        get invalidKeyCode() { return WinJS.Resources._getWinJSString("tv/automaticFocusInvalidKeyCode").value; },
        get automaticFocusFailedDuplicateIFrameRegistration() { return WinJS.Resources._getWinJSString("tv/automaticFocusFailedDuplicateIFrameRegistration").value; }
    };

    var _wasFocusRootSetProgrammatically = false;

    // A line segment used to keep track of navigation history in the vertical direction. For 
    // details, see the _navigateFocus method description.
    var _verticalManifold;

    // An enumeration of post message types used to enable automatic focus across iframes
    var _VmType = {
        none: 0,
        registerChild: 1,
        unregisterChild: 2,
        requestFocusNavigation: 3
    };

    var _standardizeUrl = function (url) {
        var standardizedUrl = url.toLowerCase();
        var replacementStrings = [
            { find: "ms-appx:///", replace: "ms-appx://" + window.location.hostname + "/" },
            { find: "ms-appx-web:///", replace: "ms-appx-web://" + window.location.hostname + "/" }
        ];

        for (var i = 0; i < replacementStrings.length; i++) {
            if (standardizedUrl.indexOf(replacementStrings[i].find) === 0 &&
                standardizedUrl.lastIndexOf(replacementStrings[i].find) === 0) {
                standardizedUrl = standardizedUrl.replace(replacementStrings[i].find, replacementStrings[i].replace);
                break;
            }
        }

        return standardizedUrl;
    };

    // Helper function to get a specific iframe from the iframe collection
    var _getFrameElement = function (frameSource) {
        var frameUrlStandardized = _standardizeUrl(frameSource);
        var frameElements = document.getElementsByTagName("IFRAME");

        for (var i = 0; i < frameElements.length; i++) {
            if (_standardizeUrl(frameElements[i].src) === frameUrlStandardized) {
                return frameElements[i];
            }
        }

        return null;
    };

    document.addEventListener("DOMContentLoaded", function initializeAlgorithm() {

        if (!_wasFocusRootSetProgrammatically) {
            _focusRoot = document.body;
        }

        // Initialize lastFocusedElement with the current active element
        if (lastFocusedElement === null) {
            var activeElement = document.activeElement;
            if (activeElement && activeElement !== document.body &&
                _isFocusableElement(activeElement)) {
                lastFocusedElement = activeElement;
            }
        }

        _maxDistance = Math.max(screen.availWidth, screen.availHeight);
        document.addEventListener("keydown", _onKeydown, false);
        document.addEventListener("focusin", _onFocusIn, false);

        window.addEventListener("message", _onMessage, false);

        // If we are running within an iframe, we send a registration message to the parent window
        if (top !== self) {
            window.parent.postMessage({
                ms__winJSAutomaticFocusControlMessage: {
                    type: _VmType.registerChild,
                    clientId: window.location.href,
                    version: 1.0
                }
            }, "*");
        }
    });

    var _findNextFocusElement = function (keyCode, focusHintRectangle) {
        return _navigateFocusInternal(keyCode, focusHintRectangle, true, null);
    };

    var _navigateFocusInternal = function (keyCode, focusHintRectangle, wasCalledProgramatically, eventObject) {
        //     This method is the core of the 2D focus algorithm. The terms below are used in the code.
        //
        //  Terms:
        //             Reference: The DOM element that currently has focus.
        //
        //             Potential: One of the possible set of elements that are eligible to receive focus. The focus algorithm
        //                        will evaluate all potential elements before choosing one and moving focus to that element.
        //
        //   Horizontal Manifold: A portion of the horizontal edge of the currently focused element. Although the manifold starts
        //                        out as 100% of the horizontal edge of the currently focused element, it is clipped over time. For
        //                        more information, read the "Algorithm" section below.
        //
        //     Vertical Manifold: A portion of the vertical edge of the currently focused element. Although the manifold starts
        //                        out as 100% of the vertical edge of the currently focused element, it is clipped over time. For
        //                        more information read the "Algorithm" below.
        //
        //              Shadow: A 2-dimensional area that extends infinitely based on the current direction of keyboard input.
        //
        // Example (direction = Right):
        //                       
        //                        Reference (currently focused element)
        //                        ╔═══════════════╗.....╔══════════════╗...................................................                               
        //                        ║...............║.....║  potential 2 ║...................................................      
        //                       |║...............║.....╚══════════════╝........................shadow.....................
        //                       |║...............║........................╔══════════════╗................................
        //                       |║...............║........................║              ║................................
        // horizontal manifold ->|║...............║........................║  potential 3 ║.........╔══════════════╗.......
        //    ╔══════════════╗   |║...............║........................║              ║.........║              ║.......
        //    ║              ║    ╚═══════════════╝........................╚══════════════╝.........║  potential 4 ║.......
        //    ║  potential 1 ║                                                                      ║              ║
        //    ║              ║                                                                      ╚══════════════╝         
        //    ╚══════════════╝                                                                                 ╔══════════════╗
        //                                                                                                     ║              ║
        //                                                                                                     ║  potential 5 ║
        //                                                                                                     ║              ║
        //                                                                                                     ╚══════════════╝
        // Algorithm:
        // The algorithm assigns each of the potential elements a score. After the algorithm has gone through all of the potential
        // elements, the potential element with the highest score gets keyboard focus.
        //
        //    1) Potential 1 is behind the currently focused element so it won't be selected.
        //    2) Potential 5 is in front of the currently focused element, but isn't in the shadow so it will get a low score.
        //    3) Potential 4 is in front of the currently focused element and partially in the shadow so it will get a higher
        //       score than potential 5.
        //    4) Potential 3 is in front of the currently focused element and 100% in the shadow so it will get the higher score than
        //       potential 4.
        //    5) Potential 2 is also in front of the currently focused element and 100% in the shadow. As a tiebreak between potential
        //       elements 2 and 3, the algorithm will look at which element has the largest percent of it's vertical edge in the shadow cast
        //       by the horizontal manifold. Potential 3 has the largest percentage of it's vertical edge in the shadow, therefore potential
        //       element 3 wins.
        //    6) The algorithm sets focus on potential 3.
        //    7) The algorithm will update the horizontal manifold to be the size of potential 3's vertical edge.

        msWriteProfilerMark("XboxJS.UI.AutomaticFocus:findNextFocusElement,StartTM");

        // Note: We check to see if the keyCode is one of the key codes we need to process.
        // If not, we should exit immediately before doing any expensive operations. We want to minimize unnecessary
        // work in this function, because it is called on every keystroke.
        var direction = "";
        // When running on Xbox we need to ignore the arrow keys because the arrow keys are
        // are used to move the cursor in a text field. But if we are running in an iframe
        // we need to listen for gamepad key codes.
        // Note: this means that navigating focus in an iframe on Windows will not work.
        if (!WinJS.Utilities.hasWinRT ||
            Windows.Xbox) {
            switch (keyCode) {
                case WinJS.Utilities.Key.gamepadDPadUp:
                case WinJS.Utilities.Key.gamepadLeftThumbstickUp:
                    direction = "up";
                    break;
                case WinJS.Utilities.Key.gamepadDPadDown:
                case WinJS.Utilities.Key.gamepadLeftThumbstickDown:
                    direction = "down";
                    break;
                case WinJS.Utilities.Key.gamepadDPadLeft:
                case WinJS.Utilities.Key.gamepadLeftThumbstickLeft:
                    direction = "left";
                    break;
                case WinJS.Utilities.Key.gamepadDPadRight:
                case WinJS.Utilities.Key.gamepadLeftThumbstickRight:
                    direction = "right";
                    break;
                default:
                    return null;
            }
        } else {
            switch (keyCode) {
                case WinJS.Utilities.Key.upArrow:
                    direction = "up";
                    break;
                case WinJS.Utilities.Key.downArrow:
                    direction = "down";
                    break;
                case WinJS.Utilities.Key.leftArrow:
                    direction = "left";
                    break;
                case WinJS.Utilities.Key.rightArrow:
                    direction = "right";
                    break;
                default:
                    return null;
            }
        }

        var nextFocusElement = null;

        // If findNextFocusElement was called programmatically, the function should always return a value. The following if statement
        // ensures that even if the _focusRoot is null, the function will return a value.
        if (wasCalledProgramatically &&
            !_focusRoot) {
            _focusRoot = document.body;
            _isFakeFocusRootSet = true;
        }

        if (!_focusRoot ||
            (WinJS.Utilities.hasWinRT && Windows.ApplicationModel.DesignMode.designModeEnabled)) {
            return null;
        }

        if (!_focusRoot.getElementsByTagName) {
            throw new WinJS.ErrorFromName("XboxJS.UI.AutomaticFocus.InvalidFocusRoot", strings.invalidFocusRoot);
        }

        // Get the bounding rectangle of the reference element to use later for comparison with potential elements
        var referenceElement = null;
        var referenceBoundingRectangle = {};

        // If we were called programmatically, the caller may have passed in a rectangle for us to
        // as the referenceBoundingRectangle.
        if (focusHintRectangle) {
            referenceBoundingRectangle = {
                top: Math.floor(focusHintRectangle.top),
                bottom: Math.floor(focusHintRectangle.top + focusHintRectangle.height),
                right: Math.floor(focusHintRectangle.left + focusHintRectangle.width),
                left: Math.floor(focusHintRectangle.left),
                height: Math.floor(focusHintRectangle.height),
                width: Math.floor(focusHintRectangle.width),
            };

            // If we were called programmatically we need to reset the manifolds to the focusHintRectangle,
            // because we don't know where focus came from.
            if (wasCalledProgramatically) {
                _horizontalManifold = {
                    min: referenceBoundingRectangle.top,
                    max: referenceBoundingRectangle.bottom
                };
                _verticalManifold = {
                    min: referenceBoundingRectangle.left,
                    max: referenceBoundingRectangle.right
                };
            }

        } else {

            // We will use the last focused element as the reference rectangle, unless there was no
            // last focused element. In that case, we will use the upper, left corner.
            // Note: We need to check to make sure 'parentNode' is not null otherwise there is a case
            // where lastFocusedElement is defined, but calling getBoundingClientRect will throw a native exception.
            // This case happens if the innerHTML of the parent of the lastFocusElement is set to "".
            if (lastFocusedElement &&
                lastFocusedElement.parentNode) {

                referenceElement = lastFocusedElement;

                // If the current focused element has a tabIndex of -1, the focus algorithm should not run.
                // This enables Trident controls to work with the automatic focus algorithm. To illustrate the 
                // problem and the solution, we use the <select> tag as an example.
                // 
                // Problem:
                //    1. The user invokes the popup on a select tag.
                //    2. They use directional navigation to select options within the <select>.
                //    3. Rather than cycling the options, focus dismisses the popup and moves 
                //       to the next element. 
                //    4. This is incorrect. The user expected the directional keys to cycle between
                //       options when the <select> popup is open.
                //
                // Solution:
                //    1. When the user opens the select tag, Trident will set the tabIndex to -1
                //    2. If the user navigates using directional keys or gamepad, the algorithm will not
                //       run and focus will remain on the <select> tag as is expected. This allows Trident
                //       to handle directional input and move focus between the option in the <select> popup.
                //    3. When the user dismisses the popup, Trident will set the tabIndex back to its
                //       previous value.
                //    4. Because tabIndex was reset from -1, when the user navigates, the automatic focus 
                //       algorithm will run and move focus to the correct element.
                if (referenceElement.tabIndex === -1) {
                    return null;
                }

                var referenceBoundingRectangleObject = referenceElement.getBoundingClientRect();
                referenceBoundingRectangle = {
                    top: Math.floor(referenceBoundingRectangleObject.top),
                    bottom: Math.floor(referenceBoundingRectangleObject.bottom),
                    right: Math.floor(referenceBoundingRectangleObject.right),
                    left: Math.floor(referenceBoundingRectangleObject.left),
                    height: Math.floor(referenceBoundingRectangleObject.height),
                    width: Math.floor(referenceBoundingRectangleObject.width),
                };

            } else {

                // We set the top, left, bottom and right properties of the referenceBoundingRectangle to '-1' 
                // (as opposed to '0') because we want to make sure that even elements that are up to the edge 
                // of the screen can receive focus.
                referenceBoundingRectangle = {
                    top: -1,
                    bottom: -1,
                    right: -1,
                    left: -1,
                    height: 0,
                    width: 0
                };
            }
        }

        // We call prevent default otherwise if the currently focused element is
        // within a scrollable region, the 'keydown' event will propagate to the scrollbars
        // and Internet Explorer will interpret the 'keydown' as a desire to move the scrollbars.
        if (eventObject) {
            eventObject.preventDefault();
        }

        var allElements = _focusRoot.getElementsByTagName("*");

        var currentBestScore = 0;
        var currentBestIndex = -1;

        if (referenceElement) {
            var manualOverrideOptions = referenceElement.getAttribute(_overrideAutomaticFocusAttribute);

            // Before we handle focus manually, we need to make sure _navigateFocusInternal was not called programmatically.
            // If the developer called this method programmatically, he or she expects the element that gets returned from the 
            // findNextFocusElement method is the element that would have been picked by the heuristic algorithm rather than 
            // the element specified by the focus override.
            if (manualOverrideOptions &&
                (!wasCalledProgramatically || __msWinJSTestEnabledInternal)) {
                var usedManualFocus = _handleManualFocus(direction, manualOverrideOptions, keyCode);

                // If we've found an element to navigate to then we're done, otherwise the algorithm continues
                if (usedManualFocus) {
                    return null;
                }
            }
        }

        if (!_horizontalManifold) {
            _horizontalManifold = {
                min: referenceBoundingRectangle.top,
                max: referenceBoundingRectangle.bottom
            };
        }
        if (!_verticalManifold) {
            _verticalManifold = {
                min: referenceBoundingRectangle.left,
                max: referenceBoundingRectangle.right
            };
        }

        // Loop through all child elements of the focusRoot and apply the rules of the focus algorithm
        for (var i = 0; i < allElements.length; i++) {

            var currentPotentialElement = allElements[i];

            if (!_isFocusableElement(currentPotentialElement)) {
                continue;
            }

            // Note: We wait to perform the relatively expensive operations until after all the if statements
            // above so we can get a slight performance improvement.
            var score = 0;
            var primaryAxisDistance = _maxDistance;
            var secondaryAxisDistance = _maxDistance;
            var percentInManifoldShadow = 0;
            var percentInShadow = 0;

            var currentPotentialElementRectangleObject = currentPotentialElement.getBoundingClientRect();
            var currentPotentialElementRectangle = {
                top: Math.floor(currentPotentialElementRectangleObject.top),
                bottom: Math.floor(currentPotentialElementRectangleObject.bottom),
                right: Math.floor(currentPotentialElementRectangleObject.right),
                left: Math.floor(currentPotentialElementRectangleObject.left),
                height: Math.floor(currentPotentialElementRectangleObject.height),
                width: Math.floor(currentPotentialElementRectangleObject.width)
            };

            // Skip elements that have either a width or zero or a height of zero
            if (currentPotentialElementRectangle.width === 0 ||
                currentPotentialElementRectangle.height === 0) {
                continue;
            }

            var referenceMin;
            var referenceMax;
            var potentialMin;
            var potentialMax;

            // Make sure the current potential element is not the reference element
            if (currentPotentialElement !== referenceElement) {

                switch (direction) {
                    case "right":
                        // Make sure we don't evaluate any potential elements to the left of the reference element
                        if (currentPotentialElementRectangle.right <= referenceBoundingRectangle.right) {
                            break;
                        }

                        referenceMin = referenceBoundingRectangle.top;
                        referenceMax = referenceBoundingRectangle.bottom;
                        potentialMin = currentPotentialElementRectangle.top;
                        potentialMax = currentPotentialElementRectangle.bottom;

                        percentInShadow = _calculatePercentInShadow(referenceMin, referenceMax, potentialMin, potentialMax);
                        primaryAxisDistance = currentPotentialElementRectangle.left - referenceBoundingRectangle.right;

                        if (percentInShadow > 0) {
                            percentInManifoldShadow = _calculatePercentInManifoldShadow(_horizontalManifold.min, _horizontalManifold.max, potentialMin, potentialMax);
                            secondaryAxisDistance = _maxDistance;
                        } else {
                            // If the potential element is not in the shadow, then we calculate secondary axis distance
                            if (currentPotentialElementRectangle.top < referenceBoundingRectangle.top) {
                                secondaryAxisDistance = Math.abs(referenceBoundingRectangle.top - currentPotentialElementRectangle.bottom);
                            } else {
                                secondaryAxisDistance = Math.abs(currentPotentialElementRectangle.top - referenceBoundingRectangle.bottom);
                            }
                        }
                        break;
                    case "left":
                        // Make sure we don't evaluate any potential elements to the right of the reference element
                        if (currentPotentialElementRectangle.left >= referenceBoundingRectangle.left) {
                            break;
                        }

                        referenceMin = referenceBoundingRectangle.top;
                        referenceMax = referenceBoundingRectangle.bottom;
                        potentialMin = currentPotentialElementRectangle.top;
                        potentialMax = currentPotentialElementRectangle.bottom;

                        percentInShadow = _calculatePercentInShadow(referenceMin, referenceMax, potentialMin, potentialMax);
                        primaryAxisDistance = referenceBoundingRectangle.left - currentPotentialElementRectangle.right;

                        if (percentInShadow > 0) {
                            percentInManifoldShadow = _calculatePercentInManifoldShadow(_horizontalManifold.min, _horizontalManifold.max, potentialMin, potentialMax);
                            secondaryAxisDistance = _maxDistance;
                        } else {

                            // If the potential element is not in the shadow, then we calculate secondary axis distance
                            if (currentPotentialElementRectangle.top < referenceBoundingRectangle.top) {
                                secondaryAxisDistance = Math.abs(referenceBoundingRectangle.top - currentPotentialElementRectangle.bottom);
                            } else {
                                secondaryAxisDistance = Math.abs(currentPotentialElementRectangle.top - referenceBoundingRectangle.bottom);
                            }
                        }
                        break;
                    case "up":
                        // Make sure we don't evaluate any potential elements below the reference element
                        if (currentPotentialElementRectangle.top >= referenceBoundingRectangle.top) {
                            break;
                        }

                        referenceMin = referenceBoundingRectangle.left;
                        referenceMax = referenceBoundingRectangle.right;
                        potentialMin = currentPotentialElementRectangle.left;
                        potentialMax = currentPotentialElementRectangle.right;

                        percentInShadow = _calculatePercentInShadow(referenceMin, referenceMax, potentialMin, potentialMax);
                        primaryAxisDistance = referenceBoundingRectangle.top - currentPotentialElementRectangle.bottom;

                        if (percentInShadow > 0) {
                            percentInManifoldShadow = _calculatePercentInManifoldShadow(_verticalManifold.min, _verticalManifold.max, potentialMin, potentialMax);
                            secondaryAxisDistance = _maxDistance;
                        } else {

                            // If the potential element is not in the shadow, then we calculate secondary axis distance
                            if (currentPotentialElementRectangle.left < referenceBoundingRectangle.left) {
                                secondaryAxisDistance = Math.abs(referenceBoundingRectangle.left - currentPotentialElementRectangle.right);
                            } else {
                                secondaryAxisDistance = Math.abs(currentPotentialElementRectangle.left - referenceBoundingRectangle.right);
                            }
                        }
                        break;
                    case "down":
                        // Make sure we don't evaluate any potential elements above the reference element
                        if (currentPotentialElementRectangle.bottom <= referenceBoundingRectangle.bottom) {
                            break;
                        }

                        referenceMin = referenceBoundingRectangle.left;
                        referenceMax = referenceBoundingRectangle.right;
                        potentialMin = currentPotentialElementRectangle.left;
                        potentialMax = currentPotentialElementRectangle.right;

                        percentInShadow = _calculatePercentInShadow(referenceMin, referenceMax, potentialMin, potentialMax);
                        primaryAxisDistance = currentPotentialElementRectangle.top - referenceBoundingRectangle.bottom;

                        if (percentInShadow > 0) {
                            percentInManifoldShadow = _calculatePercentInManifoldShadow(_verticalManifold.min, _verticalManifold.max, potentialMin, potentialMax);
                            secondaryAxisDistance = _maxDistance;
                        } else {

                            // If the potential element is not in the shadow, then we calculate secondary axis distance
                            if (currentPotentialElementRectangle.left < referenceBoundingRectangle.left) {
                                secondaryAxisDistance = Math.abs(referenceBoundingRectangle.left - currentPotentialElementRectangle.right);
                            } else {
                                secondaryAxisDistance = Math.abs(currentPotentialElementRectangle.left - referenceBoundingRectangle.right);
                            }
                        }

                        break;
                }

                if (primaryAxisDistance >= 0) {

                    // The score needs to be a positive number so we make these distances positive numbers
                    primaryAxisDistance = _maxDistance - primaryAxisDistance;
                    secondaryAxisDistance = _maxDistance - secondaryAxisDistance;

                    // Potential elements in the shadow get a multiplier to their final score
                    if (percentInShadow >= inShadowThreshold) {
                        percentInShadow = 1;

                        primaryAxisDistance *= 2;
                    }

                    score = percentInShadow * percentInShadowWeight +
                            primaryAxisDistance * primaryAxisDistanceWeight +
                            secondaryAxisDistance * secondaryAxisDistanceWeight +
                            percentInManifoldShadow * percentInManifoldShadowWeight;

                    if (score > currentBestScore) {
                        currentBestScore = score;
                        currentBestIndex = i;
                    }
                }
            }
        }

        // Move keyboard focus to the element with the highest score
        if (currentBestIndex >= 0) {
            var newFocusedElement = allElements[currentBestIndex];

            // For the 90% case, we don't want to move focus unless nextFocusedElement is not the
            // same as lastFocusedElement (meaning we've found a new element to set focus on).
            // However, iframes present the following problem:
            //
            //..╔════════════════════╗...................................
            //..║                    ║...................................
            //..║                    ║...................................
            //..║ lastFocusedElement ║...╔════════════════════════╗......
            //..║                    ║...║                        ║......
            //..║                    ║...║       iframe           ║......
            //..╚════════════════════╝...║                        ║......
            //...........................║          ╔══════════╗  ║......
            //...........................║          ║ element1 ║  ║......
            //...........................║          ╚══════════╝  ║......
            //...........................╚════════════════════════╝......
            //
            // In the picture above:
            //  1. Focus starts on "lastFocusedElement".
            //  2. The user presses right and the developer programmatically moves focus to "element1".
            //  3. The user presses left. To move focus to the left the developer calls findNextFocusElement(keyCode, focusHintRectangle).  
            //     They pass leftArrow as the keyCode and the bounding rectangle of element1 as the focusHintRectangle.
            //  4. If the if statement below only checked whether nextFocusedElement !== lastFocusedElement, then
            //     findNextFocusElement will return null. However, it should returned lastFocusedElement.
            //     
            // To provide a solution to this problem, we need the if statement to do more than check if newFocusedElement !== lastFocusedElement.
            // We also need to check:
            //  * If the focus algorithm was called programmatically. If it was not, then we don't care about 
            //    the case described above. Automatically moving focus between iframes is not supported without *some* developer code.
            //  * If document.frames.length is defined which tells us whether there are iframes on the page.
            //  * If top !== self. This tells us if we are being called from within an iframe.
            //
            // If we've detected we are in the "iframe" case, then we set nextFocusedElement to newFocusedElement even if
            // newFocusedElement is the same as lastFocusedElement.
            if (newFocusedElement !== lastFocusedElement ||
                top !== self) {
                nextFocusElement = newFocusedElement;
            }

            // Adjust the horizontal and vertical manifolds
            var newFocusedElementRectangleObject = newFocusedElement.getBoundingClientRect();
            var newFocusedElementRectangle = {
                top: Math.floor(newFocusedElementRectangleObject.top),
                bottom: Math.floor(newFocusedElementRectangleObject.bottom),
                right: Math.floor(newFocusedElementRectangleObject.right),
                left: Math.floor(newFocusedElementRectangleObject.left),
                height: Math.floor(newFocusedElementRectangleObject.height),
                width: Math.floor(newFocusedElementRectangleObject.width),
            };

            if (direction === "right" || direction === "left") {
                _horizontalManifold.min = Math.max(newFocusedElementRectangle.top, referenceBoundingRectangle.top, _horizontalManifold.min);
                _horizontalManifold.max = Math.min(newFocusedElementRectangle.bottom, referenceBoundingRectangle.bottom, _horizontalManifold.max);

                // It's possible to get into a situation where the newFocusedElement to the right / left has no overlap with the current edge.
                // For instance, in the example below the right edge of the reference element has no overlap with the right edge of the newFocusedElement:
                //
                //..╔══════════════╗..........................
                //..║   reference  ║..........................
                //..╚══════════════╝..........................
                //.....................╔═══════════════════╗..
                //.....................║                   ║..
                //.....................║ newFocusedElement ║..
                //.....................║                   ║..
                //.....................╚═══════════════════╝..
                //
                // If that is the case, we need to reset the horizontal manifold to the edge of the newFocusedElement.
                if (_horizontalManifold.max <= _horizontalManifold.min) {
                    _horizontalManifold.min = newFocusedElementRectangle.top;
                    _horizontalManifold.max = newFocusedElementRectangle.bottom;
                }

                _verticalManifold.min = newFocusedElementRectangle.left;
                _verticalManifold.max = newFocusedElementRectangle.right;
            } else {
                _verticalManifold.min = Math.max(newFocusedElementRectangle.left, referenceBoundingRectangle.left, _verticalManifold.min);
                _verticalManifold.max = Math.min(newFocusedElementRectangle.right, referenceBoundingRectangle.right, _verticalManifold.max);

                // It's possible to get into a situation where the newFocusedElement to the up / down has no overlap with the current edge.
                // For instance, in the example below the bottom edge of the reference element has no overlap with the bottom edge of the newFocusedElement:
                //
                //..╔══════════════╗..........................
                //..║   reference  ║..........................
                //..╚══════════════╝..........................
                //.....................╔═══════════════════╗..
                //.....................║                   ║..
                //.....................║ newFocusedElement ║..
                //.....................║                   ║..
                //.....................╚═══════════════════╝..
                //
                // If that is the case, we need to reset the vertical manifold to the edge of the newFocusedElement.
                if (_verticalManifold.max <= _verticalManifold.min) {
                    _verticalManifold.min = newFocusedElementRectangle.left;
                    _verticalManifold.max = newFocusedElementRectangle.right;
                }

                _horizontalManifold.min = newFocusedElementRectangle.top;
                _horizontalManifold.max = newFocusedElementRectangle.bottom;
            }
        }

        msWriteProfilerMark("XboxJS.UI.AutomaticFocus:findNextFocusElement,StopTM");

        // If the developer calls the navigate
        if (!wasCalledProgramatically) {
            if (nextFocusElement) {

                // Note: We don't want to focus on an 'iframe'. If we did, then elements inside the 'iframe' would
                // not receive focus.
                if (_needToMessageChildIframes &&
                    nextFocusElement.tagName === "IFRAME") {

                    var focusHintRectangle = {};
                    if (lastFocusedElement) {
                        // Use the current focused element as the focusHintRectangle
                        var lastFocusedElementBoundingRectangle = lastFocusedElement.getBoundingClientRect();
                        // Note:  We cannot set focusHintRectangle = lastFocusedElement.getBoundingClientRect(). Otherwise we will get a data clone
                        // error because we are trying to pass a DOM element across the iframe boundary. So instead, we make a copy of the element's
                        // properties that we are interested in.
                        focusHintRectangle = {
                            top: lastFocusedElementBoundingRectangle.top,
                            bottom: lastFocusedElementBoundingRectangle.bottom,
                            right: lastFocusedElementBoundingRectangle.right,
                            left: lastFocusedElementBoundingRectangle.left,
                            height: lastFocusedElementBoundingRectangle.height,
                            width: lastFocusedElementBoundingRectangle.width
                        };
                    } else {
                        // We set the top, left, bottom and right properties of the referenceBoundingRectangle to '-1' 
                        // (as opposed to '0') because we want to make sure that even elements that are up to the edge 
                        // of the screen can receive focus.
                        var focusHintRectangle = {
                            top: -1,
                            bottom: -1,
                            right: -1,
                            left: -1,
                            height: 0,
                            width: 0
                        };
                    }

                    // Send messages to all registered iframes to see if they have elements that need to get focus.
                    for (var iFrame in _iFrameMap) {
                        var frame = _getFrameElement(iFrame);
                        if (frame) {
                            _iFrameMap[iFrame].window.postMessage({
                                ms__winJSAutomaticFocusControlMessage: {
                                    type: _VmType.requestFocusNavigation,
                                    keyCode: keyCode,
                                    focusHintRectangle: focusHintRectangle
                                }
                            }, _iFrameMap[iFrame].domain);
                        } else {
                            _iFrameMap[iFrame].window = null;
                            delete _iFrameMap[iFrame];
                        }
                    }
                }

                // We raise an event on the focusRoot before focus changes to give listeners
                // a chance to prevent the next focus target from receiving focus if they want.
                var eventProperties = { nextFocusElement: nextFocusElement, keyCode: keyCode, disableFocusSound: false };
                var wasEventCanceled = XboxJS.UI.AutomaticFocus.dispatchEvent(_focusChangingEvent, eventProperties);
                if (!wasEventCanceled) {
                    nextFocusElement.focus();
                    
                    if (!eventProperties.disableFocusSound) {
                        // Choose one of the 4 focus sounds to play at random
                        var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                        switch (indexOfFocusSoundToPlay) {
                            case 1:
                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus1) {
                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus1.play();
                                }
                                break;
                            case 2:
                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus2) {
                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus2.play();
                                }
                                break;
                            case 3:
                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus3) {
                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus3.play();
                                }
                                break;
                            case 4:
                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus4) {
                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus4.play();
                                }
                                break;
                            default:
                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus1) {
                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus1.play();
                                }
                                break;
                        }
                    }
                }
            } else {
                // Note: We don't want to focus on an 'iframe'. If we did, then elements inside the 'iframe' would
                // not receive focus.
                if (top !== self) {

                    // Use the current focused element as the focusHintRectangle
                    if (document.activeElement) {
                        var referenceElementBoundingRectangle = document.activeElement.getBoundingClientRect();
                        var focusHintRectangle = {
                            top: referenceElementBoundingRectangle.top,
                            bottom: referenceElementBoundingRectangle.bottom,
                            left: referenceElementBoundingRectangle.left,
                            right: referenceElementBoundingRectangle.right,
                            width: referenceElementBoundingRectangle.width,
                            height: referenceElementBoundingRectangle.height
                        };
                    }

                    // If we are in an 'iframe', then we send a message to our parent window to see if it has any
                    // elements that should receive focus.
                    window.parent.postMessage({
                        ms__winJSAutomaticFocusControlMessage: {
                            type: _VmType.requestFocusNavigation,
                            clientId: window.location.href,
                            keyCode: keyCode,
                            focusHintRectangle: focusHintRectangle,
                            screenTop: self.screenTop,
                            screenLeft: self.screenLeft
                        }
                    }, "*");
                }

                // Note: We still fire an event even if the focusRoot is null
                XboxJS.UI.AutomaticFocus.dispatchEvent(_focusChangingEvent, { nextFocusElement: nextFocusElement, keyCode: keyCode });
            }
        } else {
            // If _isFakeFocusRootSet is true then it means the actual _focusRoot was null (meaning automatic focus is disabled).
            // We need to set _focusRoot back to null so a keydown event, which will trigger this function, will not cause focus to move.
            if (_isFakeFocusRootSet) {
                _focusRoot = null;
                _isFakeFocusRootSet = false;
            }

            return nextFocusElement;
        }
    };

    var _calculatePercentInShadow = function (minimumReferenceCoordinate, maximumReferenceCoordinate, minimumPotentialCoordinate, maximumPotentialCoordinate) {
        /// Calculates the percentage of the potential element that is in the shadow of the reference element.
        /// with localized strings.

        if ((minimumReferenceCoordinate >= maximumPotentialCoordinate) ||
            (maximumReferenceCoordinate <= minimumPotentialCoordinate)) {
            return 0;
        }

        var pixelOverlapWithTheReferenceShadow = (Math.min(maximumReferenceCoordinate, maximumPotentialCoordinate) - Math.max(minimumReferenceCoordinate, minimumPotentialCoordinate));
        var potentialEdgeLength = maximumPotentialCoordinate - minimumPotentialCoordinate;
        var referenceEdgeLength = maximumReferenceCoordinate - minimumReferenceCoordinate;

        // If the reference element is bigger than the potential element, then we want to use the length of the reference's edge as the 
        // denominator when we calculate percentInShadow. Otherwise, if the potential element is bigger, we want to use the length
        // of the potential's edge when calculating percentInShadow.
        var comparisonEdgeLength = 0;
        if (referenceEdgeLength >= potentialEdgeLength) {
            comparisonEdgeLength = potentialEdgeLength;
        } else {
            comparisonEdgeLength = referenceEdgeLength;
        }

        var percentInShadow = 0;
        if (comparisonEdgeLength !== 0) {
            percentInShadow = Math.min(pixelOverlapWithTheReferenceShadow / comparisonEdgeLength, 1);
        } else {
            percentInShadow = 1;
        }

        return percentInShadow;
    };

    var _calculatePercentInManifoldShadow = function (minimumManifoldCoordinate, maximumManifoldCoordinate, minimumPotentialCoordinate, maximumPotentialCoordinate) {
        /// Calculates the percentage of the potential element that is in the shadow of the manifold.

        if ((minimumManifoldCoordinate >= maximumPotentialCoordinate) ||
            (maximumManifoldCoordinate <= minimumPotentialCoordinate)) {
            return 0;
        }

        // If the manifold is bigger than the potential element, then we want to use the length of the manifold's edge as the 
        // denominator when we calculate percentInShadow. Otherwise, if the potential element is bigger, we want to use the length
        // of the potential's edge when calculating percentInShadow.
        var pixelOverlapWithManifold = (Math.min(maximumManifoldCoordinate, maximumPotentialCoordinate) - Math.max(minimumManifoldCoordinate, minimumPotentialCoordinate));
        var potentialEdgeLength = maximumPotentialCoordinate - minimumPotentialCoordinate;
        var manifoldEdgeLength = maximumManifoldCoordinate - minimumManifoldCoordinate;

        var comparisonEdgeLength = 0;
        if (manifoldEdgeLength >= potentialEdgeLength) {
            comparisonEdgeLength = potentialEdgeLength;
        } else {
            comparisonEdgeLength = manifoldEdgeLength;
        }

        var percentInManifold = 0;
        if (comparisonEdgeLength !== 0) {
            percentInManifold = Math.min(pixelOverlapWithManifold / comparisonEdgeLength, 1);
        } else {
            percentInManifold = 1;
        }

        return percentInManifold;
    };

    // Helper function to determine if an element is in our list of focusable elements
    var _isFocusableElement = function (element) {

        // If the current potential element is not one of the tags we consider to be focusable, then exit
        var elementTagName = element.tagName;
        if (elementTagName !== "A" &&
            elementTagName !== "BUTTON" &&
            elementTagName !== "INPUT" &&
            elementTagName !== "SELECT" &&
            elementTagName !== "TEXTAREA" &&
            !WinJS.Utilities.hasClass(element, _focusableClass)) {
            return false;
        }

        // Skip disabled WinJS controls
        if (elementTagName === "DIV" &&
            element.winControl &&
            element.winControl.disabled) {
            return false;
        }

        // Skip elements that are hidden
        // Note: We don't check for opacity === 0, because the browser cannot tell us this value accurately.
        var style = element.currentStyle;
        if (element.tabIndex === -1 ||
            style.display === "none" ||
            style.visibility === "hidden" ||
            element.disabled) {
            return false;
        }

        return true;
    };

    var _onKeydown = function (eventObject) {
        _navigateFocusInternal(eventObject.keyCode, null, null, eventObject);
    };

    // Remember the size of the last focused element
    var _onFocusIn = function (eventObject) {

        // We need to check to make sure the element is on our list of focusable
        // otherwise focus could get "stuck" on a non-focusable element.
        var currentElement = eventObject.target;
        if (currentElement !== document.body &&
            _isFocusableElement(currentElement)) {
            lastFocusedElement = currentElement;
        }
    };

    var _handleManualFocus = function (direction, optionsAttribute, keyCode) {
        var newFocusElement = null;
        var selector = "";

        var options;
        options = WinJS.UI.optionsParser(optionsAttribute);

        switch (direction) {
            case "left":
                selector = options.left || options.Left;
                break;

            case "right":
                selector = options.right || options.Right;
                break;

            case "up":
                selector = options.up || options.Up;
                break;

            case "down":
                selector = options.down || options.Down;
                break;

            default:
                break;
        }

        if (selector) {
            newFocusElement = document.querySelector(selector);
        }

        if (newFocusElement) {

            // We raise an event on the focusRoot before focus changes to give listeners
            // a chance to prevent the next focus target from receiving focus if they want.
            var wasEventCanceled = XboxJS.UI.AutomaticFocus.dispatchEvent(_focusChangingEvent, { nextFocusElement: newFocusElement, keyCode: keyCode });
            if (!wasEventCanceled) {
                newFocusElement.focus();
            }

            if (document.activeElement === newFocusElement) {

                // Reset the manifolds
                _horizontalManifold = null;
                _verticalManifold = null;
            } else {
                newFocusElement = null;
            }
        }

        return newFocusElement;
    };

    // When the iframe is unloaded, remove it from the collection of registered child iframes
    var _onIFrameUnload = function (eventObject) {
        var iframeSrc = eventObject.target.location;
        if (_iFrameMap[iframeSrc]) {
            _iFrameMap[iframeSrc].window = null;
            delete _iFrameMap[iframeSrc];
        }

        eventObject.target.window.removeEventListener("unload", _onIFrameUnload);
    };

    // Listen for automatic focus related messages sent by child iframes or parent windows.
    function _onMessage(ev) {

        if (!(ev.isTrusted &&
            ev.data &&
            ev.data.ms__winJSAutomaticFocusControlMessage)) {
            // Not trusted or not a message meant for us
            return;
        }

        var messageData = ev.data.ms__winJSAutomaticFocusControlMessage;
        var _messageType = messageData.type;

        switch (_messageType) {
            case _VmType.registerChild:
                var source = _getFrameElement(messageData.clientId);
                if (!source) {
                    return;
                }

                if (_iFrameMap[messageData.clientId]) {
                    WinJS.ErrorFromName("XboxJS.UI.AutomaticFocus.failedDuplicateIFrameRegistration", strings.automaticFocusFailedDuplicateIFrameRegistration);
                    return;
                }

                _iFrameMap[messageData.clientId] = { status: 0, window: source.contentWindow, domain: ev.origin };

                // Register to listen to unload events
                //ev.source.window.addEventListener("unload", _onIFrameUnload);
                _needToMessageChildIframes = true;
                break;
            case _VmType.unregisterChild:
                var source = _getFrameElement(messageData.clientId);
                if (!source) {
                    return;
                }

                if (_iFrameMap[messageData.clientId]) {
                    _iFrameMap[message.clientId].window = null;
                    delete _iFrameMap[message.clientId];
                }

                // Unregister window events
                //ev.source.window.removeEventListener("unload", _onIFrameUnload);
                break;
            case _VmType.requestFocusNavigation:
                var focusHintRectangle = messageData.focusHintRectangle;

                // The if statement checks to see if we received a message from a child iFrame. If so, then we need
                // to add the 'iframe's window offset to the screen coordinates it is reporting for it's last focused element.
                // Otherwise, we are a child 'iframe' receiving a message from a parent window and we need to subtract the offset.
                // If you are wondering why there are two subtractions it is to handle the case of an 'iframe' within an 'iframe'.
                if (self !== top) {

                    focusHintRectangle.top -= self.screenTop;
                    focusHintRectangle.bottom -= self.screenTop;
                    focusHintRectangle.left -= self.screenLeft;
                    focusHintRectangle.right -= self.screenLeft;
                } else {
                    // If we are in the parent window and an 'iframe' does not have focus then we should not processing window messages.
                    if (document.activeElement &&
                        document.activeElement.tagName !== "IFRAME") {
                        return;
                    }

                    focusHintRectangle.top += messageData.screenTop;
                    focusHintRectangle.bottom += messageData.screenTop;
                    focusHintRectangle.left += messageData.screenLeft;
                    focusHintRectangle.right += messageData.screenLeft;
                }

                // We really want to call the internal method
                _navigateFocusInternal(messageData.keyCode, focusHintRectangle, false, null);
                break;
            default:
                break;
        }
    };

    WinJS.Namespace.define("XboxJS.UI.AutomaticFocus", {

        findNextFocusElement: _findNextFocusElement,
        /// <signature helpKeyword="XboxJS.UI.AutomaticFocus.findNextFocusElement">
        /// <summary locid="XboxJS.UI.AutomaticFocus.findNextFocusElement">
        /// Programmatically determines the next element that should receive focus based on a key code that represents a direction.
        /// </summary>
        /// <param name="keyCode" type="Number" locid="XboxJS.AutomaticFocus.findNextFocusElement_p:keyCode">
        /// The numeric value of the key code that was came as input from the user.
        /// </param>
        /// <param name="focusHintRectangle" type="Object" locid="XboxJS.AutomaticFocus.findNextFocusElement_p:focusHintRectangle">
        /// A rectangle that represents the size and location of the last focused element.
        /// </param>
        /// <returns type="Object" domElement="true" optional="true" locid="XboxJS.AutomaticFocus.findNextFocusElement_returnValue">
        /// The element that the automatic focus algorithm decided should receive focus.
        /// </returns>
        /// </signature>

        /// <field type="Element" locid="XboxJS.UI.AutomaticFocus.focusRoot" helpKeyword="XboxJS.UI.AutomaticFocus.focusRoot">
        /// Gets or sets the root of the focus tree. If the focusRoot is not null, the focus
        /// algorithm will consider all child elements of the focusRoot as potential elements to give focus to.
        /// 
        /// This property is useful if you need to restrict focus to an area of the UI. For instance, in the
        /// case of a modal dialog.
        /// </field>
        focusRoot: {
            get: function () {
                return _focusRoot;
            },
            set: function (value) {
                _focusRoot = value;
                _wasFocusRootSetProgrammatically = true;

                if (XboxJS.UI.Voice) {
                    XboxJS.UI.Voice.refreshVoiceElements();
                }
            }
        },

        /// <field type="Number" locid="XboxJS.UI.AutomaticFocus.VmType" helpKeyword="XboxJS.UI.AutomaticFocus.VmType">
        /// An enumeration of post message types used to enable automatic focus across iframes.
        /// </field>
        VmType: _VmType,
        
        _sounds: {
            initialized: false,
            elementFocus1: null,
            elementFocus2: null,
            elementFocus3: null,
            elementFocus4: null
        },
        __msWinJSTestEnabled: {
            get: function() {
                return __msWinJSTestEnabledInternal;
            },
            set: function(value) {
                __msWinJSTestEnabledInternal = value;
            }
        }
    });
    
    if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.AutomaticFocus._sounds.initialized) {
        XboxJS.UI.AutomaticFocus._sounds.elementFocus1 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus1"));
        XboxJS.UI.AutomaticFocus._sounds.elementFocus2 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus2"));
        XboxJS.UI.AutomaticFocus._sounds.elementFocus3 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus3"));
        XboxJS.UI.AutomaticFocus._sounds.elementFocus4 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus4"));
        XboxJS.UI.AutomaticFocus._sounds.initialized = true;
    };

    // Note: We define a dummy prototype, because the event mixin needs a prototype
    // property to attach the event methods to.
    XboxJS.UI.prototype = XboxJS.UI.AutomaticFocus;
    WinJS.Class.mix(XboxJS.UI, WinJS.Utilities.eventMixin);
})();


(function dataModelInit() {
    "use strict";

    WinJS.Namespace.define("XboxJS.Data", {
        /// <summary locid="XboxJS.Data.DataModel">
        /// A class to represent a service data model.
        /// </summary>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        DataModel: WinJS.Namespace._lazy(function () {
            return WinJS.Class.define(null, {
                initialize: function (item) {
                    /// <signature helpKeyword="XboxJS.Data.DataModel.initialize">
                    /// <summary locid="XboxJS.Data.DataModel.initialize">
                    /// Finds all methods on the class, calls them, and stores their result in a property
                    /// with the same name.
                    /// </summary>
                    /// </signature>
                    var modelInstance = this;
                    var model = Object.getPrototypeOf(modelInstance);
                    var promises = [];

                    //Once we have an instance, calling initialize again doesn't make sense
                    delete modelInstance.initialize;

                    //Skip the constructor and initialize methods
                    for (var func in model) {
                        if (typeof (modelInstance[func]) === "function" &&
                            func !== "initialize" && func !== "constructor" && !{}.hasOwnProperty(func)) {
                            //call it
                            var result = modelInstance[func](item);

                            //add the promise to the list, then cache the result in the object
                            if (result && result.then) {
                                promises.push(modelInstance._setProperty(func, result));
                                //no promise returned, just store teh result in the object
                            } else {
                                modelInstance[func] = result;
                            }
                        }
                    }

                    //wait for all the promises to finish. We complete on the instance to allow datamodel chaining
                    return WinJS.Promise.join(promises).then(function () {
                        return WinJS.Promise.wrap(modelInstance);
                    });
                },
                _setProperty: function (func, promise) {
                    var that = this;
                    return promise.then(function (result) {
                        that[func] = result;
                    });
                }
            });
        })
    });
})();


(function dataProviderInit() {
    "use strict";

    WinJS.Namespace.define("XboxJS.Data.ContentType", {
        /// <field type="String" locid="XboxJS.Data.ContentType.album" helpKeyword="XboxJS.Data.ContentType.album">
        /// Album content type.
        /// </field>
        album: "album",

        /// <field type="String" locid="XboxJS.Data.ContentType.movie" helpKeyword="XboxJS.Data.ContentType.movie">
        /// Movie content type.
        /// </field>
        movie: "movie",

        /// <field type="String" locid="XboxJS.Data.ContentType.musicArtist" helpKeyword="XboxJS.Data.ContentType.musicArtist">
        /// Movie content type.
        /// </field>
        musicArtist: "musicArtist",

        /// <field type="String" locid="XboxJS.Data.ContentType.track" helpKeyword="XboxJS.Data.ContentType.track">
        /// Track content type.
        /// </field>
        track: "track",

        /// <field type="String" locid="XboxJS.Data.ContentType.tvShow" helpKeyword="XboxJS.Data.ContentType.tvShow">
        /// TV Show content type.
        /// </field>
        tvShow: "tvShow",

        /// <field type="String" locid="XboxJS.Data.ContentType.tvEpisode" helpKeyword="XboxJS.Data.ContentType.tvEpisode">
        /// TV Episode content type.
        /// </field>
        tvEpisode: "tvEpisode",

        /// <field type="String" locid="XboxJS.Data.ContentType.tvSeries" helpKeyword="XboxJS.Data.ContentType.tvSeries">
        /// TV Series content type.
        /// </field>
        tvSeries: "tvSeries",

        /// <field type="String" locid="XboxJS.Data.ContentType.tvSeason" helpKeyword="XboxJS.Data.ContentType.tvSeason">
        /// TV Season content type.
        /// </field>
        tvSeason: "tvSeason",

        /// <field type="String" locid="XboxJS.Data.ContentType.webVideo" helpKeyword="XboxJS.Data.ContentType.webVideo">
        /// Short form web content or user generated video.
        /// </field>
        webVideo: "webVideo",

        /// <field type="String" locid="XboxJS.Data.ContentType.webVideoCollection" helpKeyword="XboxJS.Data.ContentType.webVideoCollection">
        /// A collection of web videos such as videos from a playlist or in a subscription.
        /// </field>
        webVideoCollection: "webVideoCollection"
    });

    WinJS.Namespace.define("XboxJS.Data", {
        /// <summary locid="XboxJS.Data.DataProvider">
        /// A class to represent a service data provider.
        /// </summary>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        DataProvider: WinJS.Namespace._lazy(function () {
            return WinJS.Class.define(function () {
                /// <signature helpKeyword="XboxJS.Data.DataProvider">
                /// <summary locid="XboxJS.Data.DataProvider.constructor">
                /// Creates a new DataProvider instance
                /// </summary>
                /// <returns type="XboxJS.Data.DataProvider" locid="XboxJS.Data.DataProvider.constructor_returnValue">
                /// The new DataProvider
                /// </returns>
                /// </signature>
                this._baseDataProviderConstructor();
            }, {
                // returns a function that wraps the function on the child data provider
                // in order to wrap the results in the appropriate dataModel, and provide caching
                _generateDataMethod: function (providerInstance, DataModel, innerMethod) {
                    var that = this;
                    return function wrappedDataMethod() {
                        var outerMethod = wrappedDataMethod;

                        // we have some cached data, just return that
                        if (outerMethod.items && outerMethod.items.length > 0) {
                            return WinJS.Promise.wrap(outerMethod.items);
                        } else {
                            //call the sub method with the arguments we were called with
                            var result = innerMethod.apply(providerInstance, arguments);

                            if (result && result.then) {
                                return result.then(function (result) {
                                    if (result) {
                                        return that._wrapData(result, DataModel, outerMethod);
                                    }
                                    else {
                                        // if we got no results, return an empty array
                                        return WinJS.Promise.wrap([]);
                                    }
                                });
                            } else {
                                if (result) {
                                    return that._wrapData(result, DataModel, outerMethod);
                                }
                                else {
                                    // if we got no results, return an empty array
                                    return WinJS.Promise.wrap([]);
                                }
                            }
                        }
                    };
                },
                _initializeData: function (item, resultData) {
                    return item.initialize(resultData);
                },
                _wrapData: function (result, DataModel, method) {
                    var that = this;
                    var data = [];
                    var promises = [];

                    // for each item, wrap it in the correct dataModel, and cache the result
                    for (var i = 0; i < result.length; i++) {
                        //if this is a real item
                        if (result[i]) {
                            var item = new DataModel();
                            item.index = item.index || i;
                            data.push(item);
                            promises.push(that._initializeData(item, result[i]));
                        }
                    }

                    // when done, return all the dataModel objects
                    return WinJS.Promise.join(promises).then(function () {
                        return new WinJS.Promise(function (complete, err) {
                            // if the inner method has requested that we don't cache its data, then don't
                            if (method.items) {
                                method.items = data;
                            }
                            complete(data);
                        });
                    });
                },
                // find all the dataProvider objects, and wrap their methods in methods of the same name
                _baseDataProviderConstructor: function () {
                    var providerInstance = this;
                    var provider = Object.getPrototypeOf(providerInstance);
                    var rootDataModel = null;

                    for (var prop in provider) {
                        // do we have a root level data model
                        if (provider.hasOwnProperty(prop) && prop === "DataModel") {
                            rootDataModel = provider[prop];
                            // we have a root level data model, so we need to wrap root level methods
                        } else if (provider.hasOwnProperty(prop) && rootDataModel &&
                            typeof providerInstance[prop] === "function") {
                            providerInstance[prop] = this._generateDataMethod(providerInstance, rootDataModel, providerInstance[prop]);
                            providerInstance[prop].items = [];
                            //inner object
                        } else if (provider.hasOwnProperty(prop) && typeof (providerInstance[prop]) === "object") {
                            // if this object has a datamodel property, we have a dataModel object to process
                            if (provider[prop].hasOwnProperty("DataModel")) {
                                // override the property on the instance so we don't step over the parent property
                                providerInstance[prop] = {};

                                for (var func in provider[prop]) {
                                    // if this property is a function
                                    if (provider[prop].hasOwnProperty(func) && typeof (provider[prop][func]) === "function" && func !== "DataModel") {
                                        // generate a new wrapped method, and initialize the cache
                                        providerInstance[prop][func] = this._generateDataMethod(providerInstance, provider[prop].DataModel, provider[prop][func]);
                                        providerInstance[prop][func].items = [];
                                    }
                                }
                            }
                        }
                    }
                }
            });
        })
    });
})();


(function listPickerInit() {
    "use strict";

    var _changeEventName = "change";

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.ListPicker">
        /// A control that allows users to select one or more items from a set of options.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.ListPicker.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.ListPicker.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.ListPicker" data-win-options="{ label: 'Choose Filter', items: myFilterOptions }"></div>]]></htmlSnippet>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.WinJS.1.0/css/ui-dark.css" shared="true" />
        ListPicker: WinJS.Namespace._lazy(function () {
            // Statics
            var strings = {
                get invalidSelectionMode() { return WinJS.Resources._getWinJSString("tv/invalidSelectionMode").value; },
                get listPickerSelectedItemsCount() { return WinJS.Resources._getWinJSString("tv/listPickerSelectedItemsCount").value; }
            };

            var ListPicker = WinJS.Class.define(function (element, options) {
                /// <signature helpKeyword="XboxJS.UI.ListPicker">
                /// <summary locid="XboxJS.UI.ListPicker.constructor">
                /// Creates a new ListPicker control.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.ListPicker.constructor_p:element">
                /// The DOM element that hosts the ListPicker control.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.ListPicker.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.ListPicker" locid="XboxJS.UI.ListPicker.constructor_returnValue">
                /// The new ListPicker control.
                /// </returns>
                /// </signature>

                this._element = element || document.createElement("div");
                options = options || {};
                this._element.winControl = this;

                this._disposed = false;
                this._label = "";
                this._listPickerFlyout = new WinJS.UI.Flyout();
                this._flyoutContainerElement = this._listPickerFlyout.element.querySelector(".win-overlay-container");
                this._itemsWrapper = null;
                this._pendingRefresh = true;
                this._items = null;
                this._dataWinVoiceOverride = null;
                this._listPickerButtonLabel = null;
                this._listPickerItemContainers = [];
                this._dataListeners = {
                    itemchanged: this._dataItemChangedHandler.bind(this),
                    iteminserted: this._dataItemInsertedHandler.bind(this),
                    itemmoved: this._dataItemMovedHandler.bind(this),
                    itemremoved: this._dataItemRemovedHandler.bind(this),
                    reload: this._dataReloadHandler.bind(this),
                };
                this._refreshScrollIndicatorsBind = this._refreshScrollIndicators.bind(this);
                this._selectedItemsCountLabel = null;
                this._pageUpBind = this._pageUp.bind(this);
                this._pageDownBind = this._pageDown.bind(this);
                // Default to single selection mode
                this._selectionMode = WinJS.UI.SelectionMode.single;
                this._selectedItems = new WinJS.Binding.List();
                this._scrollingIndicator = this._listPickerFlyout.element.querySelector(".win-scrollindicator");

                var getWinJSStringName = XboxJS.UI.Voice.getWinJSStringName;
                this._scrollingIndicator.innerHTML = "<div class='win-overlay-arrowindicators'>" +
                                                     " <div class='win-overlay-scrollupindicator'></div>" +
                                                     " <div class='win-overlay-scrolldownindicator'></div>" +
                                                     "</div>" +
                                                     "<div class='win-overlay-voice-command win-overlay-pageupindicator' data-win-voice=\"{" +
                                                     "  phrase: '" + getWinJSStringName('tv/PAGE_UP_COMMAND_VUI_ALM') + "'," +
                                                     "  confidence: '" + getWinJSStringName('tv/PAGE_UP_COMMAND_VUI_CONF') + "'," +
                                                     "  pronunciation: '" + getWinJSStringName('tv/PAGE_UP_COMMAND_VUI_PRON') + "'," +
                                                     "  targetElement: select('this')" +
                                                     "}\"></div>" +
                                                     "<div class='win-overlay-voice-command win-overlay-pagedownindicator' data-win-voice='{" +
                                                     "  phrase: \"" + getWinJSStringName('tv/PAGE_DOWN_COMMAND_VUI_ALM') + "\"," +
                                                     "  confidence: \"" + getWinJSStringName('tv/PAGE_DOWN_COMMAND_VUI_CONF') + "\"," +
                                                     "  pronunciation: \"" + getWinJSStringName('tv/PAGE_DOWN_COMMAND_VUI_PRON') + "\"," +
                                                     "  targetElement: select(\"this\")" +
                                                     "}'></div>";

                this._voicePageUpElement = this._scrollingIndicator.querySelector(".win-overlay-pageupindicator");
                this._voicePageUpElement.addEventListener("click", this._pageUpBind, false);

                this._voicePageDownElement = this._scrollingIndicator.querySelector(".win-overlay-pagedownindicator");
                this._voicePageDownElement.addEventListener("click", this._pageDownBind, false);

                this._PERCENTAGE_OF_PAGE_TO_SCROLL = 0.8;
                this._THRESHOLD_TO_SHOW_TOP_ARROW = 50;
                this._THRESHOLD_TO_SHOW_BOTTOM_ARROW = 100;

                WinJS.UI.setOptions(this, options);

                var listPickerButtonElement = document.createElement("div");
                listPickerButtonElement.innerHTML = "<div class='win-text-tiletitle win-voice-inactivetext'></div>" +
                                                    "<div class='win-listpicker-selecteditemscountlabel'></div>" +
                                                    "<div class='win-listpicker-chevron'></div>";

                this._listPickerButton = new XboxJS.UI.ItemContainer(listPickerButtonElement);
                WinJS.Utilities.addClass(this._listPickerButton.element, "win-tile-galleryheader");
                this._element.appendChild(this._listPickerButton.element);

                // Override the default flyout animations
                this._listPickerFlyout._currentAnimateIn = this._listPickerOverlayAnimateIn.bind(this._listPickerFlyout);
                this._listPickerFlyout._currentAnimateOut = this._listPickerOverlayAnimateOut.bind(this._listPickerFlyout);

                // The whole control should start out invisible
                WinJS.Utilities.addClass(this._element, "win-listpicker win-disposable");
                WinJS.Utilities.addClass(this._listPickerFlyout.element, "win-listpicker-overlay");

                this._refresh();

                var that = this;
                this._showFlyoutBind = function _showFlyout(ev) {
                    that._listPickerFlyout.show(that._element, "right");
                };

                // Find the first focusable element and call focus on it after the flyout is shown
                this._beforeShowFlyoutBind = function _beforeShowFlyout(ev) {
                    that._refreshScrollIndicators();

                    // Set focus to the first selected element if there is one.
                    setImmediate(function () {
                        if (that._disposed ||
                            !that._items) {
                            return
                        }

                        var nextFocusElement = null;
                        for (var i = 0, len = that._items.length; i < len; i++) {
                            if (that._items.getAt(i).selected) {
                                nextFocusElement = that._listPickerItemContainers[i];
                                nextFocusElement.focus();
                                break;
                            }
                        }

                        // If we didn't find an element to focus on, then pick the 1st one.
                        if (!nextFocusElement &&
                            that._listPickerItemContainers[0]) {
                            that._listPickerItemContainers[0].focus();
                        }
                    });
                };

                this._listPickerButton.addEventListener("invoked", this._showFlyoutBind, false);
                this._listPickerFlyout.addEventListener("beforeshow", this._beforeShowFlyoutBind, false);

                // Attach an event listener to the scroll event
                var that = this;
                this._handleScrollBind = function _handleScroll(ev) {
                    if (that._itemsWrapper.scrollTop >= that._THRESHOLD_TO_SHOW_TOP_ARROW) {
                        that._canScrollUp = true;
                    } else {
                        that._canScrollUp = false;
                    }
                    if (that._itemsWrapper.scrollTop >= (that._itemsWrapper.scrollHeight - that._flyoutContainerElement.clientHeight)) {
                        that._canScrollDown = false;
                    } else {
                        that._canScrollDown = true;
                    }

                    // Note: We remove the classes in order so we can avoid labels flashing
                    if (!that._canScrollUp &&
                        !that._canScrollDown) {
                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-down");
                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-up");

                        WinJS.Utilities.addClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.addClass(that._voicePageDownElement, "win-voice-disableoverride");
                    } else if (!that._canScrollUp &&
                        that._canScrollDown) {
                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");

                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-up");
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-down");

                        WinJS.Utilities.addClass(that._voicePageUpElement, "win-voice-disabledlabel");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disabledlabel");
                    } else if (that._canScrollUp &&
                        !that._canScrollDown) {
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-up");
                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-down");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disabledlabel");
                        WinJS.Utilities.addClass(that._voicePageDownElement, "win-voice-disabledlabel");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");
                    } else {
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-up");
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-down");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disabledlabel");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disabledlabel");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");
                    }

                    // Refresh voice elements
                    XboxJS.UI.Voice.refreshVoiceElements();
                }

                // We should never get into a state where the DOM element that hosts the ListPicker
                // gets focus. If this ever happens, then we set focus to the ListView button.
                this._handleListPickerContainerGotFocusBind = function _handleListPickerContainerGotFocus() {
                    that._listPickerButton.element.focus();
                };
                this._element.addEventListener("focus", this._handleListPickerContainerGotFocusBind, false);

                this._itemsWrapper.addEventListener("scroll", this._handleScrollBind, false);
            }, {
                _createListPickerItemContainer: function listpicker_createListPickerItemContainer(currentIndex) {

                    // Create the option in the menu
                    var listPickerItem = this._items.getAt(currentIndex);
                    var itemContainerDiv = document.createElement("div");
                    itemContainerDiv.innerHTML = '<div class="win-listpicker-glyph"></div><div class="win-text-tiletitle  win-voice-inactivetext">' + listPickerItem.label + '</div>';
                    WinJS.Utilities.addClass(itemContainerDiv, "win-listpicker-item win-tile-listbutton");
                    itemContainerDiv.id = listPickerItem.id;

                    if (listPickerItem.selected) {
                        WinJS.Utilities.addClass(itemContainerDiv, "win-listpicker-item-selected");
                    }
                    WinJS.Utilities.addClass(itemContainerDiv, "win-listpicker-item");
                    var listPickerItemItemContainer = new XboxJS.UI.ItemContainer(itemContainerDiv);

                    var that = this;
                    var currentListPickerItem = listPickerItemItemContainer;
                    listPickerItemItemContainer.addEventListener("invoked", (function generateHandleItemInvoked(currentListPickerItem) {
                        return function handleItemInvoked(ev) {
                            if (that._selectionMode === WinJS.UI.SelectionMode.single) {
                                for (var i = 0, len = that._items.length; i < len; i++) {
                                    var currentItem = that._listPickerItemContainers[i];
                                    that._items.getAt(i).selected = false;
                                    WinJS.Utilities.removeClass(that._listPickerItemContainers[i], "win-listpicker-item-selected");
                                }

                                // Set the current selection
                                that._items.getAt(currentIndex).selected = true;
                                WinJS.Utilities.addClass(that._listPickerItemContainers[currentIndex], "win-listpicker-item-selected");
                            } else {
                                var currentItem = that._items.getAt(currentIndex);
                                if (!currentItem.selected) {
                                    currentItem.selected = true;
                                    WinJS.Utilities.addClass(that._listPickerItemContainers[currentIndex], "win-listpicker-item-selected");
                                } else {
                                    currentItem.selected = false;
                                    WinJS.Utilities.removeClass(that._listPickerItemContainers[currentIndex], "win-listpicker-item-selected");
                                }
                            }

                            if (that._data) {
                                that._data.notifyReload();
                            }

                            that._listPickerFlyout.hide();

                            // Fire the change event
                            var dispatchedEvent = document.createEvent("Event");
                            dispatchedEvent.initEvent(_changeEventName, true, false);
                            dispatchedEvent.detail = { selectedItems: that.selectedItems };
                            that._element.dispatchEvent(dispatchedEvent);

                            // Note: We stop propagation of the click event. Otherwise, the click event will bubble up to the root
                            // element and the flyout will show again.
                            ev.stopPropagation();

                            // Update the button label after the user has made a selection. In the case of multi-select
                            // we show the number of selected items in parenthesis next to the title. In the case of single-select
                            // we update the text with the option the user has chosen.
                            var numberOfSelectedItems = that._selectedItems.length;
                            if (numberOfSelectedItems) {
                                if (that._selectionMode === WinJS.UI.SelectionMode.multi) {
                                    that._selectedItemsCountLabel.textContent = WinJS.Resources._formatString(strings.listPickerSelectedItemsCount, numberOfSelectedItems);
                                } else {
                                    that._selectedItemsCountLabel.textContent = that._selectedItems.getAt(0).label;
                                }
                            } else {
                                that._selectedItemsCountLabel.textContent = "";
                                that._listPickerButtonLabel.textContent = that._label;
                            }
                        };
                    })(currentListPickerItem, currentIndex), false);

                    // Add voice support
                    if (XboxJS.UI.Voice) {
                        var voiceOverride = null;
                        if (listPickerItem.enumerate || listPickerItem.phrase || listPickerItem.pronunciation || listPickerItem.confidence) {
                            voiceOverride = {
                                enumerate: listPickerItem.enumerate,
                                phrase: listPickerItem.phrase,
                                pronunciation: listPickerItem.pronunciation,
                                confidence: listPickerItem.confidence
                            };
                            if (!voiceOverride.phrase) {
                                if (voiceOverride.pronunciation || voiceOverride.confidence) {
                                    voiceOverride.phrase = listPickerItem.label;
                                }
                            }
                        }
                        XboxJS.UI.Voice.updateVoiceAttribute(itemContainerDiv, voiceOverride, "select('.win-text-tiletitle')", "select('.win-voice-textdisplay')");
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }

                    return itemContainerDiv;
                },
                _listPickerOverlayAnimateIn: function () {
                    this._element.style.opacity = 1;
                    this._element.style.visibility = "visible";
                    return WinJS.UI.executeTransition(
                                        this._element,
                                        [{
                                            property: "opacity",
                                            delay: 0,
                                            duration: 601,
                                            timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                            from: 0,
                                            to: 1
                                        }]);
                },
                _listPickerOverlayAnimateOut: function () {
                    this._element.style.opacity = 0;
                    return WinJS.UI.executeTransition(this._element,
                                        [{
                                            property: "opacity",
                                            delay: 0,
                                            duration: 601,
                                            timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                            from: 1,
                                            to: 0
                                        }]);
                },
                _refresh: function listPicker_refresh() {

                    this._beginModification();

                    this._selectedItemsCountLabel = this._element.querySelector(".win-listpicker-selecteditemscountlabel");
                    this._listPickerButtonLabel = this._element.querySelector(".win-text-tiletitle");
                    this._listPickerButtonLabel.innerText = this._label;

                    // Populate the selected items list in case there are any selected items and update the UI
                    // on the button appropriately.
                    if (this._items &&
                        this.selectedItems &&
                        this.selectedItems.length) {
                        var numberOfSelectedItems = this._selectedItems.length;
                        if (numberOfSelectedItems &&
                            this._selectionMode === WinJS.UI.SelectionMode.multi) {
                            this._selectedItemsCountLabel.textContent = WinJS.Resources._formatString(strings.listPickerSelectedItemsCount, numberOfSelectedItems);
                        } else {
                            this._selectedItemsCountLabel.textContent = this._selectedItems.getAt(0).label;
                        }
                    }

                    // Add voice support
                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.updateVoiceAttribute(this._element.querySelector(".win-itemcontainer"), this._dataWinVoiceOverride, "select('.win-text-tiletitle')", "select('.win-voice-textdisplay')");
                    }

                    this._flyoutContainerElement.innerHTML = "";

                    var oldListPickerItemContainers = this._listPickerItemContainers;
                    this._listPickerItemContainers = [];

                    // Create a container div to host the options
                    this._itemsWrapper = this._itemsWrapper || document.createElement("div");
                    this._itemsWrapper.className = "win-listpicker-container";
                    if (this._items) {
                        for (var i = 0; i < this._items.length; i++) {
                            var itemContainer = this._createListPickerItemContainer(i);
                            this._listPickerItemContainers.push(itemContainer);
                            this._itemsWrapper.appendChild(itemContainer);
                        }
                        this._flyoutContainerElement.appendChild(this._itemsWrapper);
                        this._element.appendChild(this._listPickerFlyout.element);
                    }

                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }

                    this._pendingRefresh = false;

                    this._endModification();
                },
                _refreshScrollIndicators: function () {
                    // Set initial visibility for the arrow indicators if the contents of the scrollable region
                    // is bigger than the viewable area.
                    if (this._itemsWrapper.clientHeight < this._itemsWrapper.scrollHeight) {
                        if (this._itemsWrapper.scrollTop > 0) {
                            this._canScrollUp = true;
                        } else {
                            this._canScrollUp = false;
                        }
                        if (this._itemsWrapper.scrollTop >= (this._itemsWrapper.scrollHeight - this._itemsWrapper.clientHeight)) {
                            this._canScrollDown = false;
                        } else {
                            this._canScrollDown = true;
                        }

                        if (!this._canScrollUp &&
                            !this._canScrollDown) {
                            WinJS.Utilities.removeClass(this._scrollingIndicator, "win-scrollable-down");
                            WinJS.Utilities.removeClass(this._scrollingIndicator, "win-scrollable-up");

                            WinJS.Utilities.addClass(this._voicePageUpElement, "win-voice-disableoverride");
                            WinJS.Utilities.addClass(this._voicePageDownElement, "win-voice-disableoverride");
                        } else if (!this._canScrollUp &&
                            this._canScrollDown) {
                            WinJS.Utilities.removeClass(this._voicePageUpElement, "win-voice-disableoverride");
                            WinJS.Utilities.removeClass(this._voicePageDownElement, "win-voice-disableoverride");

                            WinJS.Utilities.removeClass(this._scrollingIndicator, "win-scrollable-up");
                            WinJS.Utilities.addClass(this._scrollingIndicator, "win-scrollable-down");

                            WinJS.Utilities.addClass(this._voicePageUpElement, "win-voice-disabledlabel");
                            WinJS.Utilities.removeClass(this._voicePageDownElement, "win-voice-disabledlabel");
                        } else if (this._canScrollUp &&
                            !this._canScrollDown) {
                            WinJS.Utilities.removeClass(this._voicePageUpElement, "win-voice-disableoverride");
                            WinJS.Utilities.removeClass(this._voicePageDownElement, "win-voice-disableoverride");

                            WinJS.Utilities.addClass(this._scrollingIndicator, "win-scrollable-up");
                            WinJS.Utilities.removeClass(this._scrollingIndicator, "win-scrollable-down");

                            WinJS.Utilities.removeClass(this._voicePageUpElement, "win-voice-disabledlabel");
                            WinJS.Utilities.addClass(this._voicePageDownElement, "win-voice-disabledlabel");
                        } else {
                            WinJS.Utilities.removeClass(this._voicePageUpElement, "win-voice-disableoverride");
                            WinJS.Utilities.removeClass(this._voicePageDownElement, "win-voice-disableoverride");

                            WinJS.Utilities.addClass(this._scrollingIndicator, "win-scrollable-down");
                            WinJS.Utilities.addClass(this._scrollingIndicator, "win-scrollable-up");

                            WinJS.Utilities.removeClass(this._voicePageUpElement, "win-voice-disabledlabel");
                            WinJS.Utilities.removeClass(this._voicePageDownElement, "win-voice-disabledlabel");
                        }

                        // Refresh voice elements
                        XboxJS.UI.Voice.refreshVoiceElements();

                        // Add a class to indicate that the content within the ScrollViewer is bigger than
                        // the visible area which means the ScrollViewer will need to be able to Scroll.
                        WinJS.Utilities.addClass(this._element, "win-scrollable");
                    } else {
                        WinJS.Utilities.removeClass(this._element, "win-scrollable");
                        WinJS.Utilities.addClass(this._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.addClass(this._voicePageDownElement, "win-voice-disableoverride");
                    }
                },
                _pageDown: function listPicker_pageDown() {
                    if (this._itemsWrapper.msZoomTo) {
                        this._itemsWrapper.msZoomTo({ contentX: 0, contentY: this._itemsWrapper.scrollTop + (this._PERCENTAGE_OF_PAGE_TO_SCROLL * this._itemsWrapper.clientHeight), viewportX: 0, viewportY: 0 });
                    }
                },
                _pageUp: function listPicker_pageUp() {
                    if (this._itemsWrapper.msZoomTo) {
                        this._itemsWrapper.msZoomTo({ contentX: 0, contentY: this._itemsWrapper.scrollTop - (this._PERCENTAGE_OF_PAGE_TO_SCROLL * this._itemsWrapper.clientHeight), viewportX: 0, viewportY: 0 });
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.ListPicker.dataWinVoiceOverride" helpKeyword="XboxJS.UI.ListPicker.dataWinVoiceOverride">
                /// Gets or sets the collection of properties used to voice enable the ListPicker Label.
                /// </field>
                dataWinVoiceOverride: {
                    get: function () {
                        return this._dataWinVoiceOverride;
                    },
                    set: function (value) {
                        if ((this._dataWinVoiceOverride === value) ||
                            ((this._dataWinVoiceOverride && value) &&
                             (this._dataWinVoiceOverride.pronunciation === value.pronunciation) &&
                             (this._dataWinVoiceOverride.confidence === value.confidence) &&
                             (this._dataWinVoiceOverride.phrase === value.phrase) &&
                             (this._dataWinVoiceOverride.enumerate === value.enumerate))) {
                            return;
                        }

                        this._dataWinVoiceOverride = value;
                        var listPickerLabel = this._element.querySelector(".win-text-tiletitle");
                        listPickerLabel.innerText = this._label;

                        // Add voice support
                        if (XboxJS.UI.Voice) {
                            XboxJS.UI.Voice.updateVoiceAttribute(this._element.querySelector(".win-itemcontainer"), this._dataWinVoiceOverride, "select('.win-text-tiletitle')", "select('.win-voice-textdisplay')");
                            XboxJS.UI.Voice.refreshVoiceElements();
                        }
                    }
                },
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.ListPicker.element" helpKeyword="XboxJS.UI.ListPicker.element">
                /// Gets the DOM element that hosts the ListPicker control.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="String" locid="XboxJS.UI.ListPicker.label" helpKeyword="XboxJS.UI.ListPicker.label">
                /// Gets or sets the label associated with the ListPicker control.
                /// </field>
                label: {
                    get: function () {
                        return this._label;
                    },
                    set: function (value) {
                        this._label = value;
                        if (!this._pendingRefresh) {
                            this._refresh();
                        }
                    }
                },
                /// <field type="Array" locid="XboxJS.UI.ListPicker.items" helpKeyword="XboxJS.UI.ListPicker.items">
                /// Gets or sets the items associated with the ListPicker control.
                /// </field>
                items: {
                    get: function () {
                        return this._items;
                    },
                    set: function (value) {
                        if (this._items) {
                            this._removeDataListeners();
                        };
                        this._items = value || new WinJS.Binding.List();
                        this._addDataListeners();

                        if (!this._pendingRefresh) {
                            this._refresh();
                        }
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.ListPicker.selectedItems" helpKeyword="XboxJS.UI.ListPicker.selectedItems">
                /// Gets the items the user has selected.
                /// </field>
                selectedItems: {
                    get: function () {
                        if (!this._items.length) {
                            return;
                        }

                        this._selectedItems.length = 0;
                        for (var i = 0, len = this._items.length; i < len; i++) {
                            var currentItem = this._items.getAt(i);
                            if (currentItem.selected) {
                                this._selectedItems.push(currentItem);
                            }
                        }

                        return this._selectedItems;
                    }
                },
                /// <field type="String" locid="XboxJS.UI.ListPicker.selectionMode" helpKeyword="XboxJS.UI.ListPicker.selectionMode">
                /// Gets or sets the selection mode of the ListPicker. It must be a value from the WinJS.UI.SelectionMode enumeration.
                /// The The default is single. WinJS.UI.SelectionMode.none is not an allowed value.
                /// </field>
                selectionMode: {
                    get: function () {
                        return this._selectionMode;
                    },
                    set: function (value) {
                        if (value !== WinJS.UI.SelectionMode.single &&
                            value !== WinJS.UI.SelectionMode.multi) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.ListPicker.invalidSelectionMode", strings.invalidSelectionMode);
                        }

                        if (this._selectionMode === value) {
                            return;
                        }

                        this._selectionMode = value;

                        // We may not have rendered UI before setting selectionMode.
                        // If that's the case, we need to exit before attempting to
                        // update an empty list of itemContainers.
                        if (!this._listPickerItemContainers.length) {
                            return;
                        }

                        // This variable is only used for single selection mode
                        var changed = false;
                        var defaultSelectionIndex = -1;
                        for (var i = 0, len = this._items.length; i < len; i++) {
                            if (this._selectionMode === WinJS.UI.SelectionMode.single) {
                                if (defaultSelectionIndex === -1 &&
                                    this._items.getAt(i).selected) {
                                    defaultSelectionIndex = i;
                                } else {
                                    WinJS.Utilities.removeClass(this._listPickerItemContainers[i], "win-listpicker-item-selected");
                                    this._items.getAt(i).selected = false;
                                }
                            } else {
                                if (this._items.getAt(i).selected) {
                                    WinJS.Utilities.addClass(this._listPickerItemContainers[i], "win-listpicker-item-selected");
                                    changed = true;
                                } else {
                                    WinJS.Utilities.removeClass(this._listPickerItemContainers[i], "win-listpicker-item-selected");
                                }
                            }
                        }

                        // In single, selectionMode add a selected class, to the default selected item.
                        if (this._selectionMode === WinJS.UI.SelectionMode.single &&
                            defaultSelectionIndex !== -1) {
                            WinJS.Utilities.addClass(this._listPickerItemContainers[defaultSelectionIndex], "win-listpicker-item-selected");
                        }

                        if (changed && this._data) {
                            this._data.notifyReload();
                        }
                    }
                },
                dispose: function listPicker_dispose() {
                    /// <signature helpKeyword="XboxJS.UI.ListPicker.dispose">
                    /// <summary locid="XboxJS.UI.ListPicker.dispose">
                    /// Disposes the control.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    // Detach event listeners
                    this._listPickerButton.removeEventListener("invoked", this._showFlyoutBind);
                    this._listPickerFlyout.removeEventListener("aftershow", this._beforeShowFlyoutBind);
                    this._element.removeEventListener("focus", this._handleListPickerContainerGotFocusBind);
                    this._itemsWrapper.removeEventListener("scroll", this._handleScrollBind);
                    this._removeDataListeners();

                    this._voicePageUpElement.removeEventListener("click", this._pageUpBind);
                    this._voicePageDownElement.removeEventListener("click", this._pageDownBind);

                    this._element.addEventListener("focus", this._handleListPickerContainerGotFocusBind, false);

                    var listPickerItems = this._listPickerFlyout.element.querySelectorAll(".win-listpicker-option");
                    if (listPickerItems) {
                        for (var i = 0; i < listPickerItems.length; i++) {
                            listPickerItems[i].winControl.removeEventListener("invoked", function () { });
                        }
                    }

                    this._listPickerFlyout.dispose();
                    this._listPickerFlyout = null;

                    WinJS.Utilities.disposeSubTree(this.element);

                    this._beforeShowFlyoutBind = null;
                    if (this._dataListeners) {
                        this._dataListeners.length = 0;
                    }
                    this._dataListeners = null;
                    this._dataWinVoiceOverride = null;
                    this._flyoutContainerElement = null;
                    this._handleListPickerContainerGotFocusBind = null;
                    this._handleScrollBind = null;
                    this._label = null;
                    this._listPickerButton = null;
                    this._listPickerButtonLabel = null;
                    if (this._listPickerItemContainers) {
                        this._listPickerItemContainers.length = 0;
                    }
                    this._listPickerItemContainers = null;
                    if (this._items) {
                        this._items.length = 0;
                    }
                    this._items = null;
                    this._itemsWrapper = null;
                    this._pageUpBind = null;
                    this._pageDownBind = null;
                    this._refreshScrollIndicatorsBind = null;
                    if (this._selectedItems) {
                        this._selectedItems.length = 0;
                    }
                    this._selectedItems = null;
                    this._selectedItemsCountLabel = null;
                    this._selectionMode = null;
                    this._showFlyoutBind = null;
                    this._scrollingIndicator = null;

                    this._scrollDownBySmallAmountBind = null;
                    this._scrollUpBySmallAmountBind = null;
                    this._scrollDownByLargeAmountBind = null;
                    this._scrollUpByLargeAmount = null;
                    this._voicePageUpElement = null;
                    this._voicePageDownElement = null;

                    this._element.winControl = null;
                    this._element = null;
                },

                _addDataListeners: function listPicker_addDataListeners() {
                    Object.keys(this._dataListeners).forEach(function (eventName) {
                        if (this._items) {
                            this._items.addEventListener(eventName, this._dataListeners[eventName], false);
                        }
                    }.bind(this));
                },

                _beginModification: function listPicker_beginModification() {
                    if (this._modifying) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.ListPicker.listPickerModificationReentrancy", strings.listPickerReentrancy);
                    }
                    this._modifying = true;
                },

                _endModification: function listPicker_endModification() {
                    this._modifying = false;
                },

                _removeDataListeners: function listPicker_removeDataListeners() {
                    Object.keys(this._dataListeners).forEach(function (eventName) {
                        if (this._items) {
                            this._items.removeEventListener(eventName, this._dataListeners[eventName], false);
                        }
                    }.bind(this));
                },

                _dataItemChangedHandler: function listPicker_dataItemChangedHandler(eventInfo) {
                    // Handles the 'itemchanged' event fired by WinJS.Binding.List

                    if (this._pendingRefresh) {
                        return;
                    }

                    this._beginModification();

                    var index = eventInfo.detail.index;
                    var newListPickerItemContainer = this._createListPickerItemContainer(index);

                    // Make the change
                    var oldItem = null;
                    if (index < this._listPickerItemContainers.length) {
                        oldItem = this._listPickerItemContainers[index];
                        oldItem.parentNode.replaceChild(newListPickerItemContainer, oldItem);
                        this._listPickerItemContainers[index] = newListPickerItemContainer;
                    } else {
                        root.appendChild(newListPickerItemContainer);
                        this._listPickerItemContainers.push(newListPickerItemContainer);
                    }

                    if (oldItem && oldItem.selected) {
                        if (this._data) {
                            this._data.notifyReload();
                        }
                    }

                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }

                    this._endModification();
                },

                _dataItemInsertedHandler: function listPicker_dataItemInsertedHandler(eventInfo) {
                    // Handles the 'iteminserted' event fired by WinJS.Binding.List

                    if (this._pendingRefresh) {
                        return;
                    }

                    this._beginModification();
                    var index = eventInfo.detail.index;
                    var newListPickerItemContainer = this._createListPickerItemContainer(index);
                    var root = this._listPickerFlyout.element;

                    if (index < this._listPickerItemContainers.length) {
                        var nextSibling = this._listPickerItemContainers[index];
                        root.insertBefore(newListPickerItemContainer, nextSibling);
                    } else {
                        root.appendChild(newListPickerItemContainer);
                    }

                    // Update collection of rendered elements
                    this._listPickerItemContainers.splice(index, 0, newListPickerItemContainer);

                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }

                    this._endModification();
                },

                _dataItemMovedHandler: function listPicker_dataItemMovedHandler(eventInfo) {
                    // Handles the 'itemmoved' event fired by WinJS.Binding.List 

                    if (this._pendingRefresh) {
                        return;
                    }

                    this._beginModification();

                    var movingItem = this._listPickerItemContainers[eventInfo.detail.oldIndex];

                    // Remove
                    this._listPickerItemContainers.splice(eventInfo.detail.oldIndex, 1)[0];
                    movingItem.element.parentNode.removeChild(movingItem.element);

                    // Insert
                    if (eventInfo.detail.newIndex < (this._listPickerItemContainers.length) - 1) {
                        var nextSibling = this._listPickerItemContainers[eventInfo.detail.newIndex];
                        this._listPickerFlyout.element.insertBefore(movingItem.element, nextSibling);
                        this._listPickerItemContainers.splice(eventInfo.detail.newIndex, 0, movingItem);
                    } else {
                        this._listPickerItemContainers.push(movingItem);
                        this._listPickerFlyout.element.appendChild(movingItem.element);
                    }

                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }

                    this._endModification();
                },

                _dataItemRemovedHandler: function listPicker_dataItemRemoveHandler(eventInfo) {
                    // Handles the 'itemremoved' event fired by WinJS.Binding.List

                    if (this._pendingRefresh) {
                        return;
                    }

                    this._beginModification();
                    var oldItem = this._listPickerItemContainers[eventInfo.detail.index];
                    oldItem.parentNode.removeChild(oldItem);

                    this._listPickerItemContainers.splice(eventInfo.detail.index, 1);

                    if (oldItem.selected && this._data) {
                        this._data.notifyReload();
                    }

                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }

                    this._endModification();
                },

                _dataReloadHandler: function listPicker_dataReloadHandler(eventInfo) {
                    // Handles the 'reload' event fired by WinJS.Binding.List whenever it performs operations such as reverse() or filter() 
                    if (this._pendingRefresh) {
                        return;
                    }

                    this._pendingRefresh = true;

                    this._refresh();
                }
            }, {
                _ClassName: {
                    listPickerVisible: "win-listpicker-overlay-visible"
                }
            });
            WinJS.Class.mix(ListPicker, WinJS.Utilities.createEventProperties(_changeEventName));
            WinJS.Class.mix(ListPicker, WinJS.UI.DOMEventMixin);

            return ListPicker;
        })
    })
})();

// Media Control
(function mediaPlayerInit(global, undefined) {

    "use strict";

    WinJS.Namespace.define("XboxJS.UI", {

        Layout: {
            /// <field type="String" locid="XboxJS.UI.Layout.full" helpKeyword="XboxJS.UI.Layout.full">
            /// The Media Control shows the full set of transport controls.
            /// </field>
            full: "full",

            /// <field type="String" locid="XboxJS.UI.Layout.partial" helpKeyword="XboxJS.UI.Layout.partial">
            /// The Media Control shows a partial set of transport controls.
            /// </field>
            partial: "partial"
        },

        MediaCommand: {
            /// <field type="String" locid="XboxJS.UI.MediaCommand.chapterSkipBack" helpKeyword="XboxJS.UI.MediaCommand.chapterSkipBack">
            /// Seeks to the previous chapter.
            /// </field>
            chapterSkipBack: "chapterSkipBack",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.chapterSkipForward" helpKeyword="XboxJS.UI.MediaCommand.chapterSkipForward">
            /// Seeks to the next chapter marker.
            /// </field>
            chapterSkipForward: "chapterSkipForward",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.closedcaptions" helpKeyword="XboxJS.UI.MediaCommand.closedcaptions">
            /// Invokes the closed captions menu.
            /// </field>
            closedCaptions: "closedCaptions",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.displayMode" helpKeyword="XboxJS.UI.MediaCommand.displayMode">
            /// Toggles the display mode between letterbox and native.
            /// </field>
            displayMode: "displaymode",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.fastForward" helpKeyword="XboxJS.UI.MediaCommand.fastForward">
            /// Increases the playback rate of the media.
            /// </field>
            fastForward: "fastForward",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.goToLive" helpKeyword="XboxJS.UI.MediaCommand.goToLive">
            /// Navigates to the real-time position in live streamed media.
            /// </field>
            goToLive: "goToLive",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.info" helpKeyword="XboxJS.UI.MediaCommand.info">
            /// Provides more information about the current media.
            /// </field>
            info: "info",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.more" helpKeyword="XboxJS.UI.MediaCommand.more">
            /// Shows additional commands beyond the ones shown on the transport bar.
            /// </field>
            more: "more",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.nextTrack" helpKeyword="XboxJS.UI.MediaCommand.nextTrack">
            /// Plays the next track.
            /// </field>
            nextTrack: "nextTrack",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.pause" helpKeyword="XboxJS.UI.MediaCommand.pause">
            /// Pauses the media.
            /// </field>
            pause: "pause",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.play" helpKeyword="XboxJS.UI.MediaCommand.play">
            /// Sets the playbackRate to the default playbackRate for the media and plays the media.
            /// </field>
            play: "play",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.playFromBeginning" helpKeyword="XboxJS.UI.MediaCommand.playFromBeginning">
            /// Seeks to the beginning of the timeline and starts playing.
            /// </field>
            playFromBeginning: "playFromBeginning",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.previousTrack" helpKeyword="XboxJS.UI.MediaCommand.previousTrack">
            /// Plays the previous track.
            /// </field>
            previousTrack: "previousTrack",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.rewind" helpKeyword="XboxJS.UI.MediaCommand.rewind">
            /// Decreases the playbackRate of the media.
            /// </field>
            rewind: "rewind",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.seek" helpKeyword="XboxJS.UI.MediaCommand.seek">
            /// Navigates to the specified position in the media.
            /// </field>
            seek: "seek",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.stop" helpKeyword="XboxJS.UI.MediaCommand.stop">
            /// Stops the media.
            /// </field>
            stop: "stop",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.timeskipBack" helpKeyword="XboxJS.UI.MediaCommand.timeskipBack">
            /// Moves the current timeline position backward by a short interval.
            /// </field>
            timeSkipBack: "timeSkipBack",

            /// <field type="String" locid="XboxJS.UI.MediaCommand.timeSkipForward" helpKeyword="XboxJS.UI.MediaCommand.timeSkipForward">
            /// Moves the current timeline position forward short interval.
            /// </field>
            timeSkipForward: "timeSkipForward",
        },

        MarkerType: {
            /// <field type="String" locid="XboxJS.UI.MarkerType.advertisement" helpKeyword="XboxJS.UI.MarkerType.advertisement">
            /// The marker represents the beginning of an advertisement.
            /// </field>
            advertisement: "advertisement",

            /// <field type="String" locid="XboxJS.UI.MarkerType.chapter" helpKeyword="XboxJS.UI.MarkerType.chapter">
            /// The markers represents the beginning of a chapter.
            /// </field>
            chapter: "chapter",

            /// <field type="String" locid="XboxJS.UI.MarkerType.custom" helpKeyword="XboxJS.UI.MarkerType.custom">
            /// The markers represents a custom event.
            /// </field>
            custom: "custom"
        }
    });

    WinJS.Namespace.define("XboxJS.UI", {

        MediaElementAdapter: WinJS.Namespace._lazy(function () {
            var nav = WinJS.Navigation;
            var utilities = WinJS.Utilities;

            var strings = {
                get mediaElementAdapterConstructorNullParameter() { return WinJS.Resources._getWinJSString("tv/mediaElementAdapterConstructorNullParameter").value; },
            };

            return WinJS.Class.define(function (mediaPlayer, existingMediaElement) {
                /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter">
                /// <summary locid="XboxJS.UI.MediaElementAdapter.constructor">
                /// Creates a new MediaElementAdapter.
                /// </summary>
                /// <param name="mediaPlayer" type="Object" locid="XboxJS.UI.MediaElementAdapter.constructor_p:mediaPlayer">
                /// A reference to a MediaPlayer class.
                /// </param>
                /// <param name="existingMediaElement" type="Object" domElement="true" optional="true" locid="XboxJS.UI.MediaElementAdapter.constructor_p:existingMediaElement">
                /// A media element can be passed to the constructor as an optional parameter. If none is specified, a default mediaElement is created.
                /// </param>
                /// <returns type="XboxJS.UI.MediaElementAdapter" locid="XboxJS.UI.MediaElementAdapter.constructor_returnValue">
                /// The new MediaElementAdapter.
                /// </returns>
                /// </signature>
                this.baseMediaElementAdapterConstructor(mediaPlayer, existingMediaElement);
            }, {
                _resetInternalState: function () {
                    this.liveTime = 0;
                    this.isPauseAllowed = true;
                    this.isPlayAllowed = true;
                    this.isLive = false;
                    this.isSeekAllowed = true;
                },

                // Public Properties
                liveTime: {
                    /// <field type="Object" locid="XboxJS.UI.MediaElementAdapter.liveTime" helpKeyword="XboxJS.UI.MediaElementAdapter.liveTime">
                    /// Gets or sets the live time.
                    /// </field>

                    get: function () {
                        return this._liveTime;
                    },

                    set: function (value) {
                        this._liveTime = value;
                    },
                },

                isLive: {
                    /// <field type="Object" locid="XboxJS.UI.MediaElementAdapter.isLive" helpKeyword="XboxJS.UI.MediaElementAdapter.isLive">
                    /// Gets or sets whether the content is a live stream.
                    /// </field>

                    get: function () {
                        return this._isLive;
                    },

                    set: function (value) {
                        this._isLive = value;
                    },
                },

                isPauseAllowed: {
                    /// <field type="Object" locid="XboxJS.UI.MediaElementAdapter.isPauseAllowed" helpKeyword="XboxJS.UI.MediaElementAdapter.isPauseAllowed">
                    /// Gets or sets a value that specifies whether the pause method can be executed.
                    /// </field>

                    get: function () {
                        return this._isPauseAllowed;
                    },

                    set: function (value) {

                        this._isPauseAllowed = value;

                        if (value) {
                            this._mediaPlayer._playPauseButton.disabled = false;
                            if (this._smtControls) {
                                this._smtControls.isPauseEnabled = true;
                            }
                        } else {
                            this._mediaPlayer._playPauseButton.disabled = true;
                            if (this._smtControls) {
                                this._smtControls.isPauseEnabled = false;
                            }
                        }
                    },
                },

                isPlayAllowed: {
                    /// <field type="Object" locid="XboxJS.UI.MediaElementAdapter.isPlayAllowed" helpKeyword="XboxJS.UI.MediaElementAdapter.isPlayAllowed">
                    /// Gets or sets a value that specifies whether the play method can be executed.
                    /// </field>

                    get: function () {
                        return this._isPlayAllowed;
                    },

                    set: function (value) {

                        this._isPlayAllowed = value;

                        if (value) {
                            this._mediaPlayer._playPauseButton.disabled = false;
                            if (this._smtControls) {
                                this._smtControls.isPlayEnabled = true;
                            }
                        } else {
                            this._mediaPlayer._playPauseButton.disabled = true;
                            if (this._smtControls) {
                                this._smtControls.isPlayEnabled = false;
                            }
                        }
                    },
                },

                isSeekAllowed: {
                    /// <field type="Object" locid="XboxJS.UI.MediaElementAdapter.isSeekAllowed" helpKeyword="XboxJS.UI.MediaElementAdapter.isSeekAllowed">
                    /// Gets or sets a value that specifies whether the seek method can be executed.
                    /// </field>

                    get: function () {
                        return this._isSeekAllowed;
                    },

                    set: function (value) {

                        this._isSeekAllowed = value;
                        if (value) {
                            if (this._mediaPlayer._chapterSkipBackButton) {
                                this._mediaPlayer._chapterSkipBackButton.disabled = false;
                            }
                            if (this._mediaPlayer._chapterSkipForwardButton) {
                                this._mediaPlayer._chapterSkipForwardButton.disabled = false;
                            }
                            if (this._mediaPlayer._fastForwardButton) {
                                this._mediaPlayer._fastForwardButton.disabled = false;
                                if (this._smtControls) {
                                    this._smtControls.isFastForwardEnabled = true;
                                }
                            }
                            if (this._mediaPlayer._rewindButton) {
                                this._mediaPlayer._rewindButton.disabled = false;
                                if (this._smtControls) {
                                    this._smtControls.isRewindEnabled = true;
                                }
                            }
                            if (this._mediaPlayer._timeSkipBackButton) {
                                this._mediaPlayer._timeSkipBackButton.disabled = false;
                            }
                            if (this._mediaPlayer._timeSkipForwardButton) {
                                this._mediaPlayer._timeSkipForwardButton.disabled = false;
                            }
                            utilities.removeClass(this._mediaPlayer._element, "win-mediaplayer-seekbar-disabled");
                        } else {
                            if (this._mediaPlayer._chapterSkipBackButton) {
                                this._mediaPlayer._chapterSkipBackButton.disabled = true;
                            }
                            if (this._mediaPlayer._chapterSkipForwardButton) {
                                this._mediaPlayer._chapterSkipForwardButton.disabled = true;
                            }
                            if (this._mediaPlayer._fastForwardButton) {
                                this._mediaPlayer._fastForwardButton.disabled = true;
                                if (this._smtControls) {
                                    this._smtControls.isFastForwardEnabled = false;
                                }
                            }
                            if (this._mediaPlayer._rewindButton) {
                                this._mediaPlayer._rewindButton.disabled = true;
                                if (this._smtControls) {
                                    this._smtControls.isRewindEnabled = false;
                                }
                            }
                            if (this._mediaPlayer._timeSkipBackButton) {
                                this._mediaPlayer._timeSkipBackButton.disabled = true;
                            }
                            if (this._mediaPlayer._timeSkipForwardButton) {
                                this._mediaPlayer._timeSkipForwardButton.disabled = true;
                            }
                            utilities.addClass(this._mediaPlayer._element, "win-mediaplayer-seekbar-disabled");
                        }
                    },
                },

                mediaElement: {
                    /// <field type="Object" locid="XboxJS.UI.MediaElementAdapter.mediaElement" helpKeyword="XboxJS.UI.MediaElementAdapter.mediaElement">
                    /// Gets or sets a value the underlying media element. This is either a video or audio tag.
                    /// </field>

                    get: function () {
                        return this._mediaElement;
                    },

                    set: function (value) {

                        var oldMediaElement = this._mediaElement;
                        this._mediaElement = value;

                        this._resetInternalState();

                        this._mediaPlayer._setupNewMediaElement(this._mediaElement, oldMediaElement);

                        if (this._mediaElement) {

                            // We only want one event listener attached, so we detach in case there's already an
                            // existing event listener.
                            if (oldMediaElement) {
                                oldMediaElement.detachEvent("onpropertychange", this._propertyChangedHandler);
                                this._propertyChangedHandler = null;
                            }

                            // We need to listen for changes to the media's 'src' property, because if it
                            // gets set to null, then we need to update the UI appropriately.
                            // For a 3rd party trying to do this, they will need to update the button states themselves
                            // by individually setting the 'disabled' property on the buttons.
                            var that = this;
                            this._propertyChangedHandler = function handleMediaPropertyChanged(evt) {

                                if (that._disposed) {
                                    that._mediaElement.detachEvent("onpropertychange", that._propertyChangedHandler);
                                    return;
                                }

                                var propertyName = evt.propertyName;
                                if (propertyName === "src" &&
                                    that._mediaPlayer) {

                                    if (that._mediaPlayer._isControlsVisible) {
                                        that._mediaPlayer._subscribeToTimeUpdates();
                                    }
                                }
                            };

                            this._mediaElement.attachEvent("onpropertychange", this._propertyChangedHandler);
                        }

                        if (this._mediaPlayer &&
                            this._mediaPlayer.element) {
                            var dispatchedEvent = document.createEvent("Event");
                            dispatchedEvent.initEvent("mediaelementchanged", true, false);
                            this._mediaPlayer.element.dispatchEvent(dispatchedEvent);
                        }
                    },
                },
                baseMediaElementAdapterConstructor: function (mediaPlayer, existingMediaElement) {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.baseMediaElementAdapterConstructor">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.baseMediaElementAdapterConstructor">
                    /// The base class constructor. If you are deriving from the MediaElementAdapter class, you
                    /// must call this base class constructor.
                    /// </summary>
                    /// </signature>
                    this._disposed = false;
                    this._liveTime = 0;
                    this._isPauseAllowed = true;
                    this._isPlayAllowed = true;
                    this._isLive = false;
                    this._isSeekAllowed = true;
                    this._mediaElement = null;
                    this._mediaPlayer = null;
                    this._propertyChangedHandler = null;
                    this._smtControls = null;

                    if (mediaPlayer) {
                        this._mediaPlayer = mediaPlayer;
                    } else {
                        throw new WinJS.ErrorFromName("XboxJS.UI.MediaElementAdapter.nullParameter", strings.mediaElementAdapterConstructorNullParameter);
                    }

                    if (Windows.Media.SystemMediaTransportControls) {
                        this._smtControls = Windows.Media.SystemMediaTransportControls.getForCurrentView();
                    }

                    if (existingMediaElement) {
                        this._mediaElement = existingMediaElement;
                    } else {
                        var containerElement = this._mediaPlayer._element;
                        if (containerElement && containerElement.getElementsByTagName) {

                            // We check for whether there is an video tag or audio tag present
                            // in order to determine which mode we're in:
                            //      1. If we find a video tag, we assume we're in video mode.
                            //      2. If not, we check for an audio tag. If we find one, we assume we're in audio mode.
                            //      3. If don't find an audio tag, then we don'd create one and assume the app developer wants to assign one later.
                            this.mediaElement = containerElement.getElementsByTagName("video")[0];

                            if (!this.mediaElement) {
                                this.mediaElement = containerElement.getElementsByTagName("audio")[0];
                            }
                        }
                    }
                },

                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.dispose">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.dispose">
                    /// Releases MediaElementAdapter resources.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    // Remove event listeners
                    if (this._mediaElement) {
                        this._mediaElement.detachEvent("onpropertychange", this._propertyChangedHandler);
                    }
                    this._propertyChangedHandler = null;

                    if (this._mediaElement) {
                        this._mediaElement.removeAttribute("src");
                    }

                    this._liveTime = null;
                    this._mediaElement = null;
                    this._mediaPlayer = null;
                    this._smtControls = null;
                },

                nextTrack: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.nextTrack">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.nextTrack">
                    /// Skips to the next track in a playlist. This function is empty by default and
                    /// meant to be overridden with a custom implementation.
                    /// </summary>
                    /// </signature>
                },

                pause: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.pause">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.pause">
                    /// Pauses the media.
                    /// </summary>
                    /// </signature>

                    if (this._mediaElement &&
                        this._isPauseAllowed) {
                        this._mediaElement.pause();
                    }
                },

                play: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.play">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.play">
                    /// Sets the playbackRate to the default playbackRate for the media and plays the media.
                    /// </summary>
                    /// </signature>

                    if (this._mediaElement &&
                        this._isPlayAllowed) {
                        this._mediaElement.play();
                    }
                },

                previousTrack: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.previousTrack">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.previousTrack">
                    /// Skips to the previous track in a playlist. This function is empty by default and
                    /// meant to be overridden with a custom implementation.
                    /// </summary>
                    /// </signature>
                },

                seek: function (newTime) {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.seek">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.seek">
                    /// Navigates to the specified position in the media.
                    /// </summary>
                    /// </signature>

                    if (this._mediaElement &&
                        this._isSeekAllowed) {
                        this._mediaElement.currentTime = newTime;
                    }
                },

                stop: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaElementAdapter.stop">
                    /// <summary locid="XboxJS.UI.MediaElementAdapter.stop">
                    /// Navigates to the specified position in the media.
                    /// </summary>
                    /// </signature>

                    if (nav.canGoBack) {
                        nav.back();
                    }
                }
            });
        }),

        // MediaPlayer is capitalized to follow WinJS conventions for class names.
        MediaPlayer: WinJS.Namespace._lazy(function () {
            var animation = WinJS.UI.Animation;
            var app = WinJS.Application;
            var layout = XboxJS.UI.Layout;
            var mediaCommandEnum = XboxJS.UI.MediaCommand;
            var markerType = XboxJS.UI.MarkerType;
            var nav = WinJS.Navigation;
            var utilities = WinJS.Utilities;
            var SmartGlass = null;
            if (utilities.hasWinRT &&
                Windows.Xbox &&
                Windows.Xbox.SmartGlass) {
                SmartGlass = Windows.Xbox.SmartGlass;
            }

            var strings = {
                get chapterSkipBackMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/chapterSkipBackMediaCommandDisplayText").value; },
                get chapterSkipForwardMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/chapterSkipForwardMediaCommandDisplayText").value; },
                get closedCaptionsMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/closedCaptionsMediaCommandDisplayText").value; },
                get displayModeMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/displayModeMediaCommandDisplayText").value; },
                get fastForwardMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/fastForwardMediaCommandDisplayText").value; },
                get fastForwardFeedbackDisplayText() { return WinJS.Resources._getWinJSString("tv/fastForwardFeedbackDisplayText").value; },
                get fastForwardFeedbackSlowMotionDisplayText() { return WinJS.Resources._getWinJSString("tv/fastForwardFeedbackSlowMotionDisplayText").value; },
                get goToFullScreenButtonLabel() { return WinJS.Resources._getWinJSString("tv/goToFullScreenButtonLabel").value; },
                get goToLiveMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/goToLiveMediaCommandDisplayText").value; },
                get infoMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/infoCommandDisplayText").value; },
                get mediaPlayerAddMarkerErrorInvalidMarkerType() { return WinJS.Resources._getWinJSString("tv/mediaPlayerAddMarkerErrorInvalidMarkerType").value; },
                get mediaPlayerAddMarkerErrorTimeNotANumber() { return WinJS.Resources._getWinJSString("tv/mediaPlayerAddMarkerErrorTimeNotANumber").value; },
                get mediaPlayerLayoutUnsupportedValue() { return WinJS.Resources._getWinJSString("tv/mediaPlayerLayoutUnsupportedValue").value; },
                get mediaPlayerMediaMetadataInvalidImageHeight() { return WinJS.Resources._getWinJSString("tv/mediaPlayerMediaMetadataInvalidImageHeight").value; },
                get mediaPlayerMediaMetadataInvalidImageWidth() { return WinJS.Resources._getWinJSString("tv/mediaPlayerMediaMetadataInvalidImageWidth").value; },
                get mediaPlayerMediaMetadataMissingRequiredParameter() { return WinJS.Resources._getWinJSString("tv/mediaPlayerMediaMetadataMissingRequiredParameter").value; },
                get mediaPlayerNullContentType() { return WinJS.Resources._getWinJSString("tv/mediaPlayerNullContentType").value; },
                get mediaPlayerNullMetadata() { return WinJS.Resources._getWinJSString("tv/mediaPlayerNullMetadata").value; },
                get mediaPlayerSetContentMetadataInvalidContentRating() { return WinJS.Resources._getWinJSString("tv/mediaPlayerSetContentMetadataInvalidContentRating").value; },
                get mediaPlayerSetContentMetadataInvalidMetadataForLinearMedia() { return WinJS.Resources._getWinJSString("tv/mediaPlayerSetContentMetadataInvalidMetadataForLinearMedia").value; },
                get mediaPlayerSetContentMetadataNoPremiumVideoPrivilege() { return WinJS.Resources._getWinJSString("tv/mediaPlayerSetContentMetadataNoPremiumVideoPrivilege").value; },
                get mediaPlayerSetContentMetadataNotAllowedToAccessContent() { return WinJS.Resources._getWinJSString("tv/mediaPlayerSetContentMetadataNotAllowedToAccessContent").value; },
                get mediaPlayerSetContentMetadataFamilySettingsUnknownError() { return WinJS.Resources._getWinJSString("tv/mediaPlayerSetContentMetadataFamilySettingsUnknownError").value; },
                get moreMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/moreMediaCommandDisplayText").value; },
                get nextTrackMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/nextTrackMediaCommandDisplayText").value; },
                get playMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/playMediaCommandDisplayText").value; },
                get playFromBeginningMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/playMediaCommandDisplayText").value; },
                get pauseMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/pauseMediaCommandDisplayText").value; },
                get previousTrackMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/playFromBeginningMediaCommandDisplayText").value; },
                get replayMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/replayMediaCommandDisplayText").value; },
                get rewindMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/rewindMediaCommandDisplayText").value; },
                get rewindFeedbackDisplayText() { return WinJS.Resources._getWinJSString("tv/rewindFeedbackDisplayText").value; },
                get rewindFeedbackSlowMotionDisplayText() { return WinJS.Resources._getWinJSString("tv/rewindFeedbackSlowMotionDisplayText").value; },
                get stopMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/stopMediaCommandDisplayText").value; },
                get timeSeparator() { return WinJS.Resources._getWinJSString("tv/timeSeparator").value; },
                get timeSkipBackMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/timeSkipBackMediaCommandDisplayText").value; },
                get timeSkipForwardMediaCommandDisplayText() { return WinJS.Resources._getWinJSString("tv/timeSkipForwardMediaCommandDisplayText").value; }
            };

            // If we are running in an iFrame, then wuiv should be undefined. Otherwise there will be an exception.
            var wuiv = utilities.hasWinRT && Windows.UI.ViewManagement;

            // Helper methods used for animations
            // Default to 11 pixel from the left (or right if RTL)
            var defaultOffset = [{ top: "0px", left: "11px", rtlflip: true }];

            var OffsetArray = WinJS.Class.define(function OffsetArray_ctor(offset, keyframe, defOffset) {
                // Constructor
                defOffset = defOffset || defaultOffset;
                if (Array.isArray(offset) && offset.length > 0) {
                    this.offsetArray = offset;
                    if (offset.length === 1) {
                        this.keyframe = checkKeyframe(offset[0], defOffset[0], keyframe);
                    }
                } else if (offset && offset.hasOwnProperty("top") && offset.hasOwnProperty("left")) {
                    this.offsetArray = [offset];
                    this.keyframe = checkKeyframe(offset, defOffset[0], keyframe);
                } else {
                    this.offsetArray = defOffset;
                    this.keyframe = chooseKeyframe(defOffset[0], keyframe);
                }
            }, { // Public Members
                getOffset: function (i) {
                    if (i >= this.offsetArray.length) {
                        i = this.offsetArray.length - 1;
                    }
                    return this.offsetArray[i];
                }
            }, { // Static Members
                supportedForProcessing: false,
            });

            function checkKeyframe(offset, defOffset, keyframe) {
                if (offset.keyframe) {
                    return offset.keyframe;
                }

                if (!keyframe ||
                    offset.left !== defOffset.left ||
                    offset.top !== defOffset.top ||
                    (offset.rtlflip && !defOffset.rtlflip)) {
                    return null;
                }

                if (!offset.rtlflip) {
                    return keyframe;
                }

                return keyframeCallback(keyframe);
            }

            function chooseKeyframe(defOffset, keyframe) {
                if (!keyframe || !defOffset.rtlflip) {
                    return keyframe;
                }

                return keyframeCallback(keyframe);
            }

            function keyframeCallback(keyframe) {
                var keyframeRtl = keyframe + "-rtl";
                return function (i, elem) {
                    return window.getComputedStyle(elem).direction === "ltr" ? keyframe : keyframeRtl;
                }
            }

            function makeArray(elements) {
                if (Array.isArray(elements) || elements instanceof NodeList || elements instanceof HTMLCollection) {
                    return elements;
                } else if (elements) {
                    return [elements];
                } else {
                    return [];
                }
            };

            function translateCallback(offsetArray, prefix) {
                prefix = prefix || "";
                return function (i, elem) {
                    var offset = offsetArray.getOffset(i);
                    var left = offset.left;
                    if (offset.rtlflip && window.getComputedStyle(elem).direction === "rtl") {
                        left = left.toString();
                        if (left.charAt(0) === "-") {
                            left = left.substring(1);
                        } else {
                            left = "-" + left;
                        }
                    }
                    return prefix + "translate(" + left + ", " + offset.top + ")";
                };
            };

            var MediaPlayer = WinJS.Class.define(function (element, options) {
                /// <signature helpKeyword="XboxJS.UI.MediaPlayer.MediaPlayer">
                /// <summary locid="XboxJS.UI.MediaPlayer.constructor">
                /// Creates a new MediaPlayer.
                /// </summary>
                /// <param name="element" domElement="true" locid="XboxJS.UI.MediaPlayer.constructor_p:element">
                /// The DOM element that hosts the MediaPlayer control.
                /// </param>
                /// <param name="options" type="Object" locid="XboxJS.UI.MediaPlayer.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.MediaPlayer" locid="XboxJS.UI.MediaPlayer.constructor_returnValue">
                /// The new MediaPlayer.
                /// </returns>
                /// </signature>

                msWriteProfilerMark("XboxJS.UI.MediaPlayer:constructor,StartTM");

                element = element || document.createElement("div");
                element.winControl = this;

                utilities.addClass(element, "win-disposable");

                // Private fields.
                this._adjustedContentType = null;
                this._areControlsHiding = false;
                this._backButton = null;
                this._busyIndicator = null;
                this._buttonEventSubscriptions = [];
                this._chapterSkipBackButton = null;
                this._chapterSkipForwardButton = null;
                this._closedCaptionsButton = null;
                this._element = element;
                if (Windows.Media.ContentRestrictions &&
                    Windows.Media.ContentRestrictions.RatedContentRestrictions) {
                    this._contentRestrictions = new Windows.Media.ContentRestrictions.RatedContentRestrictions();
                }
                this._checkPremiumVideoPrivilegeBind = this._checkPremiumVideoPrivilege.bind(this);
                this._checkParentalControlsBind = this._checkParentalControls.bind(this);
                this._checkPremiumVideoAndParentalControlsBind = this._checkPremiumVideoAndParentalControls.bind(this);
                this._controlHideTimeout = null;
                this._controls = null;
                this._controlsAddedHideDuration = null;
                this._controlsFadeInAnimation = null;
                this._controlsFadeOutAnimation = null;
                this._controlsKeyupInputHandler = null;
                this._currentTimeIndicator = null;
                this._currentTimeVisualElements = null;
                this._currentScrubbingVelocity = 0;
                this._defaultChapterMarkers = [];
                this._displayModeButton = null;
                this._disposed = false;
                // The following 3 does*NeedResetting variables are used to keep track of whether or not we to re-initialize endTime, startTime, and
                // the custom markers array to default values. They are initialized to 'true' because when the control is first instantiated, we need 
                // to set default values for these properties.
                this._doesEndTimeNeedResetting = true;
                this._doesStartTimeNeedResetting = true;
                this._doMarkersNeedResetting = true;
                this._endTime = 0;
                // We need to keep track of whether the endTime was reached so we can set button state appropriately
                this._endTimeReached = false;
                this._fastForwardButton = null;
                this._fastForwardOrRewindTimer = null;
                this._fastForwardOrRewindTimerElapsedTime = 0;
                this._gestureEventSubscriptions = [];
                this._gestureRecognizer = new Windows.UI.Input.GestureRecognizer();
                this._gestureRecognizer.gestureSettings =
                    Windows.UI.Input.GestureSettings.manipulationTranslateX |
                    Windows.UI.Input.GestureSettings.manipulationTranslateY;
                this._goToFullScreenButton = null;
                this._goToLiveButton = null;
                this._handleCheckpointCallback = null;
                this._handleSeekedAfterExitFastForwardOrRewindBind = null;
                this._handleSystemTransportControlsButtonPressedBind = null;
                this._handleTransportBarButtonFocus = null;
                this._handleTransportBarButtonFocusBind = null;
                this._handleVoiceEngagedBind = null;
                this._handleVoiceDisengagedBind = null;
                // We need this extra variable to keep track of when the 1st custom marker is added and the last custom marker is
                // removed. If we didn't care about when the 1st custom marker was added (as opposed to the 2nd), we could just check
                // to see if: this._markers.length > 0;
                this._hasCustomMarkers = false;
                this._inputHandlerClickCallback = null;
                this._inputHandlerPointerDownCallback, null,
                this._inputHandlerPointerMoveCallback = null,
                this._inputHandlerPointerUpCallback = null,
                this._infoButton = null;
                this._inputHandlerElement = null;
                this._isBusyInternal = false;
                this._isChapterMarkerVisualsDirty = false;
                this._isControlsVisible = false;
                this._isInFastForwardOrRewindMode = false;
                this._isFullScreen = true;
                this._isHandAtLeftEdge = false;
                this._isHandAtRightEdge = false;
                this._isMediaUsageCollectionAllowed = 0;
                this._isSeekWindowEnabled = false;
                this._isThumbnailEnabled = true;
                this._isThumbGrabbed = false;
                this._keydownInputHandler = null;
                this._keyupInputHandler = null;
                this._lastControlsResetTimeStamp = null;
                this._lastFastForwardOrRewindTimerTime = 0;
                this._lastPointerPosition = "0,0";
                this._lastPosition = 0;
                this._layout = null;
                this._loadTextTrackCallback = null;
                this._markers = [];
                this._mediaCommandFeedbackText = null;
                this._mediaElementAdapter = null;
                this._mediaEventSubscriptions = [];
                this._mediaMetadata = null;
                this._mediaState = {};
                this._metadataTitle = null;
                this._metadataDescription = null;
                this._moreButton = null;
                // This private field tracks the next marker time as an optimization so we don't have to iterate
                // through the entire marker collection when trying to determine which one is next. 
                // We initialize the next two values to '-1' rather than zero; because otherwise a 'markerreached'
                // event will always fire at time zero.
                this._nextCustomMarkerIndex = -1;
                this._nextCustomMarkerTime = -1;
                this._nextTrackButton = null;
                this._onHideControlsCommandInvokedBind = null;
                this._onShowControlsCommandInvokedBind = null;
                this._playbackSpeedIndicator = null;
                this._playPauseButton = null;
                this._playFromBeginningButton = null;
                this._previousPlaybackRate = 0;
                this._previousCustomMarkerIndex = -1;
                this._previousCustomMarkerTime = -1;
                this._previousTrackButton = null;
                this._progress = null;
                this._progressContainer = null;
                this._updateMediaStateBind = null;
                this._relativeTimelineStartOffset = 0;
                this._rewindButton = null;
                this._seekBar = null;
                this._seekMark = null;
                this._seekTimeIndicator = null;
                this._seekWindowLeftEdgeElement = null;
                this._seekWindowRightEdgeElement = null;
                this._smartGlassInputHandler = null;
                this._startOffsetX = 0;
                this._startTime = 0;
                this._stopButton = null;
                this._smtControls = null;
                if (Windows.Media.SystemMediaTransportControls) {
                    this._smtControls = Windows.Media.SystemMediaTransportControls.getForCurrentView();
                }
                this._targetPlaybackRate = 0;
                this._targetCurrentTime = 0;
                this._minimumSeekableRangeInPixels = 0;
                this._thumbElement = null;
                this._thumbElementWidthDividedByTwo = 0;
                this._thumbnailImage = null;
                this._thumbnailImageVisual = null;
                this._thumbImageElementWidthDividedByTwo = 0;
                this._timeline = null;
                // This time is in milliseconds. The recommended time for showing
                // progress is for operations that are two seconds or greater. By waiting
                // one second, we can avoid the flicker.
                this._timeBeforeShowingBusyVisual = 1000;
                this._timeFormatter = this._defaultTimeFormatter;
                this._timeRemainingIndicator = null;
                this._timeSeparator = strings.timeSeparator;
                this._timeSkipBackButton = null;
                this._timeSkipForwardButton = null;
                this._totalSeekBarWidth = 0;
                this._totalTimeInternal = 0;
                this._totalTimeIndicator = null;
                this._transportControls = null;
                this._transportControlsPrimary = null;
                this._transportControlsSecondary = null;
                this._wasStartTimeSetProgrammatically = false;
                this._wasEndTimeSetProgrammatically = false;
                this._wasDragAndNotClick = false;
                this._wasPausedBeforeScrubbing = false;
                this._wasPlayingBeforeSuspend = false;
                // This variable keeps track of whether the time was clamped to the end time. There are cases where we need the
                // current time can go past the end time. If we perform more than one seek in this state, it is possible to trigger
                // a condition in Media Foundation that results in the ended event not being fired. To work around the issue, we
                // keep track of whether we've already clamped the end time once so that we don't do it more than once and trigger
                // the undesirable condition.
                this._wasTimeClampedToEndTime = false;
                this._windowResizeCallback = null;

                // Constants
                // This value is used to determine whether the current time is close enough to the nearest marker
                // that is can be considered at the marker for chapter skipping purposes. See the chapterSkipForward
                // or chapterSkipBack functions for more detail. The value is in seconds.
                this._CHAPTER_SKIP_THRESHOLD = 1;
                this._CONTROLS_AUTO_HIDE_DURATION = 3000;
                // How often the function to update the time display during a fast forward or rewind is called.
                this._FAST_FORWARD_OR_REWIND_TIMER_INTERVAL = 250;
                this._MARKER_PROXIMITY_THRESHOLD = 0.5;
                // We won't add chapter markers for media under 1 minute
                this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS = 60;
                // This number represents the minimum time range where scrubbing is accurate with gesture.
                this._MINIMUM_ACCURATE_SEEKABLE_RANGE = 1800;
                // The minimum distance between consecutive pointer events for the MediaPlayer's
                // scrubbing logic to determine that the user is moving "quickly" across the timeline
                // and does not want the "sticky marker" behavior. Units are in pixels.
                this._MINIMUM_POINTER_DELTA_TO_ENABLE_SNAPPING_TO_NEAREST_MARKER = 4;
                // The amount of space on the left and right of the user that is used for. 
                // using gesture to move the seekable window. Units are in pixels.
                this._GESTURE_REGION_FOR_MOVING_THE_SEEKABLE_WINDOW = 200;
                // We report media state to various listeners via the Playback Manager every 30 seconds.
                this._REPORT_MEDIA_STATE_INTERVAL = 5000;
                this._SEEK_OFFSET = 0.1;
                this._SKIP_BACK_INTERVAL = 8;
                this._SKIP_FORWARD_INTERVAL = 30;
                // If the user is scrubbing and the timeline is within a distance of
                // a marker, the timeline will snap to the marker. The Value is expressed 
                // as a percentage of the total length of the timeline.
                this._SNAP_TO_NEAREST_MARKER_THRESHOLD = 0.005;

                // Media ready states
                this._MEDIA_READY_STATE_HAVE_NOTHING = 0;
                this._MEDIA_READY_STATE_HAVE_METADATA = 1;
                this._MEDIA_READY_STATE_HAVE_CURRENT_DATA = 2;
                this._MEDIA_READY_STATE_HAVE_FUTURE_DATA = 3;
                this._MEDIA_READY_STATE_HAVE_ENOUGH_DATA = 4;

                // PlaybackRates
                this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE = 128;
                this._PLAYBACKRATE_FAST_FORWARD_128X = 128;
                this._PLAYBACKRATE_FAST_FORWARD_64X = 64;
                this._PLAYBACKRATE_FAST_FORWARD_32X = 32;
                this._PLAYBACKRATE_FAST_FORWARD_16X = 16;
                this._PLAYBACKRATE_FAST_FORWARD_8X = 8;
                this._PLAYBACKRATE_FAST_FORWARD_4X = 4;
                this._PLAYBACKRATE_FAST_FORWARD_2X = 2;
                this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE = 0.5;
                this._PLAYBACKRATE_PLAYING = 1;
                this._PLAYBACKRATE_NOT_PLAYING = 1;
                this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE = -0.5;
                this._PLAYBACKRATE_REWIND_2X = -2;
                this._PLAYBACKRATE_REWIND_4X = -4;
                this._PLAYBACKRATE_REWIND_8X = -8;
                this._PLAYBACKRATE_REWIND_16X = -16;
                this._PLAYBACKRATE_REWIND_32X = -32;
                this._PLAYBACKRATE_REWIND_64X = -64;
                this._PLAYBACKRATE_REWIND_128X = -128;
                this._PLAYBACKRATE_REWIND_MAX_RATE = -128;

                // MEDIA ELEMENT TAG NAMES
                this._TAG_NAME_AUDIO = "AUDIO";
                this._TAG_NAME_VIDEO = "VIDEO";

                if (options &&
                    options.layout) {
                    this._layout = options.layout;
                } else {
                    this._layout = layout.full;
                }

                // This is the innerHTML that gets rendered when the MediaPlayer is instantiated. 
                this._mediaPlayerHtml = "<div class='win-mediaplayer-container'>" +
                                      "   <div class='win-mediaplayer-controls win-mediaplayer-hidden'>" +
                                      "           <div class='win-mediaplayer-mediatitle'></div>" +
                                      "           <div class='win-mediaplayer-mediadescription'></div>" +
                                      "       <div class='win-mediaplayer-timeline win-mediaplayer-thumbnailmode'>" +
                                      "           <div class='win-mediaplayer-progresscontainer'>" +
                                      "               <div class='win-mediaplayer-seekbar'>" +
                                      "                 <div class='win-mediaplayer-seekprogress'></div>" +
                                      "                 <div class='win-mediaplayer-seekbarvisualelements-container'>" +
                                      "                     <div class='win-mediaplayer-thumb win-mediaplayer-hidden'>" +
                                      "                         <div class='win-mediaplayer-thumbvisual'></div>" +
                                      "                     </div>" +
                                      "                     <div class='win-mediaplayer-thumbnail win-mediaplayer-hidden'>" +
                                      "                         <div class='win-mediaplayer-thumbnailvisual'>" +
                                      "                             <div class='win-mediaplayer-seektimeindicator'></div>" +
                                      "                             <div class='win-mediaplayer-playbackspeedindicator'></div>" +
                                      "                         </div>" +
                                      "                     </div>" +
                                      "                     <div class='win-mediaplayer-seek-mark'></div>" +
                                      "                 </div>" +
                                      "                 <div class='win-mediaplayer-seek-leftboundary win-invisible'></div>" +
                                      "                 <div class='win-mediaplayer-seek-rightboundary win-invisible'></div>" +
                                      "               </div>" +
                                      "               <div class='win-mediaplayer-currenttimeindicator'></div>" +
                                      "               <div class='win-mediaplayer-timeremainingindicator'></div>" +
                                      "               <div class='win-mediaplayer-totaltimeindicator'></div>" +
                                      "           </div>" +
                                      "           <div class='win-mediaplayer-inputfeedback'>Info</div>" +
                                      "       </div>" +
                                      "       <div class='win-mediaplayer-transportcontrols'>" +
                                      "           <div class='win-mediaplayer-transportcontrols-primary'>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-stopbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/STOP_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/STOP_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/STOP_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-stopicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-playfrombeginningbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REPLAY_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REPLAY_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REPLAY_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-replayicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-previoustrackbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PREV_TRACK_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PREV_TRACK_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PREV_TRACK_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-previoustrackicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-chapterskipbackbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CHAPTER_SKIP_BACK_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CHAPTER_SKIP_BACK_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CHAPTER_SKIP_BACK_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-chapterskipbackicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-rewindbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REWIND_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REWIND_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REWIND_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-rewindicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-timeskipbackbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TIME_SKIP_BACK_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TIME_SKIP_BACK_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TIME_SKIP_BACK_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-timeskipbackicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-playpausebutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PLAY_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PLAY_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PLAY_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-playpausetogglevisual win-mediaplayer-playicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-timeskipforwardbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TIME_SKIP_FWD_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TIME_SKIP_FWD_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TIME_SKIP_FWD_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-timeskipforwardicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-fastforwardbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FAST_FWD_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FAST_FWD_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FAST_FWD_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-fastforwardicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-chapterskipforwardbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CHAPTER_SKIP_FWD_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CHAPTER_SKIP_FWD_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CHAPTER_SKIP_FWD_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-chapterskipforwardicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-nexttrackbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/NEXT_TRACK_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/NEXT_TRACK_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/NEXT_TRACK_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                <span class='win-mediaplayer-icon win-mediaplayer-nexttrackicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-closedcaptionsbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CLOSED_CAPTIONS_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CLOSED_CAPTIONS_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/CLOSED_CAPTIONS_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-closedcaptionsicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-displaymodebutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/DISPLAY_MODE_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/DISPLAY_MODE_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/DISPLAY_MODE_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-displaymodeicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-livebutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/GOTO_LIVE_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/GOTO_LIVE_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/GOTO_LIVE_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-liveicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-infobutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/INFO_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/INFO_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/INFO_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-infoicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-morebutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/MORE_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/MORE_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/MORE_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-moreicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "              <button tabIndex='0' class='win-mediaplayer-transportcontrols-builtinbutton win-mediaplayer-gotofullscreenbutton' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/GOTO_FULL_SCREEN_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/GOTO_FULL_SCREEN_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/GOTO_FULL_SCREEN_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }\">" +
                                      "                 <span class='win-mediaplayer-icon win-mediaplayer-snappedicon'></span>" +
                                      "                 <span class='win-voice-textdisplay win-voice-activetext'></span>" +
                                      "              </button>" +
                                      "            </div>" +
                                      "            </br>" +
                                      "            <div class='win-mediaplayer-transportcontrols-secondary'>" +
                                      "            </div>" +
                                      "       </div>" +
                                      "    </div>" +
                                      "</div>" +
                                      "<div class='win-mediaplayer-inputhandler'></div>" +
                                      "<progress class='win-mediaplayer-busy win-mediaplayer-hidden win-ring win-large'></progress>";

                var that = this;

                // Note: We need to initialize _keydownInputHandler here, because it is used by isFullScreen
                this._keydownInputHandler = function handleKeyDownInput(eventObject) {
                    that._onInputHandlerKeyDown(eventObject);
                };

                this._keyupInputHandler = function handleKeyUpInput(eventObject) {
                    that._onInputHandlerKeyUp(eventObject);
                };

                this._controlsKeyupInputHandler = function handleControlsKeyInput(eventObject) {
                    that._onControlsKeyupInputHandler(eventObject);
                };

                // Default to fullscreen mode
                this.isFullScreen = true;

                this._windowResizeCallback = function handleResize() {

                    if (that._disposed) {
                        return;
                    }

                    var mediaPlayerContainer = that._element.querySelector(".win-mediaplayer-controls");
                    if (!mediaPlayerContainer) {
                        return;
                    }

                    if (wuiv &&
                        wuiv.ApplicationView.value === wuiv.ApplicationViewState.snapped) {
                        utilities.removeClass(mediaPlayerContainer, "win-mediaplayer-hidden");
                        that.showControls();
                    } else {
                        utilities.addClass(mediaPlayerContainer, "win-mediaplayer-hidden");

                        // Note: We need to reset this field so the MediaPlayer can maintain the correct
                        // UI state. If _isControlsVisible = true, which would be the case if the controls
                        // were up right before the MediaPlayer was snapped then when the MediaPlayer returns
                        // from being snapped _isControlsVisible will still be true even though the
                        // controls may or may not be visible.
                        that._isControlsVisible = false;
                        that.hideControls();
                    }

                    that._totalSeekBarWidth = that._seekBar.clientWidth;
                };
                window.addEventListener("resize", this._windowResizeCallback, false);

                // When we are hidden, we pause the media
                this._handleVisibilityChangedCallback = function handleVisibilityChanged(ev) {

                    if (document.visibilityState === "hidden") {
                        if (that._mediaElementAdapter.mediaElement &&
                            that._mediaElementAdapter.mediaElement.paused) {
                            that._wasPlayingBeforeSuspend = false;
                        } else {
                            that._wasPlayingBeforeSuspend = true;
                        }

                        that.pause();
                    } else if (document.visibilityState === "visible") {
                        if (that._wasPlayingBeforeSuspend) {
                            that.play();
                        } else {
                            that.pause();
                        }
                    }
                };
                document.addEventListener("visibilitychange", this._handleVisibilityChangedCallback, false);

                // When we go into the background, we should pause the media
                this._handleCheckpointCallback = function () {
                    that.pause();
                };
                app.addEventListener("checkpoint", this._handleCheckpointCallback, false);

                this._updateDomElements();

                // Set the rest of the options
                if (options) {
                    WinJS.UI.setOptions(this, options);
                }

                // Create a default mediaElementAdapter if none was specified
                if (!this._mediaElementAdapter) {
                    this.mediaElementAdapter = new XboxJS.UI.MediaElementAdapter(this, null);
                }

                // If we are starting in snapped mode then we need to show controls
                if (wuiv &&
                    wuiv.ApplicationView.value === wuiv.ApplicationViewState.snapped) {
                    this._showControls(true);
                }

                this._handleBeforeNavigatedCallback = function () {
                    that._handleBeforeNavigated();
                };
                WinJS.Navigation.addEventListener("beforenavigate", this._handleBeforeNavigatedCallback, false);

                // Set a timer to report state to SmartGlass periodically
                this._updateMediaStateBind = this._updateMediaState.bind(this);
                this._updateMediaStateTimerCookie = setInterval(this._updateMediaStateBind, this._REPORT_MEDIA_STATE_INTERVAL);

                if (WinJS.Utilities.hasWinRT) {
                    Windows.UI.WebUI.WebUIApplication.addEventListener("resuming", this._checkPremiumVideoAndParentalControlsBind, false);
                }

                if (this._contentRestrictions) {
                    this._contentRestrictions.addEventListener("restrictionschanged", this._checkParentalControlsBind, false);
                }

                // Listen for active listening & show the controls and don't hide them until we go out of active listening
                if (XboxJS) {
                    this._onShowControlsCommandInvokedBind = this._onShowControlsCommandInvoked.bind(this);
                    this._onHideControlsCommandInvokedBind = this._onHideControlsCommandInvoked.bind(this);
                    XboxJS.UI.Voice.addEventListener("listeningstart", this._onShowControlsCommandInvokedBind, false);
                    XboxJS.UI.Voice.addEventListener("listeningend", this._onHideControlsCommandInvokedBind, false);
                    window.addEventListener("gestureengaged", this._onShowControlsCommandInvokedBind, false);
                    window.addEventListener("gesturedisengaged", this._onHideControlsCommandInvokedBind, false);
                }

                // Check if we're in gesture or voice mode. If so we need to show the controls
                if (XboxJS.Utilities._isVoiceEngaged ||
                    XboxJS.Utilities._isGestureEngaged) {
                    // We use setImmediate because the MediaPlayer needs to finish initializing some state before showing the controls. If
                    // we call it without setImmediate, the timeline won't update until the controls are dismissed and then shown again.
                    setImmediate(function () {
                        if (that._onShowControlsCommandInvokedBind) {
                            that._onShowControlsCommandInvokedBind();
                        }
                    });
                }

                // Set up the system transport controls event handlers
                if (Windows.Media.SystemMediaTransportControls) {
                    // We need to set the enabled state for stop during construction
                    this._smtControls.isStopEnabled = nav.canGoBack;
                    this._handleSystemTransportControlsButtonPressedBind = this._handleSystemTransportControlsButtonPressed.bind(this);
                    this._handleSystemTransportControlsPropertyChangedBind = this._handleSystemTransportControlsPropertyChanged.bind(this);
                    this._smtControls.addEventListener("buttonpressed", this._handleSystemTransportControlsButtonPressedBind, false);
                    this._smtControls.addEventListener("propertychanged", this._handleSystemTransportControlsPropertyChangedBind, false);
                    this.isMediaUsageCollectionAllowed = 0;
                }

                if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.MediaPlayer._sounds.initialized) {
                    XboxJS.UI.MediaPlayer._sounds.elementFocus1 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus1"));
                    XboxJS.UI.MediaPlayer._sounds.elementFocus2 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus2"));
                    XboxJS.UI.MediaPlayer._sounds.elementFocus3 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus3"));
                    XboxJS.UI.MediaPlayer._sounds.elementFocus4 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus4"));
                    XboxJS.UI.MediaPlayer._sounds.selectButtonClick = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///SelectButtonClick"));
                    XboxJS.UI.MediaPlayer._sounds.overlayIn = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///OverlayIn"));
                    XboxJS.UI.MediaPlayer._sounds.overlayOut = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///OverlayOut"));
                    XboxJS.UI.MediaPlayer._sounds.initialized = true;
                }

                msWriteProfilerMark("XboxJS.UI.MediaPlayer:constructor,StopTM");
            },
            {
                // Private properties
                _isBusy: {

                    get: function () {
                        return this._isBusyInternal;
                    },

                    set: function (value) {
                        if (this._disposed) {
                            return;
                        }

                        this._isBusyInternal = value;

                        var that = this;
                        if (value) {
                            utilities.removeClass(this._busyIndicator, "win-mediaplayer-hidden");
                            WinJS.UI.executeTransition(this._busyIndicator,
                                [{
                                    property: "opacity",
                                    delay: 0,
                                    duration: 200,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: 0,
                                    to: 1
                                }]);
                        } else {
                            // The duration of the fade out is set to one second to avoid flicker.
                            WinJS.Promise.timeout(1000).then(function afterShortDelay() {
                                if (!that._busyIndicator) {
                                    return;
                                }

                                var fadeOutSpinnerAnimationPromise = WinJS.UI.executeTransition(that._busyIndicator,
                                    [{
                                        property: "opacity",
                                        delay: 0,
                                        duration: 200,
                                        timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                        from: 1,
                                        to: 0
                                    }]);
                                fadeOutSpinnerAnimationPromise.done(function afterSpinnerFadeOut() {
                                    if (that._busyIndicator) {
                                        utilities.addClass(that._busyIndicator, "win-mediaplayer-hidden");
                                    }
                                });
                            });
                        }

                        this._updateMediaState(false);
                    }
                },

                _totalTime: {

                    get: function () {
                        return this._totalTimeInternal;
                    },

                    set: function (value) {

                        this._totalTimeInternal = value;

                        if (!this._markers.length &&
                            this._totalTimeInternal > this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS) {
                            this._initializeDefaultChapterMarkers();
                        } else {
                            this._defaultChapterMarkers.length = 0;
                        }
                    }
                },

                // Private methods

                // Add an event handler for a button. This method tracks keeps a list of the handlers so they can be unsubscribed later.
                _addButtonEventHandler: function (button, eventName, handler) {

                    if (button) {
                        var that = this;
                        var buttonClickEventSubscription = {
                            button: button,
                            eventName: eventName,
                            handler: function (ev) {
                                handler.call(that, ev);

                                // If the button was clicked via voice, we need to play the press animation
                                if (ev.type === "click" &&
                                    !ev.deviceSessionId) {
                                    var buttonIcon = ev.target.querySelector(".win-mediaplayer-icon");
                                    if (buttonIcon) {
                                        WinJS.UI.executeAnimation(buttonIcon, [{
                                            property: "transform",
                                            delay: 0,
                                            duration: 100,
                                            timing: "ease-out",
                                            from: "scale(2)",
                                            to: "scale(1)"
                                        }]);
                                    }
                                }
                            }
                        }

                        button.addEventListener(eventName, buttonClickEventSubscription.handler, false);
                        this._buttonEventSubscriptions.push(buttonClickEventSubscription);
                    }
                },

                // Add a handler for gesture events. This method tracks keeps a list of the handlers so they can be unsubscribed later.
                _addGestureEventHandler: function (owner, eventName, handler) {

                    var that = this;
                    var gestureEventSubscription = {
                        owner: owner,
                        eventName: eventName,
                        handler: function (evt) {
                            handler.call(that, evt);
                        }
                    }

                    owner.addEventListener(eventName, gestureEventSubscription.handler, false);
                    this._gestureEventSubscriptions.push(gestureEventSubscription);
                },

                // Add a media event listener. This method tracks keeps a list of the handlers so they can be unsubscribed later.
                _addMediaEventListener: function (mediaElement, eventName, handler) {

                    if (mediaElement) {
                        mediaElement.addEventListener(eventName, handler, false);
                        if (this._mediaEventSubscriptions) {
                            this._mediaEventSubscriptions.push({ eventName: eventName, handler: handler });
                        }
                    }
                },

                // Checks if the right conditions are met such that the user can stream video
                _checkPremiumVideoPrivilege: function () {
                    var that = this;
                    return new WinJS.Promise(function (complete, error) {

                        // If there is no requiresPremiumVideoPrivilege field, that means that developer is telling us not to do a premium video
                        // check. If we not running on Xbox, we don't do the check.
                        if (!that._mediaMetadata ||
                            !that._mediaMetadata.requiresPremiumVideoPrivilege ||
                            !Windows.Xbox) {
                            complete(true);
                            return;
                        }

                        // We wait on all outstanding promises
                        var hasPremiumVideoPriviledgePromises = [];
                        var numberOfSignedInNonGuestUsers = 0;
                        var isAllowedToViewContentBasedOnPremiumVideoPriviledge = false;
                        // '224' is the privilege for premium video
                        var premiumVideoPrivilegeId = 224;
                        var noIssueResult = Windows.Xbox.ApplicationModel.Store.PrivilegeCheckResult.noIssue;
                        var priviledgeCheckResult = noIssueResult;
                        // We do this check asynchronously. It makes a service call so it could take a while to return.
                        // We allow the video to play, but will return an error if it comes back false.
                        var users = Windows.Xbox.System.User.users;
                        for (var i = 0, len = users.size; i < len; i++) {
                            if (users[i].isSignedIn &&
                                !users[i].isGuest) {
                                hasPremiumVideoPriviledgePromises.push(Windows.Xbox.ApplicationModel.Store.Product.checkPrivilegeAsync(users[i], premiumVideoPrivilegeId, true, null));
                                numberOfSignedInNonGuestUsers++;
                            }
                        }

                        // Listen for the promises to return
                        for (var i = 0, len = numberOfSignedInNonGuestUsers; i < len; i++) {
                            if (hasPremiumVideoPriviledgePromises.length) {
                                hasPremiumVideoPriviledgePromises[i].then(function (result) {
                                    if (result === noIssueResult) {
                                        isAllowedToViewContentBasedOnPremiumVideoPriviledge = true;
                                    } else {
                                        isAllowedToViewContentBasedOnPremiumVideoPriviledge = false;
                                    }
                                });
                            }
                        }

                        if (numberOfSignedInNonGuestUsers === 0) {
                            isAllowedToViewContentBasedOnPremiumVideoPriviledge = false;
                        }

                        WinJS.Promise.join(hasPremiumVideoPriviledgePromises)
                            .then(
                                function () {
                                    if (isAllowedToViewContentBasedOnPremiumVideoPriviledge) {
                                        complete(true);
                                    } else {
                                        complete(false);
                                    }
                                },
                        function unknownError() {
                            // We should never hit this case, but if we do call the error handler
                            error();
                        });
                    });
                },

                // Checks if the content restrictions are such that the user is allowed to stream video
                _checkParentalControls: function () {
                    // If contentRating has been set to a valid contentRating, then
                    // we check the family settings to see if the user is allowed to
                    // view the content.
                    if (!WinJS.Utilities.hasWinRT ||
                        !Windows.Xbox ||
                        !this._mediaMetadata ||
                        !this._mediaMetadata.contentRating ||
                        !this._mediaMetadata.contentType ||
                        !this._mediaMetadata.contentId) {
                        return WinJS.Promise.wrap(true);
                    }

                    // We need to map the contentType from the one in the XboxJS.Data.ContentType
                    // enumeration to the contentType enumeration in the family safety API.
                    var contentRestrictionsNamespace = Windows.Media.ContentRestrictions;
                    var contentType = this._convertContentType(this._mediaMetadata.contentType);
                    var contentDescription = new Windows.Media.ContentRestrictions.RatedContentDescription(
                        this._mediaMetadata.contentId,
                        this._mediaMetadata.title,
                        null,
                        contentType
                    );

                    contentDescription.category = contentType;
                    var ratingArray = [];
                    if (Array.isArray(this._mediaMetadata.contentRating)) {
                        ratingArray = this._mediaMetadata.contentRating;
                    } else {
                        ratingArray = [this._mediaMetadata.contentRating];
                    }
                    for (var i = 0, len = ratingArray.length; i < len; i++) {
                        contentDescription.ratings[i] = ratingArray[i];
                    }

                    return this._contentRestrictions.requestContentAccessAsync(contentDescription);
                },

                _checkPremiumVideoAndParentalControls: function () {
                    if (this._disposed) {
                        return;
                    }

                    var hasPremiumVideoPriviledge = false;
                    var hasParentalControlsPrivilege = false;
                    var checkPremiumVideoPromise = this._checkPremiumVideoPrivilegeBind()
                        .then(
                            function afterPriviledgeCheck(result) {
                                if (result) {
                                    hasPremiumVideoPriviledge = true;
                                } else {
                                    hasPremiumVideoPriviledge = false;
                                }
                            },
                            function error() {
                                hasPremiumVideoPriviledge = false;
                            });
                    var checkParentalControlsPromise = this._checkParentalControlsBind()
                        .then(
                            function afterParentalControlsCheck(result) {
                                if (result) {
                                    hasParentalControlsPrivilege = true;
                                } else {
                                    hasParentalControlsPrivilege = false;
                                }
                            },
                            function error() {
                                hasParentalControlsPrivilege = false;
                            });

                    WinJS.Promise.join([checkPremiumVideoPromise, checkParentalControlsPromise])
                        .then(
                            function afterPriviledgeChecksHaveCompleted() {
                                if (hasPremiumVideoPriviledge &&
                                    hasParentalControlsPrivilege) {
                                    // No-op - continue video playback
                                } else {
                                    // The expected behavior is to navigate back, or if there is no back stack, pause the media
                                    // and hide it.
                                    if (WinJS.Navigation.canGoBack) {
                                        WinJS.Navigation.back();
                                    } else {
                                        that.pause();
                                        if (that._mediaElementAdapter.mediaElement) {
                                            that._mediaElementAdapter.mediaElement.style.display = "none";
                                        }
                                    }
                                }
                            },
                            function error() {
                                // No-op. This error handler should never get called in practice. But it exists, because
                                // if there is an async error and the error handler is not defined, the app will crash.
                            });
                },

                // This is a helper function that will go away once ratings move to strings
                _convertContentType: function (origionalContentType) {
                    var dataModelContentType = XboxJS.Data.ContentType;
                    var ratingCategory = null;
                    if (Windows.Media.ContentRestrictions) {
                        ratingCategory = Windows.Media.ContentRestrictions.RatedContentCategory;
                    }
                    var adjustedContentType = ratingCategory.general;
                    switch (origionalContentType) {
                        case dataModelContentType.album:
                            adjustedContentType = ratingCategory.music;
                            break;
                        case dataModelContentType.movie:
                            adjustedContentType = ratingCategory.movie;
                            break;
                        case dataModelContentType.musicArtist:
                            adjustedContentType = ratingCategory.music;
                            break;
                        case dataModelContentType.track:
                            adjustedContentType = ratingCategory.music;
                            break;
                        case dataModelContentType.tvEpisode:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.tvSeason:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.tvSeries:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.tvShow:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.webVideo:
                            adjustedContentType = ratingCategory.general;
                            break;
                        case dataModelContentType.webVideoCollection:
                            adjustedContentType = ratingCategory.general;
                            break;
                        default:
                            adjustedContentType = ratingCategory.general;
                            break;
                    };

                    return adjustedContentType;
                },

                // Removes the DOM elements from the timeline that are used to visualize chapter markers.
                // This function does not remove chapter markers from the _markers or _defaultChapterMarkers array.
                _clearChapterMarkerVisuals: function () {

                    // We need to make sure the _element is not null, which is possible if dispose was called
                    if (this._disposed) {
                        return;
                    }

                    this._clearDefaultChapterMarkers();

                    // Remove custom chapter markers if they exist
                    var markersLength = this._markers.length;
                    for (var i = 0; i < markersLength; i++) {

                        if (this._markers[i].type === markerType.chapter) {
                            var time = this._markers[i].time;

                            var marker = this._element.querySelector("#ms__marker" + (time.toString()).replace(".", "_"));

                            // Note: This check is necessary, because the markers in the _markers collection do not
                            // always have a corresponding DOM element on the timeline. This is because we add the marker visuals
                            // at a different time than we add them to the _markers array.
                            if (marker &&
                                marker.parentNode) {
                                marker.parentNode.removeChild(marker);
                            }
                        }
                    }
                },

                // Removes the default chapters markers and DOM elements used to represent the default chapter markers.
                _clearDefaultChapterMarkers: function () {

                    if (this._disposed) {
                        return;
                    }

                    var defaultChapterMarkersLength = this._defaultChapterMarkers.length;
                    for (var i = 0; i < defaultChapterMarkersLength; i++) {

                        if (this._defaultChapterMarkers[i].type === markerType.chapter) {
                            var time = this._defaultChapterMarkers[i].time;

                            var marker = this._element.querySelector("#ms__marker" + (time.toString()).replace(".", "_"));
                            if (marker &&
                                marker.parentNode) {
                                marker.parentNode.removeChild(marker);
                            }
                        }
                    }

                    this._defaultChapterMarkers.length = 0;
                },

                // Clears the feedback text on the timeline that shows the last executed media command.
                _clearMediaCommandFeedbackText: function () {

                    if (this._mediaCommandFeedbackText) {
                        this._mediaCommandFeedbackText.textContent = "";
                    }
                },

                _clearTimeDisplay: function () {

                    if (this._currentTimeIndicator &&
                        this._totalTimeIndicator) {
                        this._currentTimeIndicator.textContent = "";
                        this._totalTimeIndicator.textContent = "";
                        this._seekTimeIndicator.textContent = "";
                    }
                },

                // Helper function to create a button to add to the transport bar
                _createTransportBarButton: function (buttonClassName, label, iconClassName, invokedHandler, container) {
                    var itemContainerDiv = document.createElement("div");
                    itemContainerDiv.innerHTML = "<div class='win-mediaplayer-layout-icon " + iconClassName + "'>" + label + "</div>" +
                                                    "</div>";

                    itemContainerDiv.className = "win-mediaplayer-transportcontrols-button " + buttonClassName;
                    var itemContainer = new XboxJS.UI.ItemContainer(itemContainerDiv);
                    container.appendChild(itemContainerDiv);

                    this._addButtonEventHandler(itemContainer.element, "focus", this._handleTransportBarButtonFocusBind);
                    this._addButtonEventHandler(itemContainer, "invoked", invokedHandler);

                    return itemContainerDiv;
                },

                // Formats time in seconds to the hh:mm:ss format.
                _defaultTimeFormatter: function (seconds) {

                    if (isNaN(seconds)) {
                        return "";
                    }

                    var minutes = Math.floor(seconds / 60);
                    seconds = Math.floor(seconds % 60);
                    var hours = Math.floor(minutes / 60);
                    minutes = minutes % 60;

                    var timeString = "";
                    if (hours > 0) {
                        timeString = hours.toString() + this._timeSeparator + this._getTimeString(minutes) + this._timeSeparator + this._getTimeString(seconds);
                    } else {
                        timeString = minutes.toString() + this._timeSeparator + this._getTimeString(seconds);
                    }

                    return timeString;
                },

                // Helper to raise a cancellable event through the containerElement
                _dispatchCancellableEvent: function (eventName, detail) {
                    if (this._disposed) {
                        // We return true because the event will never get raised if the control is disposed.
                        // Therefore the developer could not have prevented the event so the only possible return
                        // value is true.
                        return true;
                    }

                    var dispatchedEvent = document.createEvent("Event");
                    dispatchedEvent.initEvent(eventName, true, true);

                    if (detail) {
                        dispatchedEvent.detail = detail;
                    }

                    return this._element.dispatchEvent(dispatchedEvent);
                },

                _exitFastForwardOrRewind: function (shouldPlay) {

                    if (!this._isInFastForwardOrRewindMode) {
                        return;
                    }

                    clearInterval(this._fastForwardOrRewindTimer);
                    this._fastForwardOrRewindTimer = null;
                    this._isInFastForwardOrRewindMode = false;

                    // Hide the thumbnails. We do this regardless of whether thumbnail mode is enabled,
                    // because it will be a no-op if thumbnail mode is disabled.
                    if (this._thumbnailImage) {
                        WinJS.Utilities.addClass(this._thumbElement, "win-mediaplayer-hidden");
                        WinJS.Utilities.addClass(this._thumbnailImage, "win-mediaplayer-hidden");

                        WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-scrubbing");
                        WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-rewind");
                        WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-fastforward");
                    }

                    if (this._isThumbnailEnabled &&
                        this._mediaElementAdapter &&
                        this._isFastForwardOrRewind(this._targetPlaybackRate)) {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement &&
                            this._mediaElementAdapter.mediaElement.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            // If we are past the endTime, we need to seek to just before the endTime so the developer can
                            // get the ended event on the mediaElement.
                            this._shouldPlayAfterExitingFastForwardOrRewind = shouldPlay;

                            // Reset the playbackRate to the previous value
                            this._mediaElementAdapter.mediaElement.playbackRate = this._previousPlaybackRate;

                            if (!this._handleSeekedAfterExitFastForwardOrRewindBind) {
                                this._handleSeekedAfterExitFastForwardOrRewindBind = this._handleSeekedAfterExitFastForwardOrRewind.bind(this);
                            }
                            this._mediaElementAdapter.mediaElement.addEventListener("seeked", this._handleSeekedAfterExitFastForwardOrRewindBind, false);
                            if (this._targetCurrentTime > this._endTime - this._SEEK_OFFSET &&
                                !this._wasTimeClampedToEndTime) {
                                this._wasTimeClampedToEndTime = true;
                                this._seekInternal(this._endTime - this._SEEK_OFFSET, false);
                            } else {
                                this._seekInternal(this._targetCurrentTime, false);
                            }
                        }

                        this._targetPlaybackRate = 1;
                    }

                    // Since the auto-hide timer is disabled in fast forward or rewind mode,
                    // we need to manually hide the controls.
                    if (this._controlHideTimeout) {
                        this._removeControlsTimer();
                    }

                    if (!XboxJS.Utilities._isGestureEngaged ||
                        !XboxJS.Utilities._isVoiceEngaged) {
                        this._setControlsTimer();
                    }

                    // Update voice strings for Fast Forward and Rewind
                    if (this._fastForwardButton) {
                        this._fastForwardButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FAST_FWD_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FAST_FWD_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FAST_FWD_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                    }
                    if (this._rewindButton) {
                        this._rewindButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REWIND_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REWIND_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/REWIND_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                    }
                    XboxJS.UI.Voice.refreshVoiceElements();
                },

                // Pads seconds or minutes with leading zeros and returns string format. Seconds or Minutes should be less than 60.
                _getTimeString: function (secondsOrMinutes) {

                    var stringForm = secondsOrMinutes.toString();

                    if (secondsOrMinutes < 10) {
                        stringForm = "0" + stringForm;
                    }

                    return stringForm;
                },

                _getTotalTimeText: function () {

                    var totalTime = "";
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._totalTime !== Infinity) {
                        totalTime = Math.ceil(this._totalTime);
                    }

                    return this._timeFormatter(totalTime);
                },

                _getElapsedTimeText: function () {

                    var elapsedTime = "";
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var currentTime = 0;
                        if (!this._isInFastForwardOrRewindMode) {
                            currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        } else {
                            currentTime = this._targetCurrentTime;
                        }

                        if (currentTime < this._startTime) {
                            currentTime = this._startTime;
                        } else if (currentTime > this._endTime) {
                            currentTime = this._endTime;
                        }

                        elapsedTime = Math.ceil(currentTime - this._startTime);
                    }

                    return this._timeFormatter(elapsedTime);
                },

                _getRemainingTimeText: function () {

                    var remainingTime = "";
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var currentTime = 0;
                        if (!this._isInFastForwardOrRewindMode) {
                            currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        } else {
                            currentTime = this._targetCurrentTime;
                        }

                        if (currentTime < this._startTime) {
                            currentTime = this._startTime;
                        } else if (currentTime > this._endTime) {
                            currentTime = this._endTime;
                        }

                        remainingTime = Math.ceil(this._endTime - (currentTime - this._startTime));
                    }

                    return "-" + this._timeFormatter(remainingTime);
                },

                _handlePointerDown: function (args) {
                    var pp = Windows.UI.Input.PointerPoint.getCurrentPoint(args.pointerId);
                    // Need to try... catch, because this method throws exceptions "by design"
                    try {
                        this._gestureRecognizer.processDownEvent(pp);
                    } catch (ex) { }
                    this._handlePointerMove(args);
                },

                // There are cases where the controls can disappear while gesture is engaged. To make sure this never happens,
                // we listen for hover and if the controls are ever not visible, we show them.
                _handlePointerHover: function (args) {
                    this._onShowControlsCommandInvokedBind();
                },

                _handlePointerMove: function (args) {
                    var pps = Windows.UI.Input.PointerPoint.getIntermediatePoints(args.pointerId);
                    // Need to try... catch, because this method throws exceptions "by design"
                    try {
                        this._gestureRecognizer.processMoveEvents(pps);
                    } catch (ex) { }

                    // The following data is used for gesture scrubbing
                    if (this._isThumbGrabbed) {
                        if (args.clientX < 100) {
                            this._isHandAtLeftEdge = true;
                        } else if (args.clientX > screen.availWidth - 100) {
                            this._isHandAtRightEdge = true;
                        } else {
                            this._isHandAtLeftEdge = false;
                            this._isHandAtRightEdge = false;
                            this._currentScrubbingVelocity = 0;
                        }
                    }

                    // If the user is holding their arm out at either end of the physical interaction zone then
                    // move the seek window bars left / right depending in which direction the user is extending their arm.
                    var seekBarOffset = 0;
                    var progress = 0;
                    if (this._isSeekWindowEnabled) {
                        if (this._isHandAtLeftEdge) {

                            // We need to make sure the scrubbing directional velocity is never to the right
                            if (this._currentScrubbingVelocity > 0) {
                                return;
                            }

                            var distanceToMoveSeekableWindow = -0.005 + this._currentScrubbingVelocity / 50;

                            var newProgressPosition = this._seekWindowLeftEdge + distanceToMoveSeekableWindow;
                            if (newProgressPosition < 0) {
                                newProgressPosition = 0;
                            } else {
                                this._seekWindowRightEdge += distanceToMoveSeekableWindow;
                            }

                            this._seekWindowLeftEdge = newProgressPosition;
                            this._seekWindowSize = this._seekWindowRightEdge - this._seekWindowLeftEdge;

                            // Update the left boundary 
                            this._leftBoundary = this._seekWindowLeftEdge * this._totalSeekBarWidth;
                            this._rightBoundary = this._seekWindowRightEdge * this._totalSeekBarWidth;
                            this._seekWindowSizeInPixels = this._rightBoundary - this._leftBoundary;

                            // Move the bounds into place
                            this._seekWindowLeftEdgeElement.style.transform = "translateX(" + this._leftBoundary + "px)";
                            this._seekWindowRightEdgeElement.style.transform = "translateX(" + this._rightBoundary + "px)";

                            var leftBoundaryTime = this._seekWindowLeftEdge * this._totalTime;
                            var rightBoundaryTime = this._seekWindowRightEdge * this._totalTime;
                            this._seekWindowLeftEdgeElement.textContent = this._timeFormatter(leftBoundaryTime);
                            this._seekWindowRightEdgeElement.textContent = this._timeFormatter(rightBoundaryTime);

                            var newSeekBarOffset = newProgressPosition * this._totalSeekBarWidth;
                            seekBarOffset = newSeekBarOffset;
                            progress = newProgressPosition;

                            this._startOffsetX = this._rightBoundary;
                            this._lastPosition = this._startOffsetX;
                            this._relativeTimelineStartOffset = progress;
                        } else if (this._isHandAtRightEdge) {

                            // We need to make sure the scrubbing directional velocity is never to the left
                            if (this._currentScrubbingVelocity < 0) {
                                return;
                            }

                            var distanceToMoveSeekableWindow = 0.005 + this._currentScrubbingVelocity / 50;

                            var newProgressPosition = this._seekWindowRightEdge + distanceToMoveSeekableWindow;
                            if (newProgressPosition > 1) {
                                newProgressPosition = 1;
                            } else {
                                this._seekWindowLeftEdge += distanceToMoveSeekableWindow;
                            }
                            this._seekWindowRightEdge = newProgressPosition;
                            this._seekWindowSize = this._seekWindowRightEdge - this._seekWindowLeftEdge;

                            // Update the left boundary
                            this._leftBoundary = this._seekWindowLeftEdge * this._totalSeekBarWidth;
                            this._rightBoundary = this._seekWindowRightEdge * this._totalSeekBarWidth;
                            this._seekWindowSizeInPixels = this._rightBoundary - this._leftBoundary;

                            // Move the bounds into place
                            this._seekWindowLeftEdgeElement.style.transform = "translateX(" + this._leftBoundary + "px)";
                            this._seekWindowRightEdgeElement.style.transform = "translateX(" + this._rightBoundary + "px)";

                            var leftBoundaryTime = this._seekWindowLeftEdge * this._totalTime;
                            var rightBoundaryTime = this._seekWindowRightEdge * this._totalTime;
                            this._seekWindowLeftEdgeElement.textContent = this._timeFormatter(leftBoundaryTime);
                            this._seekWindowRightEdgeElement.textContent = this._timeFormatter(rightBoundaryTime);

                            var newSeekBarOffset = newProgressPosition * this._totalSeekBarWidth;
                            seekBarOffset = newSeekBarOffset;
                            progress = newProgressPosition;

                            this._startOffsetX = this._rightBoundary;
                            this._lastPosition = this._startOffsetX;
                            this._relativeTimelineStartOffset = progress;
                        }

                        if (this._isHandAtLeftEdge ||
                            this._isHandAtRightEdge) {

                            // Clamp the progress to the timeline
                            if (progress < 0) {
                                progress = 0;
                            } else if (progress > 1) {
                                progress = 1;
                            }

                            this._progress.style.transform = "scaleX(" + progress + ")";

                            if (this._thumbnailImage) {
                                if (this._isSeekWindowEnabled) {
                                    // Clamp the thumb indicator
                                    if (seekBarOffset < this._leftBoundary) {
                                        seekBarOffset = this._leftBoundary;
                                    } else if (seekBarOffset > this._rightBoundary) {
                                        seekBarOffset = this._rightBoundary;
                                    }
                                } else {
                                    if (seekBarOffset < 0) {
                                        seekBarOffset = 0;
                                    } else if (seekBarOffset > this._totalSeekBarWidth) {
                                        seekBarOffset = this._totalSeekBarWidth;
                                    }
                                }

                                // Don't move the timeline elements if we are at the left or right edges of the timeline.
                                var leftEdgeOfTheSeekbar = this._thumbImageElementWidthDividedByTwo;
                                var rightEdgeOfTheSeekbar = this._totalSeekBarWidth - this._thumbImageElementWidthDividedByTwo;
                                if (seekBarOffset > leftEdgeOfTheSeekbar &&
                                    seekBarOffset < rightEdgeOfTheSeekbar) {
                                    this._currentTimeVisualElements.style.transform = "translateX(" + seekBarOffset + "px)";
                                }
                            }

                            this._seekCurrentTime = progress * this._totalTime;

                            // Clamp the currentTime
                            if (this._seekCurrentTime < 0) {
                                this._seekCurrentTime = 0;
                            } else if (this._seekCurrentTime > this._totalTime) {
                                this._seekCurrentTime = this._totalTime;
                            }
                        }
                    }
                },

                _handlePointerUp: function (args) {
                    // We have to ensure the up pointer is sent to IC, so treat it as a move first.
                    this._handlePointerMove(args);
                    var pp = Windows.UI.Input.PointerPoint.getCurrentPoint(args.pointerId);
                    // Need to try... catch, because this method throws exceptions "by design"
                    try {
                        this._gestureRecognizer.processUpEvent(pp);
                    } catch (ex) { }
                },

                _handleManipulationStarted: function (args) {
                    this._inputHandlerPointerDownCallback(args);
                },

                _handleManipulationEnd: function (args) {
                    this._inputHandlerPointerUpCallback(args);
                },

                _handleManipulationUpdated: function (args) {
                    this._inputHandlerPointerMoveCallback(args);
                },

                _handleManipulationCompleted: function (args) {
                    this._inputHandlerPointerUpCallback(args);
                },

                _handleBeforeNavigated: function () {
                    this._updateMediaState(true);
                },

                _handleSeekedAfterExitFastForwardOrRewind: function (shouldPlay) {
                    if (this._disposed) {
                        return;
                    }

                    this._mediaElementAdapter.mediaElement.removeEventListener("seeked", this._handleSeekedAfterExitFastForwardOrRewindBind);
                    // Note that we need to reset the playbackRate, because it is possible due to a race condition that the FastForwardRewind timer
                    // will set the playbackRate to zero, before the timer is cleared. This will cause the play to fail and the ended
                    // event will never fire. We always want to set the rate back to the default in this case.
                    if (this._shouldPlayAfterExitingFastForwardOrRewind) {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.play) {
                            if (this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                                this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                            }
                            this._mediaElementAdapter.play();
                        }
                    } else {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.pause) {
                            if (this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                                this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                            }
                            this._mediaElementAdapter.pause();
                        }
                    }
                },

                // Helper function to call when the start time is reached via a rewind operation
                _handleStartTimeReached: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: We need to subtract an offset to ensure that we never seek past the startTime.
                        // Seeking on the media element is not 100% accurate. It will seek to the nearest frame rather
                        // than an exact timestamp. Therefore if we seek to the startTime, we may seek past the startTime.
                        var media = this._mediaElementAdapter.mediaElement;

                        // We need to make sure that we don't perform a seek if the media src was switch out from under us.
                        // Otherwise there will be an exception.
                        if (!this._isInFastForwardOrRewindMode &&
                            media.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            this._seekInternal(this._startTime + this._SEEK_OFFSET, false);
                        }

                        this._clearMediaCommandFeedbackText();

                        if (media.loop) {
                            this._playFromBeginning();
                        }
                    }
                },

                // Helper function to call when the start time is reached via a fast forward operation or through regular playback
                _handleEndTimeReached: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        !this._endTimeReached) {
                        this._exitFastForwardOrRewind(true);

                        this._endTimeReached = true;

                        // Note: We need to subtract an offset to ensure that we never seek past the endTime.
                        // Seeking on the media element is not 100% accurate. It will seek to the nearest frame rather
                        // than an exact timestamp. Therefore if we seek to the endTime, we may seek past the endTime.
                        var media = this._mediaElementAdapter.mediaElement;

                        // We need to make sure that we don't perform a seek if the media src was switch out from under us.
                        // Otherwise there will be an exception.
                        if (!this._isInFastForwardOrRewindMode &&
                            media.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA &&
                            !this._wasTimeClampedToEndTime) {
                            this._wasTimeClampedToEndTime = true;
                            this._seekInternal(this._endTime - this._SEEK_OFFSET, false);
                        }

                        if (media.loop) {
                            this._playFromBeginning();
                            this._endTimeReached = false;
                        } else {
                            if (this._wasEndTimeSetProgrammatically) {
                                this.pause();
                            }
                            this._updateMediaState(true);
                        }

                        this._clearMediaCommandFeedbackText();
                    }
                },

                // Handles global speech media-related commands
                _handleSystemTransportControlsButtonPressed: function (ev) {
                    var smtControlsButton = Windows.Media.SystemMediaTransportControlsButton;
                    switch (ev.button) {
                        case smtControlsButton.play:
                            if (this._isButtonEnabledAndVisible(this._playPauseButton)) {

                                if (this._mediaElementAdapter.mediaElement.paused) {
                                    this._showPauseButton();
                                    this.play();
                                } else {

                                    // If we are in fast forward / rewind mode, then exit to playing
                                    if (this._isInFastForwardOrRewindMode) {

                                        if (!this._isThumbnailEnabled) {
                                            this._isInFastForwardOrRewindMode = false;
                                            this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                                        }

                                        this._showPauseButton();
                                        this.play();
                                    }
                                }
                            }
                            break;
                        case smtControlsButton.pause:
                            if (this._isButtonEnabledAndVisible(this._playPauseButton)) {
                                this._showPlayButton();
                                this.pause();
                            }
                            break;
                        case smtControlsButton.stop:
                            nav.back();
                            break;
                        case smtControlsButton.fastForward:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._fastForwardButton.focus();
                                this._fastForwardButton.click();
                            }
                            break;
                        case smtControlsButton.rewind:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._rewindButton.focus();
                                this._rewindButton.click();
                            }
                            break;
                        case smtControlsButton.next:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._nextTrackButton.focus();
                                this._nextTrackButton.click();
                                this._chapterSkipForwardButton.focus();
                                this._chapterSkipForwardButton.click();
                            }
                            break;
                        case smtControlsButton.previous:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._previousTrackButton.focus();
                                this._previousTrackButton.click();
                                this._chapterSkipBackButton.focus();
                                this._chapterSkipBackButton.click();
                            }
                            break;
                        case smtControlsButton.channelUp:
                            // No-op - Windows only
                            break;
                        case smtControlsButton.channelDown:
                            // No-op - Windows only
                            break;
                        case smtControlsButton.back:
                            // No-op - This is handled by the page control
                            break;
                        case smtControlsButton.view:
                            // No-op
                        case smtControlsButton.menu:
                            // No-op
                            break;
                        default:
                            // No-op
                            break;
                    };
                },

                _handleSystemTransportControlsPropertyChanged: function (ev) {
                    var smtControlsProperty = Windows.Media.SystemMediaTransportControlsProperty;
                    var updater = this._smtControls.displayUpdater;
                    switch (ev.property) {
                        case smtControlsProperty.playbackPosition:
                            if (updater.type === Windows.Media.MediaPlaybackType.video) {
                                var numberOfMilisecondsInASecond = 1000;
                                this._seekInternal(updater.videoProperties.playbackPosition / numberOfMilisecondsInASecond, false);
                            }
                            break;
                        default:
                            break;
                    }
                },

                // Hide the controls bar, this will initiate an slide out + fadeout animation immediately.
                _hideControls: function () {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_hideControls,StartTM");

                    if (!this._isControlsVisible ||
                        (wuiv &&
                        wuiv.ApplicationView.value === wuiv.ApplicationViewState.snapped)) {
                        return;
                    }

                    var defaultNotPrevented = this._dispatchCancellableEvent("beforehidecontrols", {});

                    if (defaultNotPrevented) {
                        if (!this._isInFastForwardOrRewindMode &&
                            !this._areControlsHiding) {
                            this._areControlsHiding = true;
                            this._removeControlsTimer();

                            // Set focus off of the transport controls, otherwise if focus remains on one of
                            // the buttons, when the user presses 'A' to bring up the transport controls they
                            // may invoke one of the transport controls buttons without meaning to.
                            if (document.activeElement &&
                                this._transportControls.contains(document.activeElement)) {
                                this._element.focus();
                            }

                            if (XboxJS.UI.MediaPlayer._sounds.overlayOut) {
                                XboxJS.UI.MediaPlayer._sounds.overlayOut.play();
                            }

                            var that = this;
                            this._playHideControlsAnimation()
                                .then(function () {
                                    if (that._disposed) {
                                        return;
                                    }

                                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_hideControls,StopTM");

                                    that._isControlsVisible = false;
                                    that._areControlsHiding = false;
                                    utilities.addClass(that._controls, "win-mediaplayer-hidden");
                                    that.dispatchEvent("afterhidecontrols", {});
                                });
                        }
                    } else {
                        // If hiding the controls has been prevented, we need to remove the auto-hide controls timer
                        // otherwise the controls will hide after a period of time.
                        this._removeControlsTimer();
                    }

                    if (!this._wasStartTimeSetProgrammatically &&
                        !this._wasEndTimeSetProgrammatically &&
                        this._markers.length) {
                        this._unsubscribeFromTimeUpdates();
                    }
                },

                // Helper method to determine whether a button is enabled and visible
                // these factors determine whether a command is disabled. For instance, if
                // the fastForward button is disabled, then fastForward UI is disabled for all
                // forms of input including NUI, VUI, controller and SmartGlass.
                _isButtonEnabledAndVisible: function (button) {

                    var isButtonEnabledOrVisible = true;

                    if (button) {
                        var style = getComputedStyle(button);
                        if ((button &&
                            button.disabled) ||
                            style.display === "none") {
                            isButtonEnabledOrVisible = false;
                        }
                    } else {
                        isButtonEnabledOrVisible = false;
                    }

                    return isButtonEnabledOrVisible;
                },

                _isFastForwardOrRewind: function (playbackRate) {
                    return ((playbackRate !== this._PLAYBACKRATE_PLAYING) && (playbackRate !== this._PLAYBACKRATE_NOT_PLAYING));
                },

                // Returns true if there is a flyout that has focus
                _isFocusOnAVisibleFlyout: function () {
                    var flyouts = document.querySelectorAll(".win-overlay, .win-customoverlay");
                    for (var i = 0, len = flyouts.length; i < len; i++) {
                        var flyoutElement = flyouts[i];
                        if (flyoutElement.contains(document.activeElement)) {
                            return true;
                        }
                    }

                    return false;
                },

                // Creates a list of chapter markers. This function does not render chapter markers. To do that, call _updateChapterMarkerVisuals.
                // If the media has no chapter markers and is below a certain length (this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS), then we add
                // 11 chapter markers spaced evenly along the timeline. When the user invokes chapter skip back / chapter skip forward, the media
                // will seek to the next / previous chapter marker.
                _initializeChapterMarkers: function (mediaElement) {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_initializeChapterMarkers,StartTM");

                    var textTracks = mediaElement.textTracks;

                    // We need to check if there are any existing chapter markers that were added as text tracks
                    var hasExistingChapterMarkers = false;
                    var textTracksLength = textTracks.length;
                    for (var i = 0; i < textTracksLength; i++) {
                        var currentTextTrack = textTracks[i];
                        if (currentTextTrack.kind === "chapters") {
                            hasExistingChapterMarkers = true;
                            break;
                        }
                    }

                    // We also need to check if there were any chapter markers added by the developer
                    if (!hasExistingChapterMarkers) {
                        var markersLength = this._markers.length;
                        for (var i = 0; i < markersLength; i++) {
                            if (this._markers[i].type === markerType.chapter) {
                                hasExistingChapterMarkers = true;
                            }
                        }
                    }

                    if (hasExistingChapterMarkers) {
                        this._initializeCustomChapterMarkers(mediaElement);
                    } else if (this._totalTime > this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS) {
                        this._initializeDefaultChapterMarkers();
                    }

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_initializeChapterMarkers,StopTM");
                },

                _initializeCustomChapterMarkers: function (mediaElement) {

                    // Remove default chapter markers
                    this._defaultChapterMarkers.length = 0;
                    var textTracks = mediaElement.textTracks;

                    var tracks = mediaElement.getElementsByTagName("track");
                    var tracksLength = tracks.length;
                    for (var i = 0; i < tracksLength; i++) {
                        if (tracks[i].kind === "chapters") {

                            // Note: We need to mark the track as "HIDDEN" otherwise we will not receive cue-related events.
                            textTracks[i].mode = textTracks[i].HIDDEN;

                            var that = this;
                            this._loadTextTrackCallback = function handleLoadTextTrack() {
                                var textTrackCueList = this.track.cues;

                                var textTrackCueListLength = textTrackCueList.length;
                                for (var j = 0; j < textTrackCueListLength; j++) {
                                    that.addMarker(textTrackCueList[j].startTime, markerType.chapter, textTrackCueList[j].text);
                                }
                            };

                            tracks[i].addEventListener("load", this._loadTextTrackCallback, false);
                        }
                    }
                },

                _initializeDefaultChapterMarkers: function () {

                    // If the chapter skip back and chapter skip forward buttons are not present or display: none then do not create the default chapter markers.
                    // Note: If the buttons are disabled, we should still create the chapter markers, because the buttons may just be temporarily disabled.
                    if ((!this._chapterSkipBackButton ||
                        getComputedStyle(this._chapterSkipBackButton).display === "none") &&
                        (!this._chapterSkipForwardButton ||
                        getComputedStyle(this._chapterSkipForwardButton).display === "none")) {
                        return;
                    }

                    // Remove old default chapter markers
                    this._defaultChapterMarkers.length = 0;

                    var oneTenthOfTotalTime = this._totalTime / 10;

                    // Add the 1st default chapter marker
                    this._defaultChapterMarkers.push({ time: this._startTime, type: markerType.chapter, data: {}, extraClass: "win-mediaplayer-chaptermarker" });

                    // Add default chapter markers spaced evenly every 1/10th of the media
                    var currentMarkerPosition = 0;
                    for (var i = 0; i < 9; i++) {
                        currentMarkerPosition += oneTenthOfTotalTime;
                        this._defaultChapterMarkers.push({ time: currentMarkerPosition, type: markerType.chapter, data: {}, extraClass: "win-mediaplayer-chaptermarker" });
                    }

                    // Add the last default chapter marker
                    this._defaultChapterMarkers.push({ time: this._endTime, type: markerType.chapter, data: {}, extraClass: "win-mediaplayer-chaptermarker" });

                    this._isChapterMarkerVisualsDirty = true;
                },

                _onCanPlay: function () {

                    this._isBusy = false;

                    if (this._startTime !== 0) {
                        this._seekInternal(this._startTime, false);

                        // Note: We need to manually call play if startTime is set otherwise a video or audio 
                        // tag with 'autoplay' set to 'true' will not delay a few seconds before starting to play
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement &&
                            this._mediaElementAdapter.mediaElement.autoplay) {
                            this.play();
                        }
                    }
                },

                _onChapterSkipBackCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._chapterSkipBackButton)) {
                        this.chapterSkipBack();
                    }
                },

                _onChapterSkipForwardCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._chapterSkipForwardButton)) {
                        this.chapterSkipForward();
                    }
                },

                _onClosedCaptionsCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._closedCaptionsButton)) {
                        this._updateUIAndRaiseEvents(mediaCommandEnum.closedCaptions, strings.closedCaptionsMediaCommandDisplayText);
                    }
                },

                // Handles the back command for controller, SmartGlass, media remote and keyboard input
                // The reason we have a separate event handler for back, is because we need to intercept
                // the event before it reaches the document and navigates back. All our other key input
                // events are meant to be captured at the document level.
                _onControlsKeyupInputHandler: function (ev) {

                    if (ev.key === "GamepadB" ||
                        ev.key === "Escape") {

                        // If the controls are visible then we eat the B event so it
                        // won't bubble up to the page and cause a navigation.
                        if (wuiv &&
                            wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped &&
                            this._isControlsVisible) {
                            this._exitFastForwardOrRewind(true);
                            this._hideControls();
                            ev.stopPropagation();
                        }
                    }
                },

                // Toggles msZoom
                _onDisplayModeCommandInvoked: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._isButtonEnabledAndVisible(this._displayModeButton)) {
                        var displayModeFeebackText = "";
                        if (this._mediaElementAdapter.mediaElement.msZoom) {
                            this._mediaElementAdapter.mediaElement.msZoom = false;
                            displayModeFeebackText = "Letterbox";
                        } else {
                            this._mediaElementAdapter.mediaElement.msZoom = true;
                            displayModeFeebackText = "Native";
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.displayMode, displayModeFeebackText);
                    }
                },

                _onDurationChange: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (!isFinite(this._mediaElementAdapter.mediaElement.duration)) {
                            this._mediaElementAdapter.isLive = true;
                        }

                        if (!this._wasEndTimeSetProgrammatically) {
                            this._totalTime = this._mediaElementAdapter.mediaElement.duration - this._startTime;
                            this._updateTimelineVisuals();

                            this._updateMediaState(false);
                        }
                    }
                },

                // This function is called after the video has 
                _onEnded: function () {

                    this._exitFastForwardOrRewind(false);

                    // Reset this value to value because there is code in _handleEndTimeReached that sets checks if the
                    // end time was reached or not to prevent _handleEndTimeReached from being called again.
                    this._endTimeReached = false;

                    if (this._isThumbGrabbed) {
                        this._onThumbDragStop(null);
                    }

                    this._updateMediaState(false);
                },

                // Remove old markers and clear the time display
                _onEmptied: function () {

                    this._resetInternalState();
                    this._clearTimeDisplay();
                },

                _onFastForwardCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._fastForwardButton)) {
                        this.fastForward();
                    }
                },

                // This function is called periodically during a fast forward or rewind operation. When the MediaPlayer is fast forwarding or rewinding it is actually
                // paused and cycling thumbnails to simulate a fast forward or rewind. This function updates the targetCurrentTime property and the UI on the timeline.
                _onFastForwardRewindTimerTick: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var mediaElement = this._mediaElementAdapter.mediaElement;

                        var startTime = this._startTime;
                        var endTime = this._endTime;

                        var currentTime = mediaElement.currentTime;
                        var rawElapsedTime = new Date().getTime() - this._lastFastForwardOrRewindTimerTime;
                        var elapsedTimeInSeconds = Math.floor(rawElapsedTime / 100) / 10;

                        this._fastForwardOrRewindTimerElapsedTime += elapsedTimeInSeconds * this._targetPlaybackRate;
                        this._targetCurrentTime = this._fastForwardOrRewindTimerElapsedTime + currentTime;

                        // If we are past the endTime or startTime, then we need to exit fast forward or rewind mode
                        if (this._targetCurrentTime >= endTime) {
                            this._targetCurrentTime = endTime;
                            this._handleEndTimeReached();
                        } else if (this._targetCurrentTime <= startTime) {
                            this._targetCurrentTime = startTime;
                            this._handleStartTimeReached();
                        }

                        // Note: We don't call _updateTimelineVisuals because that would sync the seek progress bar
                        // to the location of the current time, which isn't correct during a thumbnail-based fast forward or rewind.
                        if (this._progress &&
                            this._totalTime !== 0) {
                            var newProgress = (this._targetCurrentTime - startTime) / this._totalTime;
                            var newProgressLeftOffset = newProgress * this._totalSeekBarWidth;
                            if (this._thumbnailImage) {
                                // Otherwise if we're at an edge of the timeline, we move the triangle independently of the image
                                var leftEdgeOfTheSeekbar = this._thumbImageElementWidthDividedByTwo;
                                var rightEdgeOfTheSeekbar = this._totalSeekBarWidth - this._thumbImageElementWidthDividedByTwo;
                                if (newProgressLeftOffset < leftEdgeOfTheSeekbar) {
                                    var seekMarkOffset = 1 * (newProgressLeftOffset - leftEdgeOfTheSeekbar);
                                    if (seekMarkOffset < -1 * this._thumbImageElementWidthDividedByTwo) {
                                        seekMarkOffset = -1 * this._thumbImageElementWidthDividedByTwo;
                                    }
                                    this._seekMark.style.transform = "translateX(" + seekMarkOffset + "px)";
                                    this._thumbElement.style.transform = "translate(" + (seekMarkOffset) + "px, 3px)";
                                    WinJS.Utilities.addClass(this._thumbElement, "win-mediaplayer-thumbnail-lefttriangle");
                                    this._currentTimeVisualElements.style.transform = "translateX(" + leftEdgeOfTheSeekbar + "px)";
                                } else if (newProgressLeftOffset > rightEdgeOfTheSeekbar) {
                                    var seekMarkOffset = newProgressLeftOffset - rightEdgeOfTheSeekbar;
                                    if (seekMarkOffset > this._thumbImageElementWidthDividedByTwo) {
                                        seekMarkOffset = this._thumbImageElementWidthDividedByTwo;
                                    }
                                    this._seekMark.style.transform = "translateX(" + seekMarkOffset + "px)";
                                    this._thumbElement.style.transform = "translate(" + (seekMarkOffset - 14) + "px, 6px)";
                                    WinJS.Utilities.addClass(this._thumbElement, "win-mediaplayer-thumbnail-righttriangle");
                                    this._currentTimeVisualElements.style.transform = "translateX(" + rightEdgeOfTheSeekbar + "px)";
                                } else {
                                    this._seekMark.style.transform = "none";
                                    WinJS.Utilities.removeClass(this._thumbElement, "win-mediaplayer-thumbnail-lefttriangle");
                                    WinJS.Utilities.removeClass(this._thumbElement, "win-mediaplayer-thumbnail-righttriangle");
                                    this._thumbElement.style.transform = "rotate(45deg)";
                                    this._currentTimeVisualElements.style.transform = "translateX(" + newProgressLeftOffset + "px)";
                                }
                            }
                            this._progress.style.transform = "scaleX(" + newProgress + ")";

                            this._updateTimeDisplay();

                            // Request a new thumbnail and send a time update event
                            this.dispatchEvent("targettimeupdate", {});
                            this.dispatchEvent("thumbnailrequest", { currentTime: this._targetCurrentTime, playbackRate: this._targetPlaybackRate });
                        }

                        this._lastFastForwardOrRewindTimerTime = new Date().getTime();

                        // It's possible to get into a non-paused state, if the user starts FF or RR while a seek is in progress.
                        // The seek will finish and start the video playing, but if the user is in the FF or RR state we want
                        // the media to be paused.
                        if (this._isThumbnailEnabled &&
                            mediaElement.playbackRate !== 0) {
                            this._previousPlaybackRate = mediaElement.playbackRate;
                            mediaElement.playbackRate = 0;
                        }
                    }
                },

                _onGoToFullScreenCommandInvoked: function () {
                    if (Windows.Xbox) {
                        Windows.UI.ViewManagement.ApplicationView.tryUnsnapToFullscreen();
                    } else {
                        Windows.UI.ViewManagement.ApplicationView.tryUnsnap();
                    }
                },

                _onHideControlsCommandInvoked: function () {
                    if (this._disposed) {
                        return;
                    }

                    // If the controls are ever hidden and the MediaPlayer thinks the user is grabbing the timeline then
                    // we are in an incorrect state and need to cancel the timeline grabbing gesture. This can happen
                    // if we don't receive a pointer up event when the user opens their hand.
                    if (this._isThumbGrabbed) {
                        this._onThumbDragStop(null);
                    }

                    this._hideControls();
                },

                _onInputHandlerKeyDown: function (ev) {
                    if (this._disposed) {
                        return;
                    }

                    switch (ev.keyCode) {
                        case utilities.Key.gamepadLeftShoulder:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._chapterSkipBackButton.click();
                                this._playPauseButton.focus();
                            }

                            break;
                        case utilities.Key.gamepadRightShoulder:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._chapterSkipForwardButton.click();
                                this._playPauseButton.focus();
                            }

                            break;
                        case utilities.Key.gamepadLeftTrigger:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._rewindButton.click();
                                this._playPauseButton.focus();
                            }

                            break;
                        case utilities.Key.gamepadRightTrigger:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped) {
                                if (!this._isControlsVisible) {
                                    this._showControls();
                                }
                                this._fastForwardButton.click();
                                this._playPauseButton.focus();
                            }

                            break;
                        default:
                            break;
                    }
                },

                _onInputHandlerKeyUp: function (ev) {
                    if (this._disposed) {
                        return;
                    }

                    switch (ev.keyCode) {
                        case utilities.Key.enter:
                        case utilities.Key.gamepadA:
                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped &&
                                !this._isControlsVisible &&
                                !this._isFocusOnAVisibleFlyout()) {
                                this._showControls();
                                this._playPauseButton.focus();
                            }

                            break;
                        default:
                            break;
                    }
                },

                // Handles the gesture start event on the input Handler element
                _onInputHandlerPointerDown: function (evt) {
                    // Keep track of the last pointer position allows us to see if the pointer had the same X, Y on
                    // pointer up (meaning the pointer was tapped as opposed to dragged). If the pointer was tapped
                    // then we dismiss the controls.
                    this._lastPointerPosition = evt.position.x + "," + evt.position.y;

                    // When the user presses anywhere on the video if we are FF'ing or RR'ing
                    // we should exit FF or RR mode and play.
                    this._exitFastForwardOrRewind(true);

                    if (this._isControlsVisible) {
                        this._onThumbStartDrag(evt);
                    } else {
                        this._showControls();
                    }
                },

                // Handles the pointer move event on the input Handler element
                _onInputHandlerPointerMove: function (evt) {
                    this._onThumbDrag(evt);
                },

                _onInfoButtonCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._infoButton)) {
                        this._updateUIAndRaiseEvents(mediaCommandEnum.info, strings.infoMediaCommandDisplayText);
                    }
                },

                // Handles click on to pause, a feature for advanced users
                _onInputHandlerClick: function (ev) {
                    this._onPlayPauseCommandInvoked();
                },

                // Handles the gesture end event on the input Handler element
                _onInputHandlerPointerUp: function (evt) {

                    this._inputHandlerElement.msReleasePointerCapture(evt.pointerId);

                    if (this._isThumbGrabbed) {
                        this._onThumbDragStop(evt);
                    }

                    var currentPointerPosition = evt.pageX + "," + evt.pageY;
                    var lastPointerPosition = this._lastPointerPosition;
                    if (currentPointerPosition === lastPointerPosition) {
                        this._hideControls();
                    }
                },

                // This function is called whenever a new media source is loaded. This function is the
                // right place to initialize any properties that get set/reset when new media is loaded.
                _onLoadStart: function () {
                    this._clearMediaCommandFeedbackText();
                    this._clearTimeDisplay();

                    if (!this._wasStartTimeSetProgrammatically &&
                        !this._wasEndTimeSetProgrammatically &&
                        !this._hasCustomMarkers) {
                        this._unsubscribeFromTimeUpdates();
                    }

                    // Remove any old markers
                    if (this._doMarkersNeedResetting) {
                        this._markers.length = 0;
                        this._hasCustomMarkers = false;
                        this._doMarkersNeedResetting = false;
                    }

                    this._isChapterMarkerVisualsDirty = true;

                    var that = this;
                    WinJS.Promise.timeout(this._timeBeforeShowingBusyVisual).done(function afterEnoughTimeHasPassedToShowALoadingSpinner() {
                        if (that._mediaElementAdapter &&
                            that._mediaElementAdapter.mediaElement &&
                            that._mediaElementAdapter.mediaElement.readyState < that._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            that._isBusy = true;
                        }
                    });
                },

                _onLiveButtonCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._goToLiveButton)) {
                        this.goToLive();
                    }
                },

                // This function is called when the media's metadata is loaded. This function is the right
                // place to initialize properties that need to know the duration of the media.
                _onLoadedMetadata: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (this._mediaElementAdapter.mediaElement.duration === Number.POSITIVE_INFINITY) {
                            this._mediaElementAdapter.isLive = true;
                        }

                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        this._updateDefaultStartAndEndTime(mediaElement);

                        this._initializeChapterMarkers(mediaElement);
                    }
                },

                _onMarkerCollectionChanged: function () {

                    // The marker logic depends on the markers array always being in sorted order from smallest to largest time.
                    this._markers.sort(function (first, next) {
                        return first.time - next.time;
                    });

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._recalculateNextAndPreviousCustomMarkerIndexAndTime(this._mediaElementAdapter.mediaElement.currentTime);
                    }

                    // We wait until the first custom marker is added before subscribing to time updates
                    // That way we won't be listening to time updates when we don't need to.
                    if (!this._hasCustomMarkers) {

                        this._subscribeToTimeUpdates();
                        this._hasCustomMarkers = true;
                    }

                    this._isChapterMarkerVisualsDirty = true;
                    this._updateChapterMarkerVisuals();
                },

                _onMoreCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._moreButton)) {
                        this._updateUIAndRaiseEvents(mediaCommandEnum.more, "");
                    }
                },

                _onNextTrackCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._nextTrackButton)) {
                        this.nextTrack();
                    }
                },

                _onPause: function () {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:pause,StopTM");

                    this._showPlayButton();
                },

                // Note: Instead of following the typical patter where we call a public method on the MediaPlayer,
                // we handle the logic in this function. That was done, because we didn't want to expose a public API
                // called "playFromBeginning". The reason we didn't want to expose that API was because smaller API surface
                // is better and "playFromBeginning" was easily accomplished programmatically with the existing seek and play APIs.
                _onPlayFromBeginningCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._playFromBeginningButton)) {
                        this._playFromBeginning();

                        this._updateUIAndRaiseEvents(mediaCommandEnum.playFromBeginning, strings.playFromBeginningMediaCommandDisplayText);
                    }
                },

                // Toggles the play / pause state of the media
                _onPlayPauseCommandInvoked: function () {

                    if (this._isControlsVisible &&
                        this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._isButtonEnabledAndVisible(this._playPauseButton)) {

                        if (this._mediaElementAdapter.mediaElement.paused) {
                            this._showPauseButton();
                            this.play();
                        } else {

                            // If we are in fast forward / rewind mode, then exit to playing
                            if (this._isInFastForwardOrRewindMode) {

                                if (!this._isThumbnailEnabled) {
                                    this._isInFastForwardOrRewindMode = false;
                                    this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                                }

                                this._showPauseButton();
                                this.play();
                            } else {
                                this._showPlayButton();
                                this.pause();
                            }
                        }
                    }
                },

                _onPlay: function () {

                    this._showPauseButton();
                    this._updateMediaState(false);
                },

                _onPlaying: function () {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:play,StopTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        if (this._mediaElementAdapter.mediaElement.playbackRate === this._mediaElementAdapter.mediaElement.defaultPlaybackRate) {
                            this._showPauseButton();
                        }

                        this._updateMediaState(false);
                    }
                },

                _onPreviousTrackCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._previousTrackButton)) {
                        this.previousTrack();
                    }
                },

                // Handler for media elements 'ratechange' event. This function updates the UI to react to changes in playRate.
                _onRateChange: function () {
                    // We don't want to change _isInFastForwardOrRewindMode if thumbnail mode is enabled, because the actual playbackRate
                    // is not going to correspond to the perceived playbackRate in the UI.
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        !this._isThumbnailEnabled) {
                        if (this._mediaElementAdapter.mediaElement.playbackRate === this._mediaElementAdapter.mediaElement.defaultPlaybackRate) {
                            this._isInFastForwardOrRewindMode = false;
                            this._showPauseButton();
                            this._updateInfoDisplay(strings.playMediaCommandDisplayText);
                        } else if (this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                            this._isInFastForwardOrRewindMode = false;
                            this._showPlayButton();
                            this._updateInfoDisplay(strings.pauseMediaCommandDisplayText);
                        } else {
                            this._isInFastForwardOrRewindMode = true;
                            this._showPlayButton();
                            this._setFastForwardOrRewindText();
                        }

                        this._updateMediaState(false);
                    }
                },

                _onRewindCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._rewindButton)) {
                        this.rewind();
                    }
                },

                _onSeeked: function () {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:seek,StopTM");

                    // Note: We don't call _updateMediaState, because setting _isBusy calls the function
                    // under the covers.
                    this._isBusy = false;

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        // Note: After a seek event, we need to recalculate the _nextMarkerTime, _nextMarkerIndex, _previousMarkerTime and _previousMarkerIndex
                        // because the current time will have changed.
                        this._recalculateNextAndPreviousCustomMarkerIndexAndTime(this._mediaElementAdapter.mediaElement.currentTime);

                        if (this._isControlsVisible) {
                            // After a seek, clear any transforms on the currentTime circle visual
                            if (this._isThumbnailEnabled) {
                                this._seekMark.style.transform = "none";
                            }
                            this._updateTimelineVisuals();
                        }
                    }
                },

                // This function is called before a seek operation is attempted
                _onSeeking: function () {

                    // Note: We don't call _updateMediaState, because setting _isBusy calls the function
                    // under the covers.
                    var that = this;
                    WinJS.Promise.timeout(this._timeBeforeShowingBusyVisual).done(function afterEnoughTimeHasPassedToShowALoadingSpinner() {
                        if (that._mediaElementAdapter &&
                            that._mediaElementAdapter.mediaElement &&
                            that._mediaElementAdapter.mediaElement.seeking) {
                            that._isBusy = true;
                        }
                    });

                    // If there was an outside force that caused a seek operation past the starTime or endTime (for instance, 
                    // someone called seek on the video tag directly, then we need to clamp the time to the startTime or endTime.
                    if (this._wasStartTimeSetProgrammatically ||
                        this._wasEndTimeSetProgrammatically) {

                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {
                            var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                            if (currentTime < this._startTime) {
                                this._handleStartTimeReached();
                            } else if (currentTime > this._endTime) {
                                this._handleEndTimeReached();
                            }
                        }
                    }
                },

                // This function is called to show the controls when the user invokes them with voice or gesture input
                _onShowControlsCommandInvoked: function () {
                    if (this._disposed) {
                        return;
                    }

                    if (wuiv &&
                        wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped &&
                        !this._isControlsVisible &&
                        !this._isFocusOnAVisibleFlyout()) {
                        if (XboxJS.Utilities._isGestureEngaged ||
                            XboxJS.Utilities._isVoiceEngaged) {
                            this._showControls(true, true);
                        }
                    }
                },

                // Handles the pointer move event on the input handler element when thumb bar is held down
                _onThumbDrag: function (evt) {
                    if (this._mediaElementAdapter &&
                       !this._mediaElementAdapter.isSeekAllowed) {
                        return;
                    }

                    // If the user is moving the seek window there's no work to do
                    if (this._isSeekWindowEnabled &&
                       (this._isHandAtLeftEdge ||
                        this._isHandAtRightEdge)) {
                        this._currentScrubbingVelocity = evt.velocities.linear.x;
                        return;
                    }

                    // Calculate how far the user moved since last time & remember
                    // the current X coordinate of the pointer.
                    var velocityX = evt.velocities.linear.x;
                    var velocityY = evt.velocities.linear.y;
                    // If the velocity of hand movement is much further in the Y direction than X,
                    // then we don't process the drag, because it is likely the user dropping their
                    // hand after a scrubbing gesture and we do not want that motion to result in a seek.
                    if (Math.abs(velocityX) < Math.abs(velocityY) / 2) {
                        return;
                    }
                    var newXPosition = evt.delta.translation.x + this._lastPosition;
                    this._lastPosition = newXPosition;

                    // We default the scrubbing zone to smaller than the physical interaction zone so the user 
                    // can easily scrub from one end of the video to another.
                    var seekGestureInteractionZoneWidth = document.body.offsetWidth;

                    // This value is the adjusted value of input that is a value between -1 and 1 representing how
                    // far the user has moved their hand from the starting point.
                    var inputSpaceMovement = (newXPosition - this._startOffsetX) / seekGestureInteractionZoneWidth;
                    var progress = 0;
                    var seekBarOffset = 0;
                    // Adjust the seek bar width to take the seek window into account
                    if (this._isSeekWindowEnabled) {
                        // Add the input space movement, scaled by the width of the seek window
                        progress = (inputSpaceMovement * this._seekWindowSize) + this._relativeTimelineStartOffset;
                        seekBarOffset = progress * this._totalSeekBarWidth;
                    } else {
                        progress = inputSpaceMovement + this._relativeTimelineStartOffset;
                        seekBarOffset = progress * this._totalSeekBarWidth;
                    }

                    // Clamp the progress to the timeline
                    if (progress < 0) {
                        progress = 0;
                    } else if (progress > 1) {
                        progress = 1;
                    }

                    this._progress.style.transform = "scaleX(" + progress + ")";

                    if (this._thumbnailImage) {
                        if (this._isSeekWindowEnabled) {
                            // Clamp the thumb indicator
                            if (seekBarOffset < this._leftBoundary) {
                                seekBarOffset = this._leftBoundary;
                            } else if (seekBarOffset > this._rightBoundary) {
                                seekBarOffset = this._rightBoundary;
                            }
                        } else {
                            if (seekBarOffset < 0) {
                                seekBarOffset = 0;
                            } else if (seekBarOffset > this._totalSeekBarWidth) {
                                seekBarOffset = this._totalSeekBarWidth;
                            }
                        }

                        // Otherwise if we're at an edge of the timeline, we move the triangle independently of the image
                        var leftEdgeOfTheSeekbar = 0;
                        if (this.isThumbnailEnabled) {
                            leftEdgeOfTheSeekbar = this._thumbImageElementWidthDividedByTwo;
                        } else {
                            leftEdgeOfTheSeekbar = 50; // This is 1/2 of the width of the seek time indicator visual
                        }
                        var rightEdgeOfTheSeekbar = this._totalSeekBarWidth - leftEdgeOfTheSeekbar;
                        if (seekBarOffset < leftEdgeOfTheSeekbar) {
                            var seekMarkOffset = 1 * (seekBarOffset - leftEdgeOfTheSeekbar);
                            if (seekMarkOffset < -1 * this._thumbImageElementWidthDividedByTwo) {
                                seekMarkOffset = -1 * this._thumbImageElementWidthDividedByTwo;
                            }
                            this._seekMark.style.transform = "translateX(" + seekMarkOffset + "px)";
                            this._thumbElement.style.transform = "translate(" + (seekMarkOffset) + "px, 3px)";
                            WinJS.Utilities.addClass(this._thumbElement, "win-mediaplayer-thumbnail-lefttriangle");
                            this._currentTimeVisualElements.style.transform = "translateX(" + leftEdgeOfTheSeekbar + "px)";
                        } else if (seekBarOffset > rightEdgeOfTheSeekbar) {
                            var seekMarkOffset = seekBarOffset - rightEdgeOfTheSeekbar;
                            if (seekMarkOffset > this._thumbImageElementWidthDividedByTwo) {
                                seekMarkOffset = this._thumbImageElementWidthDividedByTwo;
                            }
                            this._seekMark.style.transform = "translateX(" + seekMarkOffset + "px)";
                            this._thumbElement.style.transform = "translate(" + (seekMarkOffset - 14) + "px, 6px)";
                            WinJS.Utilities.addClass(this._thumbElement, "win-mediaplayer-thumbnail-righttriangle");
                            this._currentTimeVisualElements.style.transform = "translateX(" + rightEdgeOfTheSeekbar + "px)";
                        } else {
                            this._seekMark.style.transform = "none";
                            this._thumbElement.style.transform = "rotate(45deg)";
                            WinJS.Utilities.removeClass(this._thumbElement, "win-mediaplayer-thumbnail-righttriangle");
                            WinJS.Utilities.removeClass(this._thumbElement, "win-mediaplayer-thumbnail-lefttriangle");
                            this._currentTimeVisualElements.style.transform = "translateX(" + seekBarOffset + "px)";
                        }
                    }

                    this._seekCurrentTime = progress * this._totalTime;

                    // Clamp the currentTime
                    if (this._seekCurrentTime < 0) {
                        this._seekCurrentTime = 0;
                    } else if (this._seekCurrentTime > this._totalTime) {
                        this._seekCurrentTime = this._totalTime;
                    }

                    // Apply a slight magnetism so that is the user is scrubbing close to a marker the timeline
                    // position will snap to the marker.
                    if (this._markers.length &&
                        velocityX < this._MINIMUM_POINTER_DELTA_TO_ENABLE_SNAPPING_TO_NEAREST_MARKER &&
                        this._isButtonEnabledAndVisible(this._chapterSkipBackButton) &&
                        this._isButtonEnabledAndVisible(this._chapterSkipForwardButton)) {
                        var closeToMarkerThreshold = this._totalTime * this._SNAP_TO_NEAREST_MARKER_THRESHOLD;
                        for (var i = 0, len = this._markers.length; i < len; i++) {
                            if (Math.abs(this._markers[i].time - this._seekCurrentTime) < closeToMarkerThreshold) {

                                // Snap the currentTime to the marker
                                this._seekCurrentTime = this._markers[i].time;
                                var markerOffset = this._seekCurrentTime / this._totalTime;

                                // Snap the UI to the marker location
                                this._progress.style.transform = "scaleX(" + markerOffset + "px)";
                                this._currentTimeVisualElements.style.transform = "translateX(" + markerOffset + "px)";

                                break;
                            }
                        }
                    }

                    this.dispatchEvent("thumbnailrequest", { currentTime: this._seekCurrentTime, playbackRate: 0 });

                    if (this._thumbnailImage) {
                        this._seekTimeIndicator.textContent = this._timeFormatter(this._seekCurrentTime);
                    }
                },

                // Handles the pointer up event on the seek bar thumb
                _onThumbDragStop: function (evt) {

                    if (this._mediaElementAdapter &&
                       !this._mediaElementAdapter.isSeekAllowed) {
                        return;
                    }

                    // Show the buttons again
                    WinJS.Utilities.removeClass(this._transportControls, "win-invisible");

                    var mediaElement = this._mediaElementAdapter.mediaElement;

                    // Hide the cursor while the user is scrubbing
                    if (Windows.Xbox) {
                        Windows.Xbox.Input.InputManager.systemCursorVisibility = Windows.Xbox.Input.SystemCursorVisibility.visible;
                    }

                    if (this._isSeekWindowEnabled) {
                        WinJS.Utilities.addClass(this._seekWindowLeftEdgeElement, "win-invisible");
                        WinJS.Utilities.addClass(this._seekWindowRightEdgeElement, "win-invisible");
                    }

                    if (this._thumbnailImage) {
                        WinJS.Utilities.addClass(this._thumbElement, "win-mediaplayer-hidden");
                        WinJS.Utilities.addClass(this._thumbnailImage, "win-mediaplayer-hidden");

                        this._seekMark.style.transform = "none";
                        this._thumbElement.style.transform = "rotate(45deg)";
                    }

                    WinJS.Utilities.removeClass(this._element, "win-mediaplayer-scrubbing");

                    // We need to check if the video is loaded before seeking otherwise the video tag will throw an exception.
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                        this.seek(this._seekCurrentTime);
                    }

                    if (!this._wasPausedBeforeScrubbing &&
                        !mediaElement.ended) {
                        this._mediaElementAdapter.mediaElement.playbackRate = this._previousPlaybackRate;
                        mediaElement.play();
                    }

                    if (!XboxJS.Utilities._isGestureEngaged &&
                        !XboxJS.Utilities._isVoiceEngaged) {
                        this._setControlsTimer();
                    }

                    this._isThumbGrabbed = false;
                },

                // Handles the pointer down event on the seek bar thumb 
                _onThumbStartDrag: function (evt) {
                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.isSeekAllowed ||
                        !this._mediaElementAdapter.mediaElement) {
                        return;
                    }

                    if (this._isControlsVisible) {
                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        this._wasPausedBeforeScrubbing = mediaElement.paused;

                        // Disable the auto-hide timer on the controls while scrubbing
                        if (this._controlHideTimeout) {
                            this._removeControlsTimer();
                        }

                        // Only do this for video otherwise this will stop audio playback
                        // during scrubbing which is undesirable.
                        if (mediaElement.tagName === this._TAG_NAME_VIDEO) {
                            mediaElement.pause();
                            this._previousPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            this._mediaElementAdapter.mediaElement.playbackRate = 0;
                        }

                        // This is the initial position of the cursor before the user has started
                        // a scrub operation. This value will be mapped to the current timeline position.
                        this._startOffsetX = evt.position.x;
                        this._lastPosition = this._startOffsetX;

                        // If the media is beyond a certain length, we enable a special UI feature
                        // that restricts the seek region to a portion of the timeline so the user can
                        // use the entire physical interaction zone to seek within a subset of the timeline.
                        // This allows the user to seek much more accurately for long content.
                        if (this._totalTime > this._MINIMUM_ACCURATE_SEEKABLE_RANGE) {
                            this._isSeekWindowEnabled = true;
                        } else {
                            this._isSeekWindowEnabled = false;
                        }

                        // Hide the control so -ms-attraction doesn't cause the cursor to jump up & down
                        WinJS.Utilities.addClass(this._transportControls, "win-invisible");

                        // Need to also calculate the offset of the timeline
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        this._relativeTimelineStartOffset = currentTime / this._totalTime;
                        var progress = this._relativeTimelineStartOffset * this._totalSeekBarWidth;

                        if (this._isSeekWindowEnabled) {
                            this._minimumSeekableRange = this._MINIMUM_ACCURATE_SEEKABLE_RANGE / this._totalTime;

                            // Figure out where to put the seek window based on where the hand is
                            var relativePositionOfLeftBoundary = evt.position.x / screen.availWidth;
                            var relativePositionOfRightBoundary = 1 - relativePositionOfLeftBoundary;

                            // Map this to real space
                            this._seekWindowLeftEdge = this._relativeTimelineStartOffset - relativePositionOfLeftBoundary * this._minimumSeekableRange;
                            this._seekWindowRightEdge = this._relativeTimelineStartOffset + relativePositionOfRightBoundary * this._minimumSeekableRange;

                            // Clamp the bounds
                            if (this._seekWindowLeftEdge < 0) {
                                this._seekWindowLeftEdge = 0;
                            } else if (this._seekWindowRightEdge > 1) {
                                this._seekWindowRightEdge = 1;
                            }
                            this._seekWindowSize = this._seekWindowRightEdge - this._seekWindowLeftEdge;

                            // Update the left boundary
                            this._leftBoundary = this._seekWindowLeftEdge * this._totalSeekBarWidth;
                            this._rightBoundary = this._seekWindowRightEdge * this._totalSeekBarWidth;

                            this._seekWindowSizeInPixels = this._rightBoundary - this._leftBoundary;

                            // Move the bounds into place
                            this._seekWindowLeftEdgeElement.style.transform = "translateX(" + this._leftBoundary + "px)";
                            this._seekWindowRightEdgeElement.style.transform = "translateX(" + this._rightBoundary + "px)";

                            var leftBoundaryTime = this._seekWindowLeftEdge * this._totalTime;
                            var rightBoundaryTime = this._seekWindowRightEdge * this._totalTime;
                            this._seekWindowLeftEdgeElement.textContent = this._timeFormatter(leftBoundaryTime);
                            this._seekWindowRightEdgeElement.textContent = this._timeFormatter(rightBoundaryTime);

                            WinJS.Utilities.removeClass(this._seekWindowLeftEdgeElement, "win-invisible");
                            WinJS.Utilities.removeClass(this._seekWindowRightEdgeElement, "win-invisible");
                        }

                        this._isThumbGrabbed = true;

                        // Hide the cursor while the user is scrubbing
                        if (Windows.Xbox) {
                            Windows.Xbox.Input.InputManager.systemCursorVisibility = Windows.Xbox.Input.SystemCursorVisibility.hidden;
                        }

                        // Show the thumbnails if thumbnail mode is enabled
                        if (this._thumbnailImage) {
                            WinJS.Utilities.removeClass(this._thumbElement, "win-mediaplayer-hidden");
                            WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-hidden");

                            // We need this value for scrubbing to make sure the thumbnail image doesn't go past the timeline.
                            if (!this._thumbImageElementWidthDividedByTwo) {
                                this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                            }
                        }

                        WinJS.Utilities.addClass(this._element, "win-mediaplayer-scrubbing");
                    }
                },

                _onTimeSkipForwardCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._timeSkipForwardButton)) {
                        this.timeSkipForward();
                    }
                },

                _onTimeSkipBackCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._timeSkipBackButton)) {
                        this.timeSkipBack();
                    }
                },

                // This function is called approximately every 200 milliseconds.
                // This function should only be called if (1) the timeline controls are visible or (2) there are custom markers
                _onTimeUpdate: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        // If current time has passed the start or end time, then we clamp the current time to the start or end time.
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        if (this._mediaElementAdapter.mediaElement.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            if (currentTime < this._startTime) {
                                this._handleStartTimeReached();
                            } else if (currentTime > this._endTime) {
                                this._handleEndTimeReached();
                            }
                        }

                        // Check Fire marker event if there is one
                        if (this._nextCustomMarkerTime !== -1 &&
                            !this._isInFastForwardOrRewindMode &&
                            Math.abs(this._nextCustomMarkerTime - currentTime) < this._MARKER_PROXIMITY_THRESHOLD) {

                            // We need to check that there is still a valid marker to fire an event on, otherwise we
                            // could run into a race condition where the markers was removed in between us capturing
                            // the currentTime and firing the event.
                            if (this._markers[this._nextCustomMarkerIndex]) {
                                this.dispatchEvent("markerreached", this._markers[this._nextCustomMarkerIndex]);
                            }

                            // It's possible that there are more markers in close proximity to the current marker
                            // we need to fire those markers as well, otherwise they will get skipped over by the
                            // next 'timeupdate', since 'timeupdate' fires only about every 200 milliseconds.
                            var currentMarkerTime = this._nextCustomMarkerTime;
                            var markersLength = this._markers.length;
                            var indexOfLastMarkerFired = this._nextCustomMarkerIndex;
                            for (var i = indexOfLastMarkerFired + 1; i < markersLength; i++) {
                                if ((this._markers[i].time - currentTime) < this._MARKER_PROXIMITY_THRESHOLD) {

                                    // We do not need to check to see if the marker is valid before firing the event like
                                    // we did above, because we already check the validity of the markers in the for loop
                                    // with this statement "this._markers[i].time".
                                    this.dispatchEvent("markerreached", this._markers[i]);
                                    indexOfLastMarkerFired = i;
                                } else {
                                    break;
                                }
                            }

                            // Reset the next/previous marker state variables
                            if (indexOfLastMarkerFired + 1 < this._markers.length &&
                                this._markers[indexOfLastMarkerFired + 1]) {
                                this._nextCustomMarkerIndex = indexOfLastMarkerFired + 1;
                                this._nextCustomMarkerTime = this._markers[this._nextCustomMarkerIndex].time;
                            } else {
                                this._nextCustomMarkerIndex = -1;
                                this._nextCustomMarkerTime = -1;
                            }

                            if (indexOfLastMarkerFired >= 0 &&
                                this._markers.length &&
                                this._markers[indexOfLastMarkerFired]) {
                                this._previousCustomMarkerIndex = indexOfLastMarkerFired;
                                this._previousCustomMarkerTime = this._markers[this._previousCustomMarkerIndex].time;
                            } else {
                                this._previousCustomMarkerIndex = -1;
                                this._previousCustomMarkerTime = -1;
                            }

                        }

                        if (this._mediaElementAdapter &&
                            this._isControlsVisible) {

                            // Update the time display for non-live streams
                            if (!this._mediaElementAdapter.isLive) {
                                this._syncTimeAndProgress(false);
                                this._updateTimeDisplay();
                            }
                        }
                    }
                },

                _onStopCommandInvoked: function () {
                    if (this._isButtonEnabledAndVisible(this._stopButton)) {
                        this.stop();
                    }
                },

                _playFromBeginning: function () {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_playFromBeginning,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        if (mediaElement.ended) {
                            mediaElement.load();
                        }

                        if (mediaElement.currentTime !== this._startTime &&
                            mediaElement.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            this._seekInternal(this._startTime, false);
                            mediaElement.playbackRate = mediaElement.defaultPlaybackRate;
                            mediaElement.play();

                            this._endTimeReached = false;
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.playFromBeginning, strings.replayMediaCommandDisplayText);
                    }
                },

                // Recalculate the index of the next custom marker based on the current time
                _recalculateNextAndPreviousCustomMarkerIndexAndTime: function (currentTime) {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_recalculateNextAndPreviousCustomMarkerIndexAndTime,StartTM");

                    var markersLength = this._markers.length;
                    var previousCustomMarkerIndexAndTimeSet = false;
                    var nextCustomMarkerIndexAndTimeSet = false;
                    for (var i = 0; i < markersLength; i++) {

                        if (previousCustomMarkerIndexAndTimeSet &&
                            nextCustomMarkerIndexAndTimeSet) {
                            return;
                        }

                        if (!nextCustomMarkerIndexAndTimeSet &&
                            this._markers[i].time >= currentTime) {
                            this._nextCustomMarkerIndex = i;
                            this._nextCustomMarkerTime = this._markers[i].time;

                            nextCustomMarkerIndexAndTimeSet = true;
                        }
                        if (!previousCustomMarkerIndexAndTimeSet &&
                            this._markers[i].time <= currentTime) {
                            this._previousCustomMarkerIndex = i;
                            this._previousCustomMarkerTime = this._markers[i].time;

                            previousCustomMarkerIndexAndTimeSet = true;
                        }
                    }

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_recalculateNextAndPreviousCustomMarkerIndexAndTime,StopTM");
                },

                _removeButtonEventHandlers: function () {

                    if (this._buttonEventSubscriptions) {
                        for (var i = 0; i < this._buttonEventSubscriptions.length; i++) {
                            var button = this._buttonEventSubscriptions[i].button;
                            var eventName = this._buttonEventSubscriptions[i].eventName;
                            var handler = this._buttonEventSubscriptions[i].handler;
                            button.removeEventListener(eventName, handler);
                        }

                        this._buttonEventSubscriptions = [];
                    }
                },

                // Remove the auto hide timer for hiding controls
                _removeControlsTimer: function () {

                    if (this._controlHideTimeout) {
                        clearTimeout(this._controlHideTimeout);
                        this._controlHideTimeout = null;
                    }
                },

                _removeGestureEventHandlers: function () {

                    if (this._gestureEventSubscriptions) {
                        for (var i = 0; i < this._gestureEventSubscriptions.length; i++) {
                            var owner = this._gestureEventSubscriptions[i].owner;
                            var eventName = this._gestureEventSubscriptions[i].eventName;
                            var handler = this._gestureEventSubscriptions[i].handler;
                            owner.removeEventListener(eventName, handler);
                        }

                        this._gestureEventSubscriptions = [];
                    }
                },

                // Reset the auto hide timer of the controls if available
                _resetAutoHideControlsTimer: function () {

                    if (this._controlHideTimeout) {
                        var that = this;

                        clearTimeout(this._controlHideTimeout);

                        this._controlHideTimeout = setTimeout(function () {
                            that._hideControls();
                        }, this._CONTROLS_AUTO_HIDE_DURATION);
                    }
                },

                // Resets both the controls timer and the seekbar timer if available
                _resetAutoHideTimers: function () {

                    this._resetAutoHideControlsTimer();
                },

                // This function should be called whenever the media source changes
                _resetInternalState: function () {

                    this._isBusy = false;
                    this._isChapterMarkerVisualsDirty = false;
                    this._doesEndTimeNeedResetting = true;
                    this._doesStartTimeNeedResetting = true;
                    this._doMarkersNeedResetting = true;
                    this._defaultChapterMarkers = [];
                    this._endTime = 0;
                    this._endTimeReached = false;
                    this._FAST_FORWARD_OR_REWIND_TIMER_INTERVAL = 250;
                    this._handleTransportBarButtonFocus = null;
                    this._hasCustomMarkers = false;
                    this._lastFastForwardOrRewindTimerTime = 0;
                    this._fastForwardOrRewindTimerElapsedTime = 0;
                    this._isInFastForwardOrRewindMode = false;
                    this._nextCustomMarkerIndex = -1;
                    this._nextCustomMarkerTime = -1;
                    this._previousCustomMarkerIndex = -1;
                    this._previousCustomMarkerTime = -1;
                    this._startTime = 0;
                    this._targetPlaybackRate = 0;
                    this._targetCurrentTime = 0;
                    this._totalTimeInternal = 0;
                    this._wasStartTimeSetProgrammatically = false;
                    this._wasEndTimeSetProgrammatically = false;
                    this._wasTimeClampedToEndTime = false;

                    // Reset the progress bar
                    this._progress.style.transform = "scaleX(0)";
                },

                _seekInternal: function (newTime, wasCalledProgrammatically) {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.seek &&
                        this._mediaElementAdapter.isSeekAllowed) {

                        this._exitFastForwardOrRewind(true);

                        if (newTime < this._startTime) {
                            newTime = this._startTime;
                        } else if (newTime > this._endTime) {
                            newTime = this._endTime;
                        }

                        if (this._mediaElementAdapter.isLive) {
                            if (newTime > this._liveTime) {
                                newTime = this._liveTime;
                            } else if (newTime > this._endTime) {
                                newTime = this._endTime;
                            }
                        }

                        // Checking if the seek time is a valid number saves us from possible crashes. Also, if it was a user initiated
                        // seek, then we check to make sure the MediaElement is in a valid state & can seek without throwing an exception.
                        // Note: we don't perform this check if the developer calls seek programmatically, because hiding the exception and
                        // failing silently would create hard to track down bugs for the developer.
                        if (!isNaN(newTime) &&
                           (wasCalledProgrammatically ||
                           (!wasCalledProgrammatically && this._mediaElementAdapter.mediaElement.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA))) {
                            this._mediaElementAdapter.seek(newTime);
                        }

                        if (wasCalledProgrammatically) {
                            this._updateUIAndRaiseEvents(mediaCommandEnum.seek, null);
                        }
                    }
                },

                // Start an auto hide timer for hiding controls
                _setControlsTimer: function () {

                    var that = this;
                    this._controlHideTimeout = setTimeout(function () {
                        that._hideControls();
                    }, this._controlsAddedHideDuration || this._CONTROLS_AUTO_HIDE_DURATION);
                    this._lastControlsResetTimeStamp = Date.now();
                },

                _setFastForwardOrRewindText: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        var currentPlaybackRate = this._PLAYBACKRATE_NOT_PLAYING;

                        if (this._isThumbnailEnabled) {
                            currentPlaybackRate = this._targetPlaybackRate;
                        } else {
                            currentPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        }

                        var playbackSpeedText = "";
                        var mediaCommand = "";
                        if (currentPlaybackRate >= this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            var fastForwardAmount = Math.floor(currentPlaybackRate / this._mediaElementAdapter.mediaElement.defaultPlaybackRate);
                            mediaCommand = mediaCommandEnum.fastForward;
                            playbackSpeedText = WinJS.Resources._formatString(strings.fastForwardFeedbackDisplayText, fastForwardAmount);
                        } else if (currentPlaybackRate <= this._PLAYBACKRATE_REWIND_2X) {
                            var rewindAmount = Math.floor(currentPlaybackRate / (-1 * this._mediaElementAdapter.mediaElement.defaultPlaybackRate));
                            mediaCommand = mediaCommandEnum.rewind;
                            playbackSpeedText = WinJS.Resources._formatString(strings.rewindFeedbackDisplayText, rewindAmount);
                        } else if (currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE) {
                            mediaCommand = mediaCommandEnum.fastForward;
                            playbackSpeedText = strings.fastForwardFeedbackSlowMotionDisplayText;
                        } else if (currentPlaybackRate === this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE) {
                            mediaCommand = mediaCommandEnum.rewind;
                            playbackSpeedText = strings.rewindFeedbackSlowMotionDisplayText;
                        } else {
                            mediaCommand = mediaCommandEnum.play;
                            playbackSpeedText = strings.playMediaCommandDisplayText;
                        }

                        this._playbackSpeedIndicator.textContent = playbackSpeedText;
                        this.dispatchEvent("mediacommandexecuted", { mediaCommand: mediaCommand });
                        this._updateMediaState(false);
                    }
                },

                _setupNewMediaElement: function (newMediaElement, oldMediaElement) {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_setupNewMediaElement,StartTM");

                    var that = this;

                    // If there's an old mediaElement, we need to remove event listeners and CSS classes from it
                    if (oldMediaElement) {
                        this._resetInternalState();
                        this._unsubscribeFromMediaEvents(oldMediaElement);
                        utilities.removeClass(oldMediaElement, "win-mediaplayer-video");
                    }

                    // Add the new mediaElement to the tree
                    var mediaPlaybackContent = this._element.querySelector(".win-mediaplayer");
                    if (newMediaElement &&
                        this._element) {

                        // Make sure it's not showing controls
                        newMediaElement.controls = false;
                        utilities.addClass(newMediaElement, "win-mediaplayer-video");

                        // The following adds the appropriate classes based on whether 
                        // we're full screen or not
                        if (this._isFullScreen) {
                            this.isFullScreen = true;
                        } else {
                            this.isFullScreen = false;
                        }

                        // If the video is in "full screen" mode, then we insert the video tag as the first child of the body
                        // so that we can use Trident's optimal video rendering path.
                        var elementToInsertMediaElementBefore = null;
                        if (this._isFullScreen) {
                            elementToInsertMediaElementBefore = this._element.querySelector(".win-mediaplayer");
                        } else {
                            elementToInsertMediaElementBefore = this._element.querySelector(".win-mediaplayer-controls");
                        }
                        if (elementToInsertMediaElementBefore &&
                            elementToInsertMediaElementBefore.parentNode) {
                            elementToInsertMediaElementBefore.parentNode.insertBefore(newMediaElement, elementToInsertMediaElementBefore);
                        }

                        if (newMediaElement) {

                            // Update visuals based on mediaPlayer.layout
                            if (newMediaElement.tagName === this._TAG_NAME_AUDIO) {
                                if (this._layout === layout.partial) {
                                    utilities.removeClass(this._controls, "win-mediaplayer-audio-full");
                                    utilities.addClass(this._controls, "win-mediaplayer-audio-partial");
                                } else if (this._layout === layout.full) {
                                    utilities.removeClass(this._controls, "win-mediaplayer-audio-partial");
                                    utilities.addClass(this._controls, "win-mediaplayer-audio-full");
                                }
                                if (this._smtControls) {
                                    this._smtControls.displayUpdater.type = Windows.Media.MediaPlaybackType.audio;
                                }
                            } else {
                                if (this._layout === layout.partial) {
                                    utilities.removeClass(this._controls, "win-mediaplayer-video-full");
                                    utilities.addClass(this._controls, "win-mediaplayer-video-partial");
                                } else if (this._layout === layout.full) {
                                    utilities.removeClass(this._controls, "win-mediaplayer-video-partial");
                                    utilities.addClass(this._controls, "win-mediaplayer-video-full");
                                }
                                if (this._smtControls) {
                                    this._smtControls.displayUpdater.type = Windows.Media.MediaPlaybackType.video;
                                }
                            }

                            if (this._isControlsVisible) {
                                this._subscribeToTimeUpdates();
                            }

                            // Update timeline
                            var startTime = this._startTime;
                            var endTime = this._endTime;
                            var currentTime = newMediaElement.currentTime - startTime;

                            this._updateTimelineVisuals();
                        }
                    }

                    // Set initial button state
                    if (newMediaElement) {
                        if (newMediaElement.paused) {
                            this._showPlayButton();
                        } else {
                            this._showPauseButton();
                        }
                    }

                    // If the video has already loaded it's metadata, then we need to set the startTime, endTime, and clear markers
                    if (newMediaElement &&
                        newMediaElement.readyState >= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {

                        if (oldMediaElement) {
                            this._doesEndTimeNeedResetting = false;
                            this._doesStartTimeNeedResetting = false;
                            this._doMarkersNeedResetting = false;
                        }

                        this._updateDefaultStartAndEndTime(newMediaElement);

                        if (!this._wasEndTimeSetProgrammatically) {
                            this._totalTime = newMediaElement.duration - this._startTime;
                            this._updateTimelineVisuals();
                        }

                        // We need to clear any existing markers, so that _initializeChapterMarkers does
                        // not think that the developer already specified chapter markers when they did not.
                        this._markers.length = 0;
                        this._initializeChapterMarkers(newMediaElement);
                    } else {
                        if (oldMediaElement) {
                            this._doesEndTimeNeedResetting = true;
                            this._doesStartTimeNeedResetting = true;
                            this._doMarkersNeedResetting = true;
                        }
                    }

                    // We do not need to check if the newMediaElement is null, because one of the sub-functions
                    // in this._subscribeToMediaEvents will do that check.
                    this._subscribeToMediaEvents(newMediaElement);

                    if (this._smtControls) {
                        this._smtControls.isNextEnabled = this._isButtonEnabledAndVisible(this._chapterSkipForwardButton) || this._isButtonEnabledAndVisible(this._nextTrackButton);
                        this._smtControls.isPreviousEnabled = this._isButtonEnabledAndVisible(this._chapterSkipBackButton) || this._isButtonEnabledAndVisible(this._previousTrackButton);
                    }

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_setupNewMediaElement,StopTM");
                },

                // Show the controls bar, controls bar will slide/fade in, but will auto hide automatically.
                _showControls: function (force, doNotAutoHide) {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_showControls,StartTM");

                    if (this._isControlsVisible &&
                        wuiv &&
                        wuiv.ApplicationView.value === wuiv.ApplicationViewState.snapped &&
                        !force ||
                        this._disposed) {
                        return;
                    }

                    if (!this._totalSeekBarWidth) {
                        this._totalSeekBarWidth = this._seekBar.clientWidth;
                        this._thumbElementWidthDividedByTwo = this._thumbElement.clientWidth / 2;
                        this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                    }

                    // Only show the controls if we actually playing back something
                    if ((this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.currentSrc) ||
                        force) {

                        var defaultNotPrevented = this._dispatchCancellableEvent("beforeshowcontrols", {});

                        if (defaultNotPrevented) {

                            if (XboxJS.UI.MediaPlayer._sounds.overlayIn) {
                                XboxJS.UI.MediaPlayer._sounds.overlayIn.play();
                            }

                            utilities.removeClass(this._controls, "win-mediaplayer-hidden");
                            this._isControlsVisible = true;
                            this._updateChapterMarkerVisuals();

                            if (this._controlHideTimeout) {
                                this._removeControlsTimer();
                            }

                            this._transportControls.style.opacity = 1;
                            var that = this;
                            this._playShowControlsAnimation()
                                .then(function () {
                                    if (that._disposed) {
                                        return;
                                    }

                                    // We need to refresh the voice bling, because we may be in active listening
                                    // but if the controls are hidden, they will not have been picked up by the voice algorithm
                                    XboxJS.UI.Voice.refreshVoiceElements();

                                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_showControls,StopTM");
                                    that.dispatchEvent("aftershowcontrols", {});
                                });

                            if (wuiv &&
                                wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped &&
                                !this._isInFastForwardOrRewindMode &&
                                !doNotAutoHide) {
                                this._setControlsTimer();
                            }

                            // Subscribe to media position change events again
                            this._subscribeToTimeUpdates();

                            this._updateTimelineVisuals();
                        }
                    }
                },

                _playShowControlsAnimation: function () {

                    // Grab all the buttons
                    var allTransportBarButtons = this._transportControls.querySelectorAll("BUTTON");
                    var visibleTransportBarButtons = [];
                    for (var i = 0, len = allTransportBarButtons.length; i < len; i++) {
                        var currentStyle = allTransportBarButtons[i].currentStyle;
                        if (currentStyle.display !== "none") {
                            visibleTransportBarButtons.push(allTransportBarButtons[i]);
                        }
                    }

                    // Create an offsetArray
                    var offsets = [];
                    var numberOfTransportBarButtons = visibleTransportBarButtons.length;

                    // Left buttons
                    var leftButtons = [];
                    var leftButtonOffsets = [];

                    // Right buttons
                    var rightButtons = [];
                    var rightButtonOffsets = [];

                    for (var i = 0, len = Math.floor(numberOfTransportBarButtons / 2) ; i < len; i++) {
                        leftButtons.push(visibleTransportBarButtons[i]);
                    }
                    // Now fill in the offset array
                    var leftOffset = -64;
                    for (var i = leftButtons.length; i > 0; i--) {
                        leftButtonOffsets.push({ left: leftOffset + "px", top: "0px" });
                        leftOffset -= 64;
                    }

                    for (var i = Math.ceil(numberOfTransportBarButtons / 2), len = numberOfTransportBarButtons; i < len; i++) {
                        rightButtons.push(visibleTransportBarButtons[i]);
                    }
                    // Fill in the offset array
                    var rightOffset = 64;
                    for (var i = rightButtons.length; i > 0; i--) {
                        rightButtonOffsets.push({ left: rightOffset + "px", top: "0px" });
                        rightOffset += 64;
                    }

                    var animationPromises = [];
                    var leftElementsOffsetArray = new OffsetArray(leftButtonOffsets, "WinJS-showLeftTransportBarButtons", [{ top: "0px", left: "-64px", rtlflip: true }]);
                    var rightElementsOffsetArray = new OffsetArray(rightButtonOffsets, "WinJS-showRightTransportBarButtons", [{ top: "0px", left: "64px", rtlflip: true }]);
                    // Do an animation on them
                    animationPromises.push(WinJS.UI.executeAnimation(leftButtons, [{
                        property: "transform",
                        delay: 0,
                        duration: 666,
                        timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                        from: translateCallback(leftElementsOffsetArray),
                        to: "none"
                    }]));

                    animationPromises.push(WinJS.UI.executeAnimation(rightButtons, [{
                        property: "transform",
                        delay: 0,
                        duration: 666,
                        timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                        from: translateCallback(rightElementsOffsetArray),
                        to: "none"
                    }]));

                    // Animate the timeline
                    animationPromises.push(WinJS.UI.executeAnimation(this._progressContainer, [{
                        property: "transform",
                        delay: 0,
                        duration: 666,
                        timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                        from: "scaleX(0)",
                        to: "none"
                    }]));

                    animationPromises.push(WinJS.UI.executeTransition(this._controls, [{
                        property: "opacity",
                        delay: 0,
                        duration: 222,
                        timing: "linear",
                        from: 0,
                        to: 1
                    }]));

                    return WinJS.Promise.join(animationPromises);
                },

                _playHideControlsAnimation: function () {

                    // Grab all the buttons
                    var allTransportBarButtons = this._transportControls.querySelectorAll("BUTTON");
                    var visibleTransportBarButtons = [];
                    for (var i = 0, len = allTransportBarButtons.length; i < len; i++) {
                        var currentStyle = allTransportBarButtons[i].currentStyle;
                        if (currentStyle.display !== "none") {
                            visibleTransportBarButtons.push(allTransportBarButtons[i]);
                        }
                    }

                    // Create an offsetArray
                    var offsets = [];
                    var numberOfTransportBarButtons = visibleTransportBarButtons.length;

                    // Left buttons
                    var leftButtons = [];
                    var leftButtonOffsets = [];

                    // Right buttons
                    var rightButtons = [];
                    var rightButtonOffsets = [];

                    for (var i = 0, len = Math.floor(numberOfTransportBarButtons / 2) ; i < len; i++) {
                        leftButtons.push(visibleTransportBarButtons[i]);
                    }
                    // Now fill in the offset array
                    var leftOffset = -64;
                    for (var i = leftButtons.length; i > 0; i--) {
                        leftButtonOffsets.push({ left: leftOffset + "px", top: "0px" });
                        leftOffset -= 64;
                    }

                    for (var i = Math.ceil(numberOfTransportBarButtons / 2), len = numberOfTransportBarButtons; i < len; i++) {
                        rightButtons.push(visibleTransportBarButtons[i]);
                    }
                    // Fill in the offset array
                    var rightOffset = 64;
                    for (var i = rightButtons.length; i > 0; i--) {
                        rightButtonOffsets.push({ left: rightOffset + "px", top: "0px" });
                        rightOffset += 64;
                    }

                    var animationPromises = [];
                    var leftElementsOffsetArray = new OffsetArray(leftButtonOffsets, "WinJS-showLeftTransportBarButtons", [{ top: "0px", left: "-64px", rtlflip: true }]);
                    var rightElementsOffsetArray = new OffsetArray(rightButtonOffsets, "WinJS-showRightTransportBarButtons", [{ top: "0px", left: "64px", rtlflip: true }]);
                    // Do an animation on them
                    animationPromises.push(WinJS.UI.executeAnimation(leftButtons, [{
                        property: "transform",
                        delay: 0,
                        duration: 666,
                        timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                        from: "none",
                        to: translateCallback(leftElementsOffsetArray)
                    }]));

                    animationPromises.push(WinJS.UI.executeAnimation(rightButtons, [{
                        property: "transform",
                        delay: 0,
                        duration: 666,
                        timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                        from: "none",
                        to: translateCallback(rightElementsOffsetArray)
                    }]));

                    // Animate the timeline
                    animationPromises.push(WinJS.UI.executeAnimation(this._progressContainer, [{
                        property: "transform",
                        delay: 0,
                        duration: 666,
                        timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                        from: "none",
                        to: "scaleX(0)"
                    }]));

                    animationPromises.push(WinJS.UI.executeTransition(this._controls, [{
                        property: "opacity",
                        delay: 0,
                        duration: 222,
                        timing: "linear",
                        from: 1,
                        to: 0
                    }]));

                    return WinJS.Promise.join(animationPromises);
                },

                _startFastForwardOrRewind: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.pause &&
                        this._mediaElementAdapter.mediaElement) {

                        // Set the playbackRate to zero & pause the video
                        this._previousPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        this._mediaElementAdapter.mediaElement.playbackRate = 0;
                        this._mediaElementAdapter.pause();

                        // Start the fastForwardAndRewind timer
                        this._fastForwardOrRewindTimerElapsedTime = 0;
                        this._lastFastForwardOrRewindTimerTime = new Date().getTime();

                        var that = this;
                        this._onFastForwardRewindTimerTick();
                        this._fastForwardOrRewindTimer = setInterval(function () { that._onFastForwardRewindTimerTick(); }, this._FAST_FORWARD_OR_REWIND_TIMER_INTERVAL);

                        // Show the thumbnails if thumbnail mode is enabled
                        if (this._thumbnailImage) {
                            WinJS.Utilities.removeClass(this._thumbElement, "win-mediaplayer-hidden");
                            WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-hidden");

                            if (this._targetPlaybackRate === 0 ||
                                this._targetPlaybackRate === 1) {
                                WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-scrubbing");
                                WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-rewind");
                                WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-fastforward");
                            } else if (this._targetPlaybackRate > 0) {
                                WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-scrubbing");
                                WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-rewind");
                                WinJS.Utilities.addClass(this._thumbnailImage, "win-mediaplayer-fastforward");
                            } else if (this._targetPlaybackRate < 0) {
                                WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-scrubbing");
                                WinJS.Utilities.removeClass(this._thumbnailImage, "win-mediaplayer-fastforward");
                                WinJS.Utilities.addClass(this._thumbnailImage, "win-mediaplayer-rewind");
                            }

                            // We need this value for scrubbing to make sure the thumbnail image doesn't go past the timeline.
                            if (!this._thumbImageElementWidthDividedByTwo) {
                                this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                            }
                        }

                        this._isInFastForwardOrRewindMode = true;

                        // If we are starting a new FF or RR operation we need to set this variable to false, otherwise
                        // the user will be unable to FF all the way to the end.
                        this._wasTimeClampedToEndTime = false;

                        // Update voice strings for Fast Forward and Rewind
                        if (this._targetPlaybackRate >= 2) {
                            if (this._fastForwardButton) {
                                this._fastForwardButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FASTER_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FASTER_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FASTER_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                            }
                            if (this._rewindButton) {
                                this._rewindButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/SLOWER_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/SLOWER_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/SLOWER_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                            }
                        } else if (this._targetPlaybackRate <= -2) {
                            if (this._fastForwardButton) {
                                this._fastForwardButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/SLOWER_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/SLOWER_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/SLOWER_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                            }
                            if (this._rewindButton) {
                                this._rewindButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FASTER_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FASTER_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FASTER_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                            }
                        }
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }
                },

                // Turns the playpause toggle button into a pause button
                _showPauseButton: function () {
                    utilities.removeClass(this._playPauseToggleVisual, "win-mediaplayer-playicon");
                    utilities.addClass(this._playPauseToggleVisual, "win-mediaplayer-pauseicon");
                    if (this._smtControls) {
                        this._smtControls.isPauseEnabled = true;
                        this._smtControls.isPlayEnabled = false;
                    }
                    this._playPauseButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PAUSE_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PAUSE_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PAUSE_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                    XboxJS.UI.Voice.refreshVoiceElements();
                },

                // Turns the playpause toggle button into a play button
                _showPlayButton: function () {
                    utilities.removeClass(this._playPauseToggleVisual, "win-mediaplayer-pauseicon");
                    utilities.addClass(this._playPauseToggleVisual, "win-mediaplayer-playicon");
                    if (this._smtControls) {
                        this._smtControls.isPauseEnabled = false;
                        this._smtControls.isPlayEnabled = true;
                    }
                    this._playPauseButton.setAttribute("data-win-voice", "{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PLAY_MEDIA_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PLAY_MEDIA_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/PLAY_MEDIA_COMMAND_VUI_PRON') + "', targetElement: select('.win-voice-activetext') }");
                    XboxJS.UI.Voice.refreshVoiceElements();
                },

                // Subscribes to the 'timeupdate' event
                _subscribeToTimeUpdates: function () {

                    // Make sure there is only one 'timeupdate' event ever, so we remove it first every time
                    var that = this;
                    this._unsubscribeFromTimeUpdates();
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._addMediaEventListener(this._mediaElementAdapter.mediaElement, "timeupdate", function () {
                            that._onTimeUpdate();
                        });
                    }
                },

                _subscribeToMediaEvents: function (mediaElement) {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_subscribeToMediaEvents,StartTM");

                    var that = this;

                    this._addMediaEventListener(mediaElement, "canplay", function () {
                        that._onCanPlay();
                    });

                    this._addMediaEventListener(mediaElement, "durationchange", function () {
                        that._onDurationChange();
                    });

                    this._addMediaEventListener(mediaElement, "emptied", function () {
                        that._onEmptied();
                    });

                    this._addMediaEventListener(mediaElement, "ended", function () {
                        that._onEnded();
                    });

                    this._addMediaEventListener(mediaElement, "loadstart", function () {
                        that._onLoadStart();
                    });

                    this._addMediaEventListener(mediaElement, "loadedmetadata", function () {
                        that._onLoadedMetadata();
                    });

                    this._addMediaEventListener(mediaElement, "pause", function () {
                        that._onPause();
                    });

                    this._addMediaEventListener(mediaElement, "play", function () {
                        that._onPlay();
                    });

                    this._addMediaEventListener(mediaElement, "playing", function () {
                        that._onPlaying();
                    });

                    this._addMediaEventListener(mediaElement, "ratechange", function () {
                        that._onRateChange();
                    });

                    this._addMediaEventListener(mediaElement, "seeked", function () {
                        that._onSeeked();
                    });

                    this._addMediaEventListener(mediaElement, "seeking", function () {
                        that._onSeeking();
                    });

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_subscribeToMediaEvents,StopTM");
                },

                // Updates the seek bar position to match the current media play time
                _syncTimeAndProgress: function (force) {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        (!this._mediaElementAdapter.mediaElement.paused || force) &&
                        (wuiv && wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped)) {

                        var startTime = this._startTime;
                        var endTime = this._endTime;
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime - startTime;

                        if (!this._isThumbGrabbed &&
                            !this._isInFastForwardOrRewindMode &&
                            (force || this._isControlsVisible)) {

                            if (!this._totalSeekBarWidth &&
                                this._seekBar.clientWidth) {
                                this._totalSeekBarWidth = this._seekBar.clientWidth;
                            }
                            var progress = currentTime / this._totalTime;
                            var amountToMoveStuff = progress * this._totalSeekBarWidth;
                            this._currentTimeVisualElements.style.transform = "translateX(" + amountToMoveStuff + "px)";
                        }

                        if (currentTime > endTime) {
                            currentTime = endTime;
                        }

                        if (this._progress &&
                            !this._isThumbGrabbed) {
                            if (this._totalTime !== 0) {
                                this._progress.style.transform = "scaleX(" + progress + ")";
                            } else {
                                // If the totalTime is zero (this typically happens while the video is buffering for the 1st time)
                                // then instead of showing a full progress bar (0/0) we show an empty one.
                                this._progress.style.transform = "scaleX(0)";
                            }
                        }
                    }
                },

                // Unsubscribe from previously subscribed media events
                _unsubscribeFromMediaEvents: function (mediaElement) {

                    if (mediaElement) {
                        var mediaEventSubscriptionsLength = this._mediaEventSubscriptions.length;
                        for (var i = 0; i < mediaEventSubscriptionsLength; i++) {
                            mediaElement.removeEventListener(this._mediaEventSubscriptions[i].eventName, this._mediaEventSubscriptions[i].handler);
                        }
                    }

                    this._mediaEventSubscriptions = [];
                },

                // This method actually updates all marker visuals, not just chapter marker visuals
                _updateChapterMarkerVisuals: function () {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_updateChapterMarkerVisuals,StartTM");

                    if (this._isChapterMarkerVisualsDirty) {

                        var markers = null;
                        if (this._defaultChapterMarkers.length) {
                            markers = this._markers.concat(this._defaultChapterMarkers);
                        } else {
                            markers = this._markers;
                        }

                        // Remove existing markers from the timeline
                        if (this._seekBar.parentNode) {
                            var oldMarkers = this._seekBar.parentNode.querySelectorAll(".win-mediaplayer-marker");
                            var oldMarkersLength = oldMarkers.length;
                            for (var i = 0; i < oldMarkersLength; i++) {
                                oldMarkers[i].parentNode.removeChild(oldMarkers[i]);
                            }
                        }

                        // Add markers to the timeline
                        var currentMarkerTime = null;
                        var markersLength = markers.length;
                        for (var i = 0; i < markersLength; i++) {

                            currentMarkerTime = markers[i].time;
                            // Note: We check if currentMarkerTime is 'null' rather than checking "if (currentMarkerTime)", 
                            // because currentMarkerTime with a value of zero is valid.
                            if (markers[i].extraClass &&
                                currentMarkerTime !== null) {

                                // The totalSeekBarWidth is sometimes calculated when controls are shown for the 1st time.
                                // That means it is possible that the seek bar width has not been calculated and we need to calculate it.
                                if (!this._totalSeekBarWidth) {
                                    this._totalSeekBarWidth = this._seekBar.clientWidth;
                                    this._thumbElementWidthDividedByTwo = this._thumbElement.clientWidth / 2;
                                    this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                                }

                                // Create a DOM element for each marker
                                var marker = document.createElement("div");
                                marker.id = "ms__marker" + (currentMarkerTime.toString()).replace(".", "_");
                                utilities.addClass(marker, "win-mediaplayer-marker " + markers[i].extraClass);

                                var percentageTime = currentMarkerTime / this._totalTime;
                                var currentTimeLeftOffset = percentageTime * this._totalSeekBarWidth;
                                marker.style.marginLeft = currentTimeLeftOffset + "px";

                                if (this._seekBar.parentNode) {
                                    this._seekBar.parentNode.insertBefore(marker, this._seekBar.nextElementSibling);
                                }
                            }
                        }

                        // If the total width of the seekbar is zero (meaning it hasn't been calculated), then
                        // we need to leave _isChapterMarkerVisualsDirty as true, otherwise all markers will have
                        // a position of zero on the timeline.
                        if (!this._totalSeekBarWidth === 0) {
                            this._isChapterMarkerVisualsDirty = false;
                        } else {
                            this._isChapterMarkerVisualsDirty = true;
                        }
                    }

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_updateChapterMarkerVisuals,StopTM");
                },

                // When the DOM for the MediaPlayer changes, call this function to re-attach event listeners
                _updateDomElements: function () {

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_updateDomElements,StartTM");

                    this._removeButtonEventHandlers();

                    var mediaPlaybackContent = this._element.querySelector(".win-mediaplayer");
                    if (!mediaPlaybackContent) {
                        mediaPlaybackContent = document.createElement("div");
                        utilities.addClass(mediaPlaybackContent, "win-mediaplayer");
                    }

                    mediaPlaybackContent.innerHTML = this._mediaPlayerHtml;
                    this._element.appendChild(mediaPlaybackContent);

                    // Get references to all the UI elements
                    this._busyIndicator = this._element.querySelector(".win-mediaplayer-busy");
                    this._controls = this._element.querySelector(".win-mediaplayer-controls");
                    this._currentTimeIndicator = this._element.querySelector(".win-mediaplayer-currenttimeindicator");
                    this._inputHandlerElement = this._element.querySelector(".win-mediaplayer-inputhandler");
                    this._mediaCommandFeedbackText = this._element.querySelector(".win-mediaplayer-inputfeedback");
                    this._playbackSpeedIndicator = this._element.querySelector(".win-mediaplayer-playbackspeedindicator");
                    this._progress = this._element.querySelector(".win-mediaplayer-seekprogress");
                    this._progressContainer = this._element.querySelector(".win-mediaplayer-progresscontainer");
                    this._metadataTitle = this._element.querySelector(".win-mediaplayer-mediatitle");
                    this._metadataDescription = this._element.querySelector(".win-mediaplayer-mediadescription");
                    this._seekBar = this._element.querySelector(".win-mediaplayer-seekbar");
                    this._seekMark = this._element.querySelector(".win-mediaplayer-seek-mark");
                    this._seekWindowLeftEdgeElement = this._element.querySelector(".win-mediaplayer-seek-leftboundary");
                    this._seekWindowRightEdgeElement = this._element.querySelector(".win-mediaplayer-seek-rightboundary");
                    this._seekTimeIndicator = this._element.querySelector(".win-mediaplayer-seektimeindicator");
                    this._thumbnailImage = this._element.querySelector(".win-mediaplayer-thumbnail");
                    this._thumbnailImageVisual = this._element.querySelector(".win-mediaplayer-thumbnailvisual");
                    this._thumbElement = this._element.querySelector(".win-mediaplayer-thumb");
                    this._timeline = this._element.querySelector(".win-mediaplayer-timeline");
                    this._timeRemainingIndicator = this._element.querySelector("win-mediaplayer-timeremainingindicator");
                    this._totalTimeIndicator = this._element.querySelector(".win-mediaplayer-totaltimeindicator");
                    this._transportControls = this._element.querySelector(".win-mediaplayer-transportcontrols");
                    this._transportControlsPrimary = this._element.querySelector(".win-mediaplayer-transportcontrols-primary");
                    this._transportControlsSecondary = this._element.querySelector(".win-mediaplayer-transportcontrols-secondary");
                    this._snappedOverlay = this._element.querySelector(".win-mediaplayer-snapped-overlay");

                    this._currentTimeVisualElements = this._element.querySelector(".win-mediaplayer-seekbarvisualelements-container");

                    this._totalSeekBarWidth = this._seekBar.clientWidth;
                    this._thumbElementWidthDividedByTwo = this._thumbElement.clientWidth / 2;
                    this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;

                    var that = this;
                    // Note: the order the buttons are created in code will be the order they show up in the UI.
                    if (this._transportControls) {

                        // Primary transport bar buttons
                        this._chapterSkipBackButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-chapterskipbackbutton");
                        this._chapterSkipForwardButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-chapterskipforwardbutton");
                        this._fastForwardButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-fastforwardbutton");
                        this._nextTrackButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-nexttrackbutton");
                        this._playFromBeginningButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-playfrombeginningbutton");
                        this._playPauseButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-playpausebutton");
                        this._previousTrackButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-previoustrackbutton");
                        this._rewindButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-rewindbutton");
                        this._stopButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-stopbutton");
                        this._timeSkipBackButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-timeskipbackbutton");
                        this._timeSkipForwardButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-timeskipforwardbutton");

                        // Secondary transport bar buttons
                        this._closedCaptionsButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-closedcaptionsbutton");
                        this._displayModeButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-displaymodebutton");
                        this._goToLiveButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-livebutton");
                        this._infoButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-infobutton");
                        this._moreButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-morebutton");

                        // Create snap-mode only buttons
                        this._backButton = new XboxJS.UI.BackButton();
                        this._busyIndicator.parentNode.insertBefore(this._backButton.element, this._busyIndicator);
                        this._goToFullScreenButton = this._transportControlsPrimary.querySelector(".win-mediaplayer-gotofullscreenbutton");

                        // Logic so that using directional navigation and click will reset the auto-hide timer.
                        this._handleTransportBarButtonFocus = function transportBarButtonFocusHandler(ev) {
                            that._resetAutoHideTimers();
                        };
                        this._handleTransportBarButtonClick = function transportBarButtonClickHandler(ev) {
                            that._resetAutoHideTimers();

                            if (XboxJS.UI.MediaPlayer._sounds.selectButtonClick) {
                                XboxJS.UI.MediaPlayer._sounds.selectButtonClick.play();
                            }
                        };

                        // Because we don't key click events on gamepadA
                        this._handleTransportBarButtonKeyDown = function transportBarButtonKeyDownHandler(ev) {
                            if (ev.key === "GamepadA") {
                                WinJS.Utilities.addClass(ev.srcElement, "win-mediaplayer-transportbarbutton-active");
                            }
                        };
                        this._handleTransportBarButtonKeyUp = function transportBarButtonKeyUpHandler(ev) {
                            if (ev.key === "GamepadA") {
                                WinJS.Utilities.removeClass(ev.srcElement, "win-mediaplayer-transportbarbutton-active");

                                if (XboxJS.UI.MediaPlayer._sounds.selectButtonClick) {
                                    XboxJS.UI.MediaPlayer._sounds.selectButtonClick.play();
                                }
                            }
                        };

                        var buttonElements = this._transportControls.getElementsByTagName("button");
                        for (var i = 0, buttonElementsLength = buttonElements.length; i < buttonElementsLength; i++) {
                            this._addButtonEventHandler(buttonElements[i], "focus", this._handleTransportBarButtonFocus);
                            this._addButtonEventHandler(buttonElements[i], "click", this._handleTransportBarButtonClick);
                            this._addButtonEventHandler(buttonElements[i], "keydown", this._handleTransportBarButtonKeyDown);
                            this._addButtonEventHandler(buttonElements[i], "keyup", this._handleTransportBarButtonKeyUp);
                        }

                        // Attach event handlers
                        this._addButtonEventHandler(this._chapterSkipBackButton, "click", this._onChapterSkipBackCommandInvoked);
                        this._addButtonEventHandler(this._chapterSkipForwardButton, "click", this._onChapterSkipForwardCommandInvoked);
                        this._addButtonEventHandler(this._closedCaptionsButton, "click", this._onClosedCaptionsCommandInvoked);
                        this._addButtonEventHandler(this._displayModeButton, "click", this._onDisplayModeCommandInvoked);
                        this._addButtonEventHandler(this._fastForwardButton, "click", this._onFastForwardCommandInvoked);
                        this._addButtonEventHandler(this._goToFullScreenButton, "click", this._onGoToFullScreenCommandInvoked);
                        this._addButtonEventHandler(this._goToLiveButton, "click", this._onLiveButtonCommandInvoked);
                        this._addButtonEventHandler(this._infoButton, "click", this._onInfoButtonCommandInvoked);
                        this._addButtonEventHandler(this._moreButton, "click", this._onMoreCommandInvoked);
                        this._addButtonEventHandler(this._nextTrackButton, "click", this._onNextTrackCommandInvoked);
                        this._addButtonEventHandler(this._playFromBeginningButton, "click", this._onPlayFromBeginningCommandInvoked);
                        this._addButtonEventHandler(this._playPauseButton, "click", this._onPlayPauseCommandInvoked);
                        this._addButtonEventHandler(this._previousTrackButton, "click", this._onPreviousTrackCommandInvoked);
                        this._addButtonEventHandler(this._rewindButton, "click", this._onRewindCommandInvoked);
                        this._addButtonEventHandler(this._stopButton, "click", this._onStopCommandInvoked);
                        this._addButtonEventHandler(this._timeSkipBackButton, "click", this._onTimeSkipBackCommandInvoked);
                        this._addButtonEventHandler(this._timeSkipForwardButton, "click", this._onTimeSkipForwardCommandInvoked);

                        // Get a reference to the playpause visual
                        this._playPauseToggleVisual = this._playPauseButton.querySelector(".win-mediaplayer-playpausetogglevisual");
                    }

                    this._inputHandlerPointerDownCallback = this._onInputHandlerPointerDown.bind(this);
                    this._inputHandlerPointerMoveCallback = this._onInputHandlerPointerMove.bind(this);
                    this._inputHandlerPointerUpCallback = this._onInputHandlerPointerUp.bind(this);
                    this._inputHandlerClickCallback = this._onInputHandlerClick.bind(this);

                    // Register for gesture events
                    this._addGestureEventHandler(this._gestureRecognizer, 'manipulationstarted', this._handleManipulationStarted, false);
                    this._addGestureEventHandler(this._gestureRecognizer, 'manipulationupdated', this._handleManipulationUpdated, false);
                    this._addGestureEventHandler(this._gestureRecognizer, 'manipulationcompleted', this._handleManipulationCompleted, false);
                    this._addGestureEventHandler(this._gestureRecognizer, 'manipulationend', this._handleManipulationEnd, false);
                    this._addGestureEventHandler(this._inputHandlerElement, "click", this._inputHandlerClickCallback, false);
                    // The following events feed pointer input to the gesture recognizer
                    this._addGestureEventHandler(this._inputHandlerElement, "MSPointerDown", this._handlePointerDown);
                    this._addGestureEventHandler(this._inputHandlerElement, "MSPointerHover", this._handlePointerHover);
                    this._addGestureEventHandler(this._inputHandlerElement, "MSPointerMove", this._handlePointerMove);
                    this._addGestureEventHandler(this._inputHandlerElement, "MSPointerUp", this._handlePointerUp);

                    this._element.addEventListener("keyup", this._controlsKeyupInputHandler, false);

                    WinJS.Resources.processAll(this._element);

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:_updateDomElements,StopTM");

                },

                _updateFastForwardAndRewindState: function (oldPlaybackRate, newPlaybackRate) {

                    if (!this._isFastForwardOrRewind(oldPlaybackRate) &&
                        this._isFastForwardOrRewind(newPlaybackRate)) {
                        this._startFastForwardOrRewind();
                    } else if (this._isFastForwardOrRewind(oldPlaybackRate) &&
                               !this._isFastForwardOrRewind(newPlaybackRate)) {
                        this._exitFastForwardOrRewind(true);
                    } else {
                        // Do nothing
                    }

                    this.dispatchEvent("targetratechange", {});
                    this._updateMediaState(false);
                },

                _updateInfoDisplay: function (mediaCommand) {

                    this._mediaCommandFeedbackText.textContent = mediaCommand;
                },

                _updateMediaState: function (isStopped) {

                    // Return if we are running in an iframe or not on an Xbox
                    if (!utilities.hasWinRT ||
                        !Windows.Xbox ||
                        !this._smtControls) {
                        return;
                    }

                    var numberOfMilisecondsInASecond = 1000;
                    var playbackStatus = Windows.Media.MediaPlaybackStatus;
                    var updater = this._smtControls.displayUpdater;

                    // We need to set the contentId on every update because there could be cases where there are multiple
                    // concurrent videos. Because there is only one smtc, the two videos will override each other's state.
                    // For SmartGlass to be able to differentiate between the two video streams, we need to send the contentId
                    // along with each update.
                    if (updater &&
                        this._mediaMetadata) {
                        updater.appMediaId = this._mediaMetadata.contentId;
                    }

                    // Assign MediaTransportState
                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.mediaElement ||
                        !this._mediaElementAdapter.mediaElement.src) {
                        this._smtControls.playbackStatus = playbackStatus.closed;
                    } else if (isStopped ||
                        this._mediaElementAdapter.mediaElement.ended) {
                        this._smtControls.playbackStatus = playbackStatus.stopped;
                    } else if (this._isBusy) {
                        if (this._mediaElementAdapter.mediaElement.readyState <= this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            this._smtControls.playbackStatus = playbackStatus.changing;
                        }
                    } else if (!this._isInFastForwardOrRewindMode) {
                        if (this._mediaElementAdapter.mediaElement.paused) {
                            this._smtControls.playbackStatus = playbackStatus.paused;
                        } else {
                            this._smtControls.playbackStatus = playbackStatus.playing;
                        }
                    } else if (this._isInFastForwardOrRewindMode) {
                        this._smtControls.playbackStatus = playbackStatus.playing;
                    } else {
                        this._smtControls.playbackStatus = playbackStatus.closed;
                    }

                    this._smtControls.isFastForwardEnabled = this._isButtonEnabledAndVisible(this._fastForwardButton);
                    this._smtControls.isNextEnabled = this._isButtonEnabledAndVisible(this._chapterSkipForwardButton) || this._isButtonEnabledAndVisible(this._nextTrackButton);

                    if (this._isButtonEnabledAndVisible(this._playPauseButton)) {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {

                            if (this._mediaElementAdapter.mediaElement.paused) {
                                this._smtControls.isPlayEnabled = true;
                                this._smtControls.isPauseEnabled = false;
                            } else {
                                this._smtControls.isPlayEnabled = false;
                                this._smtControls.isPauseEnabled = true;
                            }
                        }
                    }

                    this._smtControls.isPreviousEnabled = this._isButtonEnabledAndVisible(this._chapterSkipBackButton) || this._isButtonEnabledAndVisible(this._previousTrackButton);
                    this._smtControls.isRewindEnabled = this._isButtonEnabledAndVisible(this._rewindButton);
                    this._smtControls.isStopEnabled = nav.canGoBack;
                    this._smtControls.isChannelUpEnabled = this._isButtonEnabledAndVisible(this._channelUpButton);
                    this._smtControls.isChannelDownEnabled = this._isButtonEnabledAndVisible(this._channelDownButton);

                    // Note: The duration is NaN before the video stream has loaded it's metadata, which will cause
                    // the MediaPlayer to fall into "live" mode. We need to check the state of the mediaElement to
                    // make sure that metadata is loaded before setting isLive to true.
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        !isFinite(this._mediaElementAdapter.mediaElement.duration) &&
                        this._mediaElementAdapter.mediaElement.readyState > this._MEDIA_READY_STATE_HAVE_METADATA) {
                        this._mediaElementAdapter.isLive = true;
                    }

                    if (updater.type === Windows.Media.MediaPlaybackType.video) {
                        updater.videoProperties.mediaStart = 0;
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.isSeekAllowed) {
                            if (isFinite(this._startTime)) {
                                updater.videoProperties.minSeek = this._startTime * numberOfMilisecondsInASecond;
                            }
                            // We use -1 to indicate to the SystemMediaTransportControl that the
                            // media represents a live event
                            if (this._mediaElementAdapter.isLive) {
                                if (isFinite(this.targetCurrentTime) &&
                                    isFinite(this._startTime)) {
                                    updater.videoProperties.maxSeek = (this.targetCurrentTime - this._startTime) * numberOfMilisecondsInASecond;
                                }
                                else {
                                    updater.videoProperties.maxSeek = 0;
                                }
                            } else {
                                if (isFinite(this._endTime)) {
                                    updater.videoProperties.maxSeek = this._endTime * numberOfMilisecondsInASecond;
                                }
                            }
                        } else {
                            updater.videoProperties.minSeek = 0;
                            updater.videoProperties.maxSeek = 0;
                        }
                        if (isFinite(this.targetCurrentTime)) {
                            updater.videoProperties.playbackPosition = this.targetCurrentTime * numberOfMilisecondsInASecond;
                        }
                        else {
                            updater.videoProperties.playbackPosition = 0;
                        }
                        updater.videoProperties.playbackRate = this.targetPlaybackRate;

                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement &&
                            updater.type) {
                            // We use -1 to indicate to the SystemMediaTransportControl that the
                            // media represents a live event
                            if (this._mediaElementAdapter.isLive) {
                                updater.videoProperties.mediaStart = 0;
                                updater.videoProperties.mediaEnd = -1;
                            } else {
                                if (this._mediaElementAdapter.mediaElement.duration &&
                                    isFinite(this._mediaElementAdapter.mediaElement.duration)) {
                                    updater.videoProperties.mediaStart = 0;
                                    updater.videoProperties.mediaEnd = this._mediaElementAdapter.mediaElement.duration * numberOfMilisecondsInASecond;
                                }
                            }
                        }
                    }

                    updater.update();
                },

                _updateTimeDisplay: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        (wuiv && wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped)) {
                        if (this._mediaElementAdapter.mediaElement.readyState < this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            this._clearTimeDisplay();
                        } else {
                            var elapsedTime = this._getElapsedTimeText();
                            this._currentTimeIndicator.textContent = elapsedTime;
                            this._totalTimeIndicator.textContent = "/ " + this._getTotalTimeText();

                            if (this._isInFastForwardOrRewindMode) {
                                this._seekTimeIndicator.textContent = elapsedTime;
                            }
                        }
                    }
                },

                // Helper function to update all the UI on the timeline
                _updateTimelineVisuals: function () {

                    this._syncTimeAndProgress(true);
                    this._updateTimeDisplay();
                },

                // Unsubscribe a specific media event
                _unsubscribeFromMediaEvent: function (eventName) {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        var mediaEventSubscriptionsLength = this._mediaEventSubscriptions.length;
                        for (var i = 0, len = mediaEventSubscriptionsLength; i < len; i++) {
                            var otherEventName = this._mediaEventSubscriptions[i].eventName;
                            if (eventName === otherEventName) {
                                this._mediaElementAdapter.mediaElement.removeEventListener(otherEventName, this._mediaEventSubscriptions[i].handler);
                                this._mediaEventSubscriptions.splice(i, 1);
                                break;
                            }
                        }
                    }
                },

                _updateDefaultStartAndEndTime: function (mediaElement) {

                    // Note: We are not worried that by calling 'this.startTime = ' rather than 'this._endTime' we will
                    // set _wasStartTimeSetProgrammatically to 'true' incorrectly, because we reset those values to false later in the function. 
                    if (!this._wasStartTimeSetProgrammatically) {
                        this._startTime = mediaElement.initialTime;

                        // Reset default chapter markers
                        if (this._defaultChapterMarkers.length) {
                            this._initializeDefaultChapterMarkers();
                        }

                        // Update the time display
                        this._updateTimelineVisuals();
                    }
                    if (!this._wasEndTimeSetProgrammatically) {
                        this._endTime = mediaElement.duration;

                        // Reset default chapter markers
                        if (this._defaultChapterMarkers.length) {
                            this._initializeDefaultChapterMarkers();
                        }

                        // Update the time display
                        this._updateTimelineVisuals();
                    }

                    // Note: We need to reset these values because when a new media src is loaded
                    // we don't care if someone previously set startTime or endTime programmatically.
                    // Since it is a new src, we want these values to be clean.
                    if (this._doesStartTimeNeedResetting) {
                        this._wasStartTimeSetProgrammatically = false;
                    }
                    if (this._doesEndTimeNeedResetting) {
                        this._wasEndTimeSetProgrammatically = false;
                    }

                    this._updateTimeDisplay();
                },

                // Unsubscribe to "timeupdate" events from MPT
                _unsubscribeFromTimeUpdates: function () {

                    if (!this._hasCustomMarkers &&
                        !this._isControlsVisible) {
                        this._unsubscribeFromMediaEvent("timeupdate");
                    }
                },

                _updateUIAndRaiseEvents: function (mediaCommand, mediaCommandDisplayString) {
                    this.dispatchEvent("mediacommandexecuted", { mediaCommand: mediaCommand });
                    this._updateMediaState(false);
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.endTime" helpKeyword="XboxJS.UI.MediaPlayer.endTime">
                /// Gets or sets maximum playback position of the media. By default, the value is the duration of the media.
                /// </field>
                endTime: {

                    get: function () {
                        return this._endTime;
                    },

                    set: function (value) {

                        this._endTime = value;
                        this._wasEndTimeSetProgrammatically = true;

                        this._totalTime = this._endTime - this._startTime;

                        // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                        // will not erase the old value of startTime.
                        if (!this._mediaElementAdapter ||
                            !this._mediaElementAdapter.mediaElement ||
                            this._mediaElementAdapter.mediaElement.readyState < this._MEDIA_READY_STATE_HAVE_METADATA) {
                            this._doesEndTimeNeedResetting = false;
                        }

                        this._subscribeToTimeUpdates();

                        // Update the time display
                        this._updateTimelineVisuals();

                        this._updateMediaState(false);
                    },
                },

                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.MediaPlayer.element" helpKeyword="XboxJS.UI.MediaPlayer.element">
                /// The DOM element that hosts the MediaPlayer control.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.isFullScreen" helpKeyword="XboxJS.UI.MediaPlayer.isFullScreen">
                /// Gets or sets a value indicating whether the MediaPlayer is full screen.
                /// </field>
                isFullScreen: {
                    get: function () {
                        return this._isFullScreen;
                    },

                    set: function (isFullScreen) {

                        if (isFullScreen) {
                            WinJS.Utilities.addClass(this._element, "win-mediaplayer-fullscreen");
                            utilities.removeClass(this.element, "win-focusable");

                            this._element.removeEventListener("keydown", this._keydownInputHandler);
                            this._element.removeEventListener("keyup", this._keyupInputHandler);
                            document.addEventListener("keydown", this._keydownInputHandler, false);
                            document.addEventListener("keyup", this._keyupInputHandler, false);
                        } else {
                            WinJS.Utilities.removeClass(this._element, "win-mediaplayer-fullscreen");
                            utilities.addClass(this.element, "win-focusable");

                            document.removeEventListener("keydown", this._keydownInputHandler);
                            document.removeEventListener("keyup", this._keyupInputHandler);
                            this._element.addEventListener("keydown", this._keydownInputHandler, false);
                            this._element.addEventListener("keyup", this._keyupInputHandler, false);
                        }

                        this._isFullScreen = isFullScreen;
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.isMediaUsageCollectionAllowed" helpKeyword="XboxJS.UI.MediaPlayer.isMediaUsageCollectionAllowed">
                /// Gets or sets a value that determines whether the system tracks the number of times that content has been viewed.
                /// </field>
                isMediaUsageCollectionAllowed: {

                    get: function () {
                        return this._isMediaUsageCollectionAllowed;
                    },

                    set: function (value) {
                        this._isMediaUsageCollectionAllowed = value;
                        if (!this._smtControls) {
                            return;
                        }
                        var updater = this._smtControls.displayUpdater;
                        if (updater.type === Windows.Media.MediaPlaybackType.video) {
                            if (value === Windows.Media.MediaLoggingLevel.complete) {
                                updater.videoProperties.loggingLevel = Windows.Media.MediaLoggingLevel.complete;
                            } else if (value === Windows.Media.MediaLoggingLevel.basic) {
                                updater.videoProperties.loggingLevel = Windows.Media.MediaLoggingLevel.basic;
                            } else {
                                updater.videoProperties.loggingLevel = Windows.Media.MediaLoggingLevel.noLogging;
                            }
                        }
                    },
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.isThumbnailEnabled" helpKeyword="XboxJS.UI.MediaPlayer.isThumbnailEnabled">
                /// Gets or sets a value indicating whether to use thumbnails for fast forward, rewind and scrubbing. If true, the fast forward, rewind and scrub operations
                /// will pause the mediaElement and cycle thumbnails as the user changes position. If false, the fast forward, rewind operations will increase or decrease
                /// the mediaElement's playbackRate and the scrub operation will move the position.
                /// </field>
                isThumbnailEnabled: {

                    get: function () {
                        return utilities.hasClass(this._timeline, "win-mediaplayer-thumbnailmode");
                    },

                    set: function (value) {
                        if (value) {
                            utilities.addClass(this._timeline, "win-mediaplayer-thumbnailmode");
                        } else {
                            utilities.removeClass(this._timeline, "win-mediaplayer-thumbnailmode");
                        }
                        // Although it is implemented, we never go into a true FF / RR state.
                        this._isThumbnailEnabled = true;
                    },
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.markers" helpKeyword="XboxJS.UI.MediaPlayer.markers">
                /// Gets or sets the MediaPlayer's marker collection.
                /// </field>
                markers: {

                    get: function () {
                        return this._markers;
                    },

                    set: function (value) {

                        // Clear any existing markers
                        this._markers.length = 0;
                        this._markers = value;

                        // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                        // will not delete those markers.
                        if (!this._mediaElementAdapter ||
                            !this._mediaElementAdapter.mediaElement ||
                            this._mediaElementAdapter.mediaElement.readyState < this._MEDIA_READY_STATE_HAVE_METADATA) {
                            this._doMarkersNeedResetting = false;
                        }

                        // Unsubscribe from time update if there are no markers in the array
                        if (!this._markers.length) {
                            this._hasCustomMarkers = false;
                            this._unsubscribeFromTimeUpdates();
                        }

                        this._onMarkerCollectionChanged();
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.mediaElementAdapter" helpKeyword="XboxJS.UI.MediaPlayer.mediaElementAdapter">
                /// Gets or sets an interface that your application can implement to have more control over synchronization between
                /// the MediaPlayer and your media.
                /// </field>
                mediaElementAdapter: {

                    get: function () {
                        return this._mediaElementAdapter;
                    },

                    set: function (value) {

                        var oldMediaElement = null;
                        var newMediaElement = null;

                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {
                            oldMediaElement = this._mediaElementAdapter.mediaElement;
                        }

                        if (value &&
                            value.mediaElement) {
                            newMediaElement = value.mediaElement;
                        }

                        this._setupNewMediaElement(newMediaElement, oldMediaElement);

                        this._mediaElementAdapter = value;
                    }
                },

                /// <field type="Number" locid="XboxJS.UI.Layout" helpKeyword="XboxJS.UI.Layout">
                /// Gets or sets the playback mode, which specifies how many transport controls are shown.
                /// </field>
                layout: {

                    get: function () {
                        return this._layout;
                    },

                    set: function (value) {

                        if (value !== layout.full &&
                            value !== layout.partial) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.MediaPlayer.unsupportedLayout", strings.mediaPlayerLayoutUnsupportedValue);
                        }

                        this._layout = value;
                        this._updateDomElements();
                    }
                },

                /// <field type="Boolean" locid="XboxJS.UI.MediaPlayer.isControlsVisible" helpKeyword="XboxJS.UI.MediaPlayer.isControlsVisible">
                /// Gets a property that specifies whether the transport controls are visible.
                /// </field>
                isControlsVisible: {

                    get: function () {
                        return this._isControlsVisible;
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.startTime" helpKeyword="XboxJS.UI.MediaPlayer.startTime">
                /// Gets or sets minimum playback position of the media. By default the value is zero.
                /// </field>
                startTime: {

                    get: function () {
                        return this._startTime;
                    },

                    set: function (value) {

                        this._startTime = value;
                        this._wasStartTimeSetProgrammatically = true;

                        this._totalTime = this._endTime - this._startTime;

                        // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                        // will not erase the old value of startTime.
                        if (!this._mediaElementAdapter ||
                            !this._mediaElementAdapter.mediaElement ||
                            this._mediaElementAdapter.mediaElement.readyState < this._MEDIA_READY_STATE_HAVE_METADATA) {
                            this._doesStartTimeNeedResetting = false;
                        }

                        // Note: Unlike for the endTime property, we do not call this._subscribeToTimeUpdates(), because during normal playback (playbackRate === 1), 
                        // we don't have the possibility of going before the startTime. This is because playback is always in the forward direction. In the RR case,
                        // we already subscribe to time updates when entering the fast forward or rewind state, so we don't have to do it again here.

                        // Update the time display
                        this._updateTimelineVisuals();

                        this._updateMediaState(false);
                    },
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.targetCurrentTime" helpKeyword="XboxJS.UI.MediaPlayer.targetCurrentTime">
                /// Gets the current time as it is represented in the UI. While fast forwarding or rewinding, this property may be different than the video or audio
                /// tag's 'currentTime' property. This is because during an fast forward or rewind operation, the media is paused while the timeline animates to
                /// simulate a fast forward or rewind operation.
                /// </field>
                targetCurrentTime: {

                    get: function () {

                        var targetCurrentTime = 0;

                        if (this._isThumbnailEnabled &&
                            this._isInFastForwardOrRewindMode) {
                            targetCurrentTime = this._targetCurrentTime;
                        } else {
                            if (this._mediaElementAdapter &&
                                this._mediaElementAdapter.mediaElement) {
                                targetCurrentTime = this._mediaElementAdapter.mediaElement.currentTime;
                            }
                        }

                        return targetCurrentTime;
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.targetPlaybackRate" helpKeyword="XboxJS.UI.MediaPlayer.targetPlaybackRate">
                /// Gets the playbackRate as it is represented in the UI. While fast forwarding or rewinding, this property may be different than the video or audio
                /// tag's 'playbackRate' property. This is because during an fast forward or rewind operation, the media is paused while the timeline animates to
                /// simulate a fast forward or rewind operation.
                /// </field>
                targetPlaybackRate: {

                    get: function () {

                        var targetPlaybackRate = 0;

                        if (this._isThumbnailEnabled &&
                            this._isInFastForwardOrRewindMode) {
                            targetPlaybackRate = this._targetPlaybackRate;
                        } else {
                            if (this._mediaElementAdapter &&
                                this._mediaElementAdapter.mediaElement) {
                                targetPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            }
                        }

                        return targetPlaybackRate;
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.timeFormatter" helpKeyword="XboxJS.UI.MediaPlayer.timeFormatter">
                /// Gets or sets a function that converts raw time data from the video or audio tag into text to display in the UI of the MediaPlayer.
                /// </field>
                timeFormatter: {

                    get: function () {
                        return this._timeFormatter;
                    },

                    set: function (value) {

                        if (value) {
                            this._timeFormatter = value;
                        } else {
                            // If timeFormatter is 'null', then use the default timeFormatter
                            this._timeFormatter = this._defaultTimeFormatter;
                        }
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.MediaPlayer.thumbnailImage" helpKeyword="XboxJS.UI.MediaPlayer.thumbnailImage">
                /// Sets the path to the current thumbnail image to display.
                /// </field>
                thumbnailImage: {
                    set: function (value) {
                        this._thumbnailImageVisual.style.backgroundImage = "url(" + value + ")";
                    }
                },

                // Public methods
                addMarker: function (time, type, data, extraClass) {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.addMarker">
                    /// <summary locid="XboxJS.UI.MediaPlayer.addMarker">
                    /// Ads a new chapter marker.
                    /// </summary>
                    /// <param name="time" type="Number" locid="XboxJS.UI.MediaPlayer.addMarker_p:time">
                    /// The marker time.
                    /// </param>
                    /// <param name="time" type="String" locid="XboxJS.UI.MediaPlayer.addMarker_p:type">
                    /// The marker type.
                    /// </param>
                    /// <param name="time" type="Object" locid="XboxJS.UI.MediaPlayer.addMarker_p:data">
                    /// The marker data.
                    /// </param>
                    /// <param name="extraClass" type="String" optional="true" locid="XboxJS.UI.MediaPlayer.addMarker_p:extraClass">
                    /// The marker data.
                    /// </param>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:addMarker,StartTM");

                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.mediaElement) {
                        return;
                    }

                    if ((!time &&
                        time !== 0) ||
                        isNaN(time)) {

                        throw new WinJS.ErrorFromName("XboxJS.UI.MediaPlayer.timeNotANumber", strings.mediaPlayerAddMarkerErrorTimeNotANumber);
                    }

                    if (type !== markerType.advertisement &&
                        type !== markerType.chapter &&
                        type !== markerType.custom) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.MediaPlayer.InvalidMarkerType", strings.mediaPlayerAddMarkerErrorInvalidMarkerType);
                    }

                    // If it's a chapter marker, clear out the default chapter markers
                    if (type === markerType.chapter) {
                        if (!extraClass) {
                            extraClass = "win-mediaplayer-chaptermarker";
                        }

                        if (this._defaultChapterMarkers.length) {
                            this._clearDefaultChapterMarkers();
                        }
                    } else if (type === markerType.advertisement) {
                        if (!extraClass) {
                            extraClass = "win-mediaplayer-advertisementmarker";
                        }

                        if (this._defaultChapterMarkers.length) {
                            this._clearDefaultChapterMarkers();
                        }
                    }

                    // Remove the marker if a marker with the same time already exists
                    var markersLength = this._markers.length
                    for (var i = 0; i < markersLength; i++) {
                        if (this._markers[i].time === time) {
                            this._markers.splice(i, 1);
                            break;
                        }
                    }

                    this._markers.push({ time: time, type: type, data: data, extraClass: extraClass });

                    // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                    // will not delete those markers.
                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.mediaElement ||
                        this._mediaElementAdapter.mediaElement.readyState < this._MEDIA_READY_STATE_HAVE_METADATA) {
                        this._doMarkersNeedResetting = false;
                    }

                    this._onMarkerCollectionChanged();

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:addMarker,StopTM");
                },

                chapterSkipBack: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.chapterSkipBack">
                    /// <summary locid="XboxJS.UI.MediaPlayer.chapterSkipBack">
                    /// Seeks to the previous chapter marker.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:chapterSkipBack,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: We're handling the logic for chapterSkipForward at the MediaPlayer level rather than in the
                        // MediaElementAdapater layer, because we want the experience to be consistent.

                        // Figure out where the next marker is
                        var newSeekTime = -1;
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        var chapterMarkers = null;

                        if (this._defaultChapterMarkers.length) {
                            chapterMarkers = this._defaultChapterMarkers;
                        } else {
                            chapterMarkers = this._markers;
                        }

                        var chapterMarkersLength = chapterMarkers.length;
                        for (var i = chapterMarkersLength - 1; i >= 0; i--) {
                            if ((chapterMarkers[i].type === markerType.chapter ||
                                chapterMarkers[i].type === markerType.advertisement) &&
                                chapterMarkers[i].time + this._CHAPTER_SKIP_THRESHOLD < currentTime) {
                                newSeekTime = chapterMarkers[i].time;
                                break;
                            }
                        }

                        if (newSeekTime !== -1) {
                            this._seekInternal(newSeekTime, false);
                        } else {
                            this._seekInternal(this._startTime, false);
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.chapterSkipBack, strings.chapterSkipBackMediaCommandDisplayText);
                    }
                },

                chapterSkipForward: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.chapterSkipForward">
                    /// <summary locid="XboxJS.UI.MediaPlayer.chapterSkipForward">
                    /// Seeks to the next chapter marker.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:chapterSkipForward,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: We're handling the logic for chapterSkipForward at the MediaPlayer level rather than in the
                        // MediaElementAdapater layer, because we want the experience to be consistent.

                        // Figure out where the next marker is
                        var newSeekTime = -1;
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        var chapterMarkers = null;

                        if (this._defaultChapterMarkers.length) {
                            chapterMarkers = this._defaultChapterMarkers;
                        } else {
                            chapterMarkers = this._markers;
                        }

                        var chapterMarkersLength = chapterMarkers.length;
                        for (var i = 0; i < chapterMarkersLength; i++) {
                            if ((chapterMarkers[i].type === markerType.chapter ||
                                chapterMarkers[i].type === markerType.advertisement) &&
                                chapterMarkers[i].time - this._CHAPTER_SKIP_THRESHOLD > currentTime) {
                                newSeekTime = chapterMarkers[i].time;
                                break;
                            }
                        }

                        if (newSeekTime !== -1) {
                            this._seekInternal(newSeekTime, false);
                        } else {
                            this._seekInternal(this._endTime, false);
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.chapterSkipForward, strings.chapterSkipForwardMediaCommandDisplayText);
                    }
                },

                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.dispose">
                    /// <summary locid="XboxJS.UI.MediaPlayer.dispose">
                    /// Releases MediaPlayer resources.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:dispose,StartTM");

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    // Cancel animations
                    if (this._controlsFadeInAnimation) {
                        this._controlsFadeInAnimation.cancel();
                        this._controlsFInAnimation = null;
                    }

                    if (this._controlsFadeOutAnimation) {
                        this._controlsFadeOutAnimation.cancel();
                        this._controlsFadeOutAnimation = null;
                    }

                    // Remove event listeners
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._mediaElementAdapter.mediaElement.removeEventListener("seeked", this._handleSeekedAfterExitFastForwardOrRewindBind);
                    }
                    this._handleSeekedAfterExitFastForwardOrRewindBind = null;

                    window.removeEventListener("resize", this._windowResizeCallback);
                    this._windowResizeCallback = null;

                    if (WinJS.Utilities.hasWinRT) {
                        Windows.UI.WebUI.WebUIApplication.removeEventListener("resuming", this._checkPremiumVideoAndParentalControlsBind);
                    }
                    app.removeEventListener("checkpoint", this._handleCheckpointCallback);

                    if (this._contentRestrictions) {
                        this._contentRestrictions.addEventListener("restrictionschanged", this._checkParentalControlsBind, false);
                    }

                    document.removeEventListener("visibilitychange", this._handleVisibilityChangedCallback);
                    this._handleVisibilityChangedCallback = null;

                    document.removeEventListener("keydown", this._keydownInputHandler);
                    document.removeEventListener("keyup", this._keyupInputHandler);
                    document.removeEventListener("keyup", this._controlsKeyupInputHandler);
                    this._controlsKeyupInputHandler = null;

                    if (Windows.Media.SystemMediaTransportControls) {
                        this._smtControls.removeEventListener("buttonpressed", this._handleSystemTransportControlsButtonPressedBind, false);
                        this._smtControls.removeEventListener("propertychanged", this._handleSystemTransportControlsPropertyChangedBind, false);
                    }
                    this._handleSystemTransportControlsButtonPressedBind = null;
                    this._handleSystemTransportControlsPropertyChangedBind = null;
                    this._smtControls = null;

                    if (this._element) {
                        this._element.removeEventListener("keydown", this._keydownInputHandler);
                        this._element.removeEventListener("keyup", this._keyupInputHandler);
                        this._keydownInputHandler = null;
                        this._keyupInputHandler = null;

                        if (SmartGlass &&
                            SmartGlass.removeEventListener) {
                            SmartGlass.removeEventListener("message", this._smartGlassInputHandler);
                        }
                        this._smartGlassInputHandler = null;
                    }

                    WinJS.Navigation.removeEventListener("beforenavigate", this._handleBeforeNavigatedCallback);

                    if (XboxJS) {
                        XboxJS.UI.Voice.removeEventListener("listeningstart", this._onShowControlsCommandInvokedBind);
                        XboxJS.UI.Voice.removeEventListener("listeningend", this._onHideControlsCommandInvokedBind);
                        window.removeEventListener("gestureengaged", this._onShowControlsCommandInvokedBind);
                        window.removeEventListener("gesturedisengaged", this._onHideControlsCommandInvokedBind);
                        this._onShowControlsCommandInvokedBind = null;
                        this._onHideControlsCommandInvokedBind = null;
                    }

                    // Clear timers
                    this._removeControlsTimer();
                    clearInterval(this._fastForwardOrRewindTimer);
                    clearInterval(this._updateMediaStateTimerCookie);
                    this._updateMediaStateTimerCookie = null;
                    this._unsubscribeFromTimeUpdates();

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._unsubscribeFromMediaEvents(this._mediaElementAdapter.mediaElement);
                    }
                    this._mediaEventSubscriptions = null;

                    this._removeButtonEventHandlers();
                    this._buttonEventSubscriptions = null;

                    this._removeGestureEventHandlers();
                    this._gestureEventSubscriptions = null;

                    // Remove text track event listeners
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        var textTracks = mediaElement.textTracks;
                        if (textTracks) {
                            var tracks = mediaElement.getElementsByTagName("track");
                            var tracksLength = tracks.length;
                            for (var i = 0; i < tracksLength; i++) {
                                if (tracks[i].kind === "chapters") {
                                    tracks[i].removeEventListener("load", this._loadTextTrackCallback);
                                }
                            }
                        }
                    }

                    this._adjustedContentType = null;
                    this._backButton.dispose();
                    this._backButton = null;
                    this._busyIndicator = null;
                    this._chapterSkipBackButton = null;
                    this._chapterSkipForwardButton = null;
                    this._checkPremiumVideoPrivilegeBind = null;
                    this._checkParentalControlsBind = null;
                    this._checkPremiumVideoAndParentalControlsBind = null;
                    this._closedCaptionsButton = null;
                    this._contentRestrictions = null;
                    this._controlHideTimeout = null;
                    this._controls = null;
                    this._controlsAddedHideDuration = null;
                    this._currentScrubbingVelocity = null;
                    this._currentTimeIndicator = null;
                    this._currentTimeVisualElements = null;
                    this._defaultChapterMarkers = [];
                    this._defaultChapterMarkers = null;
                    this._displayModeButton = null;
                    this._endTime = null;
                    this._fastForwardButton = null;
                    this._fastForwardOrRewindTimer = null;
                    this._fastForwardOrRewindTimerElapsedTime = null;
                    this._gestureRecognizer = null;
                    this._goToFullScreenButton = null;
                    this._goToLiveButton = null;
                    this._handleBeforeNavigatedCallback = null;
                    this._handleCheckpointCallback = null;
                    this._handleTransportBarButtonFocusBind = null;
                    this._handleTransportBarButtonClick = null;
                    this._handleTransportBarButtonFocus = null;
                    this._handleTransportBarButtonKeyDown = null;
                    this._handleTransportBarButtonKeyUp = null;
                    this._infoButton = null;
                    this._inputHandlerElement = null;
                    this._inputHandlerClickCallback = null;
                    this._inputHandlerPointerDownCallback = null;
                    this._inputHandlerPointerMoveCallback = null;
                    this._inputHandlerPointerUpCallback = null;
                    this._lastControlsResetTimeStamp = null;
                    this._lastFastForwardOrRewindTimerTime = null;
                    this._lastControlsResetTimeStamp = null;
                    this._lastPointerPosition = null;
                    this._lastPosition = null;
                    this._layout = null;
                    this._loadTextTrackCallback = null;
                    this._markers = [];
                    this._markers = null;
                    this._mediaCommandFeedbackText = null;

                    if (this._mediaElementAdapter) {
                        this._mediaElementAdapter.dispose();
                    }

                    this._mediaElementAdapter = null;
                    this._mediaMetadata = null;
                    this._mediaPlayerHtml = null;
                    this._mediaState = null;
                    this._metadataTitle = null;
                    this._metadataDescription = null;
                    this._minimumSeekableRangeInPixels = null;
                    this._moreButton = null;
                    this._nextCustomMarkerIndex = null;
                    this._nextCustomMarkerTime = null;
                    this._previousCustomMarkerIndex = null;
                    this._previousCustomMarkerTime = null;
                    this._nextTrackButton = null;
                    this._playbackSpeedIndicator = null;
                    this._playPauseButton = null;
                    this._playPauseToggleVisual = null;
                    this._playFromBeginningButton = null;
                    this._previousPlaybackRate = null;
                    this._previousTrackButton = null;
                    this._progress = null;
                    this._progressContainer = null;
                    this._updateMediaStateBind = null;
                    this._relativeTimelineStartOffset = null;
                    this._rewindButton = null;
                    this._seekBar = null;
                    this._seekMark = null;
                    this._seekTimeIndicator = null;
                    this._seekWindowLeftEdgeElement = null;
                    this._seekWindowRightEdgeElement = null;
                    this._startTime = null;
                    this._startOffsetX = null;
                    this._stopButton = null;
                    this._smtControls = null;
                    this._targetCurrentTime = null;
                    this._targetPlaybackRate = null;
                    this._thumbnailImage = null;
                    this._thumbnailImageVisual = null;
                    this._thumbElement = null;
                    this._thumbElementWidthDividedByTwo = null;
                    this._timeFormatter = null;
                    this._thumbImageElementWidthDividedByTwo = null;
                    this._timeBeforeShowingBusyVisual = null;
                    this._timeRemainingIndicator = null;
                    this._timeSeparator = null;
                    this._timeSkipBackButton = null;
                    this._timeSkipForwardButton = null;
                    this._timeline = null;
                    this._totalSeekBarWidth = null;
                    this._totalTimeIndicator = null;
                    this._totalTimeInternal = null;
                    this._transportControls = null;
                    this._transportControlsPrimary = null;
                    this._transportControlsSecondary = null;

                    // Constants
                    this._CHAPTER_SKIP_THRESHOLD = null;

                    this._FAST_FORWARD_OR_REWIND_TIMER_INTERVAL = null;
                    this._MINIMUM_ACCURATE_SEEKABLE_RANGE = null;
                    this._MINIMUM_POINTER_DELTA_TO_ENABLE_SNAPPING_TO_NEAREST_MARKER = null;
                    this._GESTURE_REGION_FOR_MOVING_THE_SEEKABLE_WINDOW = null;
                    this._REPORT_MEDIA_STATE_INTERVAL = null;
                    this._SNAP_TO_NEAREST_MARKER_THRESHOLD = null;

                    this._CONTROLS_AUTO_HIDE_DURATION = null;
                    this._MARKER_PROXIMITY_THRESHOLD = null;
                    // We won't add chapter markers for media under 1 minute
                    this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS = null;
                    this._MOUSE_LEFT_BUTTON = null;
                    this._MOUSE_POINTER_TYPE = null;
                    this._SEEK_OFFSET = null;
                    this._SKIP_BACK_INTERVAL = null;
                    this._SKIP_FORWARD_INTERVAL = null;

                    // Media ready states
                    this._MEDIA_READY_STATE_HAVE_NOTHING = null;
                    this._MEDIA_READY_STATE_HAVE_METADATA = null;
                    this._MEDIA_READY_STATE_HAVE_CURRENT_DATA = null;
                    this._MEDIA_READY_STATE_HAVE_FUTURE_DATA = null;
                    this._MEDIA_READY_STATE_HAVE_ENOUGH_DATA = null;

                    // PlaybackRates
                    this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE = null;
                    this._PLAYBACKRATE_FAST_FORWARD_128X = null;
                    this._PLAYBACKRATE_FAST_FORWARD_64X = null;
                    this._PLAYBACKRATE_FAST_FORWARD_32X = null;
                    this._PLAYBACKRATE_FAST_FORWARD_16X = null;
                    this._PLAYBACKRATE_FAST_FORWARD_8X = null;
                    this._PLAYBACKRATE_FAST_FORWARD_4X = null;
                    this._PLAYBACKRATE_FAST_FORWARD_2X = null;
                    this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE = null;
                    this._PLAYBACKRATE_PLAYING = null;
                    this._PLAYBACKRATE_NOT_PLAYING = null;
                    this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE = null;
                    this._PLAYBACKRATE_REWIND_2X = null;
                    this._PLAYBACKRATE_REWIND_4X = null;
                    this._PLAYBACKRATE_REWIND_8X = null;
                    this._PLAYBACKRATE_REWIND_16X = null;
                    this._PLAYBACKRATE_REWIND_32X = null;
                    this._PLAYBACKRATE_REWIND_64X = null;
                    this._PLAYBACKRATE_REWIND_128X = null;
                    this._PLAYBACKRATE_REWIND_MAX_RATE = null;

                    this._TAG_NAME_AUDIO = null;
                    this._TAG_NAME_VIDEO = null;

                    WinJS.Utilities.disposeSubTree(this._element);

                    this._element.winControl = null;
                    this._element = null;

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:dispose,StopTM");
                },

                fastForward: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.fastForward">
                    /// <summary locid="XboxJS.UI.MediaPlayer.fastForward">
                    /// Increases the playback rate of the media.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:fastForward,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (this._mediaElementAdapter.mediaElement.readyState < this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            return;
                        }

                        // We show the controls, because we need to give visual feedback to the user regarding timeline
                        // movement event if the API is called programmatically.
                        if (!this._isControlsVisible) {
                            this._showControls();
                        }

                        var newPlaybackRate = null;
                        if (!this._isInFastForwardOrRewindMode) {
                            this._targetPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            this._targetCurrentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        }

                        var currentPlaybackRate = null;
                        if (this._isThumbnailEnabled) {
                            currentPlaybackRate = this._targetPlaybackRate;
                        } else {
                            currentPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        }

                        if (!this._isInFastForwardOrRewindMode &&
                            this._mediaElementAdapter.mediaElement.paused &&
                            currentPlaybackRate === this._PLAYBACKRATE_REWIND_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (!this._isInFastForwardOrRewindMode &&
                                   this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_2X;
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            newPlaybackRate = Math.min(Math.floor(currentPlaybackRate) * 2, this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE);
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_FAST_FORWARD_2X &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_2X;
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_PLAYING &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_REWIND_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_REWIND_2X &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_REWIND_MAX_RATE) {
                            newPlaybackRate = Math.floor(currentPlaybackRate) / 2;
                        }

                        if (newPlaybackRate) {
                            if (this._isThumbnailEnabled) {
                                if (this._isFastForwardOrRewind(newPlaybackRate)) {
                                    var oldPlaybackRate = currentPlaybackRate;
                                    this._targetPlaybackRate = newPlaybackRate;
                                    this._updateFastForwardAndRewindState(oldPlaybackRate, newPlaybackRate);
                                } else {
                                    this._exitFastForwardOrRewind(true);
                                }
                            } else {
                                if (this._mediaElementAdapter.mediaElement.paused &&
                                    newPlaybackRate !== this._PLAYBACKRATE_PLAYING) {
                                    this._mediaElementAdapter.play();
                                }

                                this._mediaElementAdapter.mediaElement.playbackRate = newPlaybackRate;
                            }
                        }

                        this._setFastForwardOrRewindText();
                    }
                },

                goToLive: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.goToLive">
                    /// <summary locid="XboxJS.UI.MediaPlayer.goToLive">
                    /// Navigates to the real-time position in live streamed media.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:goToLive,StartTM");

                    if (this._mediaElementAdapter) {

                        this._exitFastForwardOrRewind(true);

                        // We try to handle all time movements as seeks so there are fewer
                        // one code paths to have to worry about for ad skipping.
                        this._seekInternal(this._mediaElementAdapter.liveTime, false);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.goToLive, strings.goToLiveMediaCommandDisplayText);
                    }
                },

                hideControls: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.hideControls">
                    /// <summary locid="XboxJS.UI.MediaPlayer.hideControls">
                    /// Hides all the UI associated with the MediaPlayer.
                    /// </summary>
                    /// </signature>

                    this._hideControls();
                },

                nextTrack: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.nextTrack">
                    /// <summary locid="XboxJS.UI.MediaPlayer.nextTrack">
                    /// Plays the next track.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:nextTrack,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.nextTrack) {

                        this._exitFastForwardOrRewind(true);

                        this._mediaElementAdapter.nextTrack();

                        this._updateUIAndRaiseEvents(mediaCommandEnum.nextTrack, strings.nextTrackMediaCommandDisplayText);
                    }
                },

                pause: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.pause">
                    /// <summary locid="XboxJS.UI.MediaPlayer.pause">
                    /// Pauses the media.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:pause,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.pause) {

                        if (this._isThumbnailEnabled &&
                            !this._isFastForwardOrRewind) {
                            this._exitFastForwardOrRewind(false);
                        } else {
                            this._mediaElementAdapter.pause();
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.pause, strings.pauseMediaCommandDisplayText);
                    }
                },

                play: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.play">
                    /// <summary locid="XboxJS.UI.MediaPlayer.play">
                    /// Sets the playbackRate to the default playbackRate for the media and plays the media.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:play,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.play) {

                        if (this._isThumbnailEnabled &&
                            this._isInFastForwardOrRewindMode) {
                            this._exitFastForwardOrRewind(true);
                        } else if (this._mediaElementAdapter.mediaElement &&
                                   this._mediaElementAdapter.mediaElement.ended ||
                                   this._endTimeReached) {
                            this._playFromBeginning();
                        } else {
                            this._mediaElementAdapter.play();
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.play, strings.playMediaCommandDisplayText);
                    }
                },

                previousTrack: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.previousTrack">
                    /// <summary locid="XboxJS.UI.MediaPlayer.previousTrack">
                    /// Plays the next track.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:previousTrack,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.previousTrack) {
                        this._mediaElementAdapter.previousTrack();

                        this._exitFastForwardOrRewind(true);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.previousTrack, strings.previousTrackMediaCommandDisplayText);
                    }
                },

                removeMarker: function (time) {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.removeMarker">
                    /// <summary locid="XboxJS.UI.MediaPlayer.removeMarker">
                    /// Removes all chapter markers at the specified time.
                    /// </summary>
                    /// <param name="time" type="Object" locid="XboxJS.UI.MediaPlayer.removeMarker_p:time">
                    /// The time of the marker to remove.
                    /// </param>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:removeMarker,StartTM");

                    var markersLength = this._markers.length;
                    for (var i = 0; i < markersLength; i++) {
                        if (this._markers[i].time === time) {
                            this._markers.splice(i, 1);
                            break;
                        }
                    }

                    // We need to reset the markersLength because a marker may have been removed
                    // so the length of the array has changed.
                    markersLength = this._markers.length;

                    // If we removed any of the markers that correspond to _nextCustomMarkerTime or  _previousCustomMarkerTime
                    // then we need to reset _nextCustomMarkerTime and _previousCustomMarkerTime. Otherwise we could fire
                    // an event for a non-existent marker.
                    if (this._nextCustomMarkerTime === time) {
                        if (this._nextCustomMarkerIndex < markersLength - 1 &&
                            this._markers[this._nextCustomMarkerIndex]) {
                            this._nextCustomMarkerIndex++;
                            this._nextCustomMarkerTime = this._markers[this._nextCustomMarkerIndex].time;
                        } else {
                            this._nextCustomMarkerIndex = -1;
                            this._nextCustomMarkerTime = -1;
                        }
                    }
                    if (this._previousCustomMarkerTime === time) {
                        if (this._previousCustomMarkerIndex > 0 &&
                            this._markers[this._previousCustomMarkerTime]) {
                            this._previousCustomMarkerIndex--;
                            this._previousCustomMarkerTime = this._markers[this._previousCustomMarkerTime].time;
                        } else {
                            this._previousCustomMarkerIndex = -1;
                            this._previousCustomMarkerTime = -1;
                        }
                    }

                    if (this._markers.length === 0) {
                        this._hasCustomMarkers = false;
                        this._unsubscribeFromTimeUpdates();
                    }

                    this._isChapterMarkerVisualsDirty = true;
                    this._updateChapterMarkerVisuals();

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:removeMarker,StopTM");
                },

                rewind: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.rewind">
                    /// <summary locid="XboxJS.UI.MediaPlayer.rewind">
                    /// Decreases the playbackRate of the media.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:rewind,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (this._mediaElementAdapter.mediaElement.readyState < this._MEDIA_READY_STATE_HAVE_FUTURE_DATA) {
                            return;
                        }

                        // We show the controls, because we need to give visual feedback to the user regarding timeline
                        // movement event if the API is called programmatically.
                        if (!this._isControlsVisible) {
                            this._showControls();
                        }

                        var newPlaybackRate = null;
                        if (!this._isInFastForwardOrRewindMode) {
                            this._targetPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            this._targetCurrentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        }

                        var currentPlaybackRate = this._PLAYBACKRATE_NOT_PLAYING;
                        if (this._isThumbnailEnabled) {
                            currentPlaybackRate = this._targetPlaybackRate;
                        } else {
                            currentPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        }

                        // We have special behavior for pause. If the user is in the playing state and presses
                        // rewind, they will go into a slow motion state.
                        if (!this._isInFastForwardOrRewindMode &&
                            this._mediaElementAdapter.mediaElement.paused &&
                            currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (!this._isInFastForwardOrRewindMode &&
                                   this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_2X;
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_REWIND_MAX_RATE &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_REWIND_2X) {
                            newPlaybackRate = Math.max(Math.floor(currentPlaybackRate) * 2, this._PLAYBACKRATE_REWIND_MAX_RATE);
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_REWIND_2X &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_2X;
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_PLAYING &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_FAST_FORWARD_2X &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE) {
                            newPlaybackRate = Math.floor(currentPlaybackRate) / 2;
                        }

                        if (newPlaybackRate) {
                            if (this._isThumbnailEnabled) {
                                if (this._isFastForwardOrRewind(newPlaybackRate)) {
                                    var oldPlaybackRate = currentPlaybackRate;
                                    this._targetPlaybackRate = newPlaybackRate;
                                    this._updateFastForwardAndRewindState(oldPlaybackRate, newPlaybackRate);
                                } else {
                                    this._exitFastForwardOrRewind(true);
                                }
                            } else {
                                if (this._mediaElementAdapter.mediaElement.paused &&
                                    newPlaybackRate !== this._PLAYBACKRATE_PLAYING) {
                                    this._mediaElementAdapter.play();
                                }

                                this._mediaElementAdapter.mediaElement.playbackRate = newPlaybackRate;
                            }
                        }

                        this._setFastForwardOrRewindText();
                    }
                },

                seek: function (time) {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.seek">
                    /// <summary locid="XboxJS.UI.MediaPlayer.seek">
                    /// Navigates to the specified position in the media.
                    /// </summary>
                    /// <param name="time" type="Number" locid="XboxJS.UI.MediaPlayer.seek_p:time">
                    /// The position in seconds to seek to.
                    /// </param>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:seek,StartTM");

                    this._seekInternal(time, true);
                },

                setContentMetadata: function (contentType, metadata) {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.setContentMetadata">
                    /// <summary locid="XboxJS.UI.MediaPlayer.setContentMetadata">
                    /// Sets the metadata fields for the given peice of media. This method should be called before changing the video stream.
                    /// </summary>
                    /// <param name="contentType" type="String" locid="XboxJS.UI.MediaPlayer.setContentMetadata:contentType">
                    /// The type of content that will be played by the mediaPlayer.
                    /// </param>
                    /// <param name="metadata" type="Object" locid="XboxJS.UI.MediaPlayer.setContentMetadata:metadata">
                    /// A collection of name value pairs that provide additional information about the current media.
                    /// </param>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:setContentMetadata,StartTM");

                    if (!contentType) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.MediaPlayer.nullContentType", strings.mediaPlayerNullContentType);
                    }

                    if (!metadata) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.MediaPlayer.nullMetadata", strings.mediaPlayerNullMetadata);
                    }

                    // Set the title & description in the UI
                    this._mediaMetadata = metadata;
                    this._mediaMetadata.contentType = contentType;
                    this._metadataTitle.textContent = this._mediaMetadata.title || "";
                    this._metadataDescription.textContent = this._mediaMetadata.description || "";

                    if (this._smtControls) {
                        var updater = this._smtControls.displayUpdater;
                        if (this._mediaElementAdapter.mediaElement &&
                            this._mediaElementAdapter.mediaElement.tagName === this._TAG_NAME_AUDIO) {
                            updater.type = Windows.Media.MediaPlaybackType.audio;
                        } else {
                            updater.type = Windows.Media.MediaPlaybackType.video;
                        }
                        updater.appMediaId = this._mediaMetadata.contentId;

                        // Set video properties
                        if (updater.type === Windows.Media.MediaPlaybackType.video) {
                            updater.videoProperties.title = this._mediaMetadata.title;
                            updater.videoProperties.acquisitionType = this._mediaMetadata.acquisitionType;
                            updater.videoProperties.acquisitionContext = this._mediaMetadata.acquisitionContext;
                            updater.videoProperties.acquisitionContextId = this._mediaMetadata.acquisitionContextId;
                            updater.videoProperties.acquisitionContextType = this._mediaMetadata.acquisitionContextType;
                            updater.videoProperties.acquisitionContextId = this._mediaMetadata.acquisitionContextId;
                            updater.videoProperties.subscriptionType = this._mediaMetadata.mediaSubscriptionType;
                            updater.videoProperties.subscriptionTier = this._mediaMetadata.subscriptionTier;
                            // Note: Due to a bug, we need to make sure not to set bingId, unless it has a value value
                            // Setting it to empty will throw an exception later when we try to update media state.
                            if (this._mediaMetadata.bingId) {
                                updater.videoProperties.bingId = this._mediaMetadata.bingId;
                            }
                        }

                        updater.update();
                    }

                    var that = this;
                    var isAllowedToViewContentBasedOnPremiumVideoPriviledge = false;
                    var isAllowedToViewContentBasedOnFamilySafetyPolicy = false;

                    return new WinJS.Promise(function (complete, error, progress) {

                        var checkPremiumVideoPromise = that._checkPremiumVideoPrivilege()
                            .then(
                                function afterPriviledgeCheck(result) {
                                    if (result) {
                                        isAllowedToViewContentBasedOnPremiumVideoPriviledge = true;
                                    } else {
                                        isAllowedToViewContentBasedOnPremiumVideoPriviledge = false;
                                    }
                                });
                        var checkParentalControlsPromise = that._checkParentalControls()
                            .then(
                                function afterContentRatingCheckReturns(result) {
                                    if (result) {
                                        isAllowedToViewContentBasedOnFamilySafetyPolicy = true;
                                    } else {
                                        isAllowedToViewContentBasedOnFamilySafetyPolicy = false;
                                    }
                                });

                        WinJS.Promise.join([checkPremiumVideoPromise, checkParentalControlsPromise])
                            .then(
                                function success() {
                                    if (isAllowedToViewContentBasedOnPremiumVideoPriviledge &&
                                        isAllowedToViewContentBasedOnFamilySafetyPolicy) {
                                        complete();
                                    } else {
                                        error();
                                        return;
                                    }
                                },
                                function errorHandler() {
                                    error();
                                    return;
                                });
                    });

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:setContentMetadata,StopTM");
                },

                showControls: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.showControls">
                    /// <summary locid="XboxJS.UI.MediaPlayer.showControls">
                    /// Displays the UI associated with the MediaPlayer.
                    /// </summary>
                    /// </signature>

                    this._showControls(false);
                },

                stop: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.stop">
                    /// <summary locid="XboxJS.UI.MediaPlayer.stop">
                    /// Stops the media.
                    /// </summary>
                    /// </signature>

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.stop) {
                        this._mediaElementAdapter.stop();
                        this._updateUIAndRaiseEvents(mediaCommandEnum.stop, strings.stopMediaCommandDisplayText);
                    }
                },

                timeSkipBack: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.timeSkipBack">
                    /// <summary locid="XboxJS.UI.MediaPlayer.timeSkipBack">
                    /// Moves the current timeline position backward by a short interval.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:timeSkipBack,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: Unlike the other media commands, which simply pass the command through to the MediaElementAdapter,
                        // the timeSkipBack command's logic is handled at the MediaPlayer layer, to ensure the interval of time
                        // to skip back is the same no matter what MediaElementAdapter is used.
                        var newTime = this._mediaElementAdapter.mediaElement.currentTime - this._SKIP_BACK_INTERVAL;

                        if (newTime < this._startTime) {
                            newTime = this._startTime;
                        }

                        this._seekInternal(newTime, false);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.timeSkipBack, strings.timeSkipBackMediaCommandDisplayText);
                    }
                },

                timeSkipForward: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaPlayer.timeSkipForward">
                    /// <summary locid="XboxJS.UI.MediaPlayer.timeSkipForward">
                    /// Moves the current timeline position forward short interval.
                    /// </summary>
                    /// </signature>

                    msWriteProfilerMark("XboxJS.UI.MediaPlayer:timeSkipForward,StartTM");

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: Unlike the other media commands, which simply pass the command through to the MediaElementAdapter,
                        // the timeSkipForward command's logic is handled at the MediaPlayer layer, to ensure the interval of time
                        // to skip forward is the same no matter what MediaElementAdapter is used.
                        var newTime = this._mediaElementAdapter.mediaElement.currentTime + this._SKIP_FORWARD_INTERVAL;

                        if (newTime > this._endTime) {
                            newTime = this._endTime;
                        }

                        this._seekInternal(newTime, false);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.timeSkipForward, strings.timeSkipForwardMediaCommandDisplayText);
                    }
                }
            }, {
                _sounds: {
                    initialized: false,
                    elementFocus1: null,
                    elementFocus2: null,
                    elementFocus3: null,
                    elementFocus4: null,
                    selectButtonClick: null,
                    overlayIn: null,
                    overlayOut: null,
                }
            });

            WinJS.Class.mix(MediaPlayer, utilities.createEventProperties(
               "beforeshowcontrols",
               "aftershowcontrols",
               "beforehidecontrols",
               "afterhidecontrols",
               "markerreached",
               "mediacommandexecuted",
               "targetratechange",
               "targettimeupdate",
               "thumbnailrequest"));
            WinJS.Class.mix(MediaPlayer, WinJS.UI.DOMEventMixin);
            return MediaPlayer;
        })
    });

}(this));


// Media Tile
(function mediaTileInit(global, WinJS, undefined) {
    "use strict";

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.MediaTile">
        /// A clickable rectangle with an image and text.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.MediaTile.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.MediaTile.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.MediaTile" data-win-options="{metadata: {title: 'Title', image: 'image.png', pronunciation: 'Title'}}"></div>]]></htmlSnippet>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.WinJS.1.0/css/ui-dark.css" shared="true" />
        MediaTile: WinJS.Namespace._lazy(function () {
            var app = WinJS.Application;

            // Keeps track of the number of MediaTiles that haven't loaded yet for determining which animation to use
            var _numberOfAnimatingMediaTiles = 0;

            function _getDefaultMediaTileTemplate(mediaTile) {
                var metadata = mediaTile._metadata;
                var metadatalabel = "";
                var metadatainformation = "";
                var metadataseason = "";

                if (mediaTile._titleString) {
                    metadatalabel = "<div class='win-text-tiletitle win-voice-inactivetext " + XboxJS.UI.MediaTile._ClassName.title + "'>" + mediaTile._titleString + "</div>";
                }
                if (metadata.season) {
                    metadataseason = "<div class='win-text-tilemetadata win-voice-inactivetext " + XboxJS.UI.MediaTile._ClassName.season + "'>" + metadata.season + "</div>";
                }
                if (metadata.information) {
                    metadatainformation = "<div class='win-text-tilemetadata win-voice-inactivetext " + XboxJS.UI.MediaTile._ClassName.information + "'>" + metadata.information + "</div>";
                }

                var htmlString = "<div class='win-itembox'>" +
                                    "  <div class='win-item'>" +
                                    "      <div class='win-mediatile-metadatagrid'>" +
                                    "        <div class='" + XboxJS.UI.MediaTile._ClassName.backgroundImage + "'></div>" +
                                    "        <div class='win-mediatile-metadata'><div class='win-mediatile-metadatabackground'></div>" + metadatalabel + metadataseason + metadatainformation + "</div>" +
                                    "    </div>" +
                                    "  </div>" +
                                    "</div>" +
                                    "<div class='win-tile-focusindicator'></div>" +
                                    "<div class='win-voice-host'>" +
                                    "<div class='win-voice-container'>" +
                                    "  <div class='win-voice-overlay'></div>" +
                                    "  <div class='win-voice-textdisplay win-voice-activetext'></div></div>" +
                                    "</div>" +
                                    "<div class='win-itemcontainer-captureproxy'></div>";

                return htmlString;
            };

            var strings = {
                get mediaTileDefaultContentRating() { return WinJS.Resources._getWinJSString("tv/mediaTileDefaultContentRating").value; }
            };

            var MediaTile = WinJS.Class.define(function mediaTile_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.MediaTile">
                /// <summary locid="XboxJS.UI.MediaTile.constructor">
                /// Creates a new MediaTile.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.MediaTile.constructor_p:element">
                /// The DOM element that hosts the MediaTile.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.MediaTile.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.MediaTile" locid="XboxJS.UI.MediaTile.constructor_returnValue">
                /// The new MediaTile.
                /// </returns>
                /// </signature>

                this._element = element || document.createElement("div");
                options = options || {};
                this._element.winControl = this;

                this._contentRatingElement = null;
                if (Windows.Media.ContentRestrictions &&
                    Windows.Media.ContentRestrictions.RatedContentRestrictions) {
                    this._contentRestrictions = new Windows.Media.ContentRestrictions.RatedContentRestrictions();
                }
                this._entranceAniamtionDuration = 1000;
                this._disposed = false;
                this._titleElement = null;
                this._titleBackgroundElement = null;
                this._imageElement = null;
                this._informationElement = null;
                this._playImageEntranceAnimationBind = this._playImageEntranceAnimation.bind(this);
                // The amount of time before an image is considered to have taken too long to load
                // and needs to play an image entrance animation. Units are in seconds.
                this._playImageLoadAnimationTimeThreshold = 2;
                // Image entrance animations are staggered so that there are not multiple animations occuring at the
                // same time. Units are in milliseconds.
                this._staggerImageEntranceTimeRange = 500;
                this._preloadedImage = new Image();
                this._titleString = null;
                this._metadata = {
                    contentRating: "",
                    title: "",
                    image: ""
                };
                this._dataWinVoiceOverride = null;
                this._template = _getDefaultMediaTileTemplate;

                this._adjustedContentType = null;
                this._convertedRating = "";
                this._isLocked = false;
                this._useDefaultTemplate = true;

                WinJS.UI.setOptions(this, options);
                WinJS.Utilities.addClass(this._element, "win-focusable win-disposable win-itemcontainer win-mediatile");

                // Div elements are not always focusable unless they have a tabIndex. Because the ItemContainer must always be focusable, we
                // assign a tabIndex if one does not already exist. We use a tabIndex of 0, which instructs Trident to choose the default tabbing
                // flow order for the control.
                if (!this.element.tabIndex) {
                    this.element.tabIndex = 0;
                }

                this._render();

                WinJS.UI.setOptions(this, options);

                var that = this;
                this._handleKeyDownBind = function _handleKeyDown(ev) {
                    if ((ev.key === "Spacebar" ||
                        ev.key === "Enter" ||
                        ev.key === "GamepadA") &&
                        !ev.repeat) {
                        WinJS.Utilities.addClass(that._element, "win-itemcontainer-active");
                    }
                };

                this._handleKeyUpBind = function _handleKeyUp(ev) {
                    if ((ev.key === "Spacebar" ||
                        ev.key === "Enter" ||
                        ev.key === "GamepadA") &&
                        !ev.repeat &&
                        WinJS.Utilities.hasClass(that._element, "win-itemcontainer-active")) {
                        WinJS.Utilities.removeClass(that._element, "win-itemcontainer-active");
                        if (that._isLocked) {
                            if (XboxJS.UI.MediaTile._sounds.disabledButtonClick) {
                                XboxJS.UI.MediaTile._sounds.disabledButtonClick.play();
                            }
                            ev.preventDefault();
                            ev.stopPropagation();
                            return;
                        }

                        that._fireInvokeEvent(ev.deviceSessionId);
                    }
                };

                this._handlePointerDownBind = function _handlePointerDown(ev) {
                    WinJS.Utilities.addClass(that._element, "win-itemcontainer-active");
                    if (XboxJS.UI.MediaTile._sounds.selectButtonPressingKinect &&
                        ev.pressExtent !== 0) {
                        XboxJS.UI.MediaTile._sounds.selectButtonPressingKinect.play();
                    }
                };

                this._handlePointerUpBind = function _handlePointerUp(ev) {
                    WinJS.Utilities.removeClass(that._element, "win-itemcontainer-active");
                };

                this._handlePointerOutBind = function _handlePointerOut(ev) {
                    WinJS.Utilities.removeClass(that._element, "win-itemcontainer-active");
                };

                this._handleClickBind = function _handleClick(ev) {
                    if (that._isLocked) {
                        if (XboxJS.UI.MediaTile._sounds.disabledButtonClick) {
                            XboxJS.UI.MediaTile._sounds.disabledButtonClick.play();
                        }
                        ev.preventDefault();
                        ev.stopPropagation();
                        return;
                    }

                    that._fireInvokeEvent(ev.deviceSessionId);
                };

                // We need to check parental controls on resume
                this._handleResumeCallback = function handleResume() {
                    that._checkParentalControls();
                };

                this._handleRestrictionsChangedCallback = function _handleRestrictionsChanged() {
                    that._checkParentalControls();
                };

                this._element.addEventListener("keydown", this._handleKeyDownBind, false);
                this._element.addEventListener("keyup", this._handleKeyUpBind, false);
                this._element.addEventListener("MSPointerDown", this._handlePointerDownBind, false);
                this._element.addEventListener("MSPointerUp", this._handlePointerUpBind, false);
                this._element.addEventListener("MSPointerOut", this._handlePointerOutBind, false);
                this._element.addEventListener("click", this._handleClickBind, false);
                if (WinJS.Utilities.hasWinRT) {
                    Windows.UI.WebUI.WebUIApplication.addEventListener("resuming", this._handleResumeCallback, false);
                }

                if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.MediaTile._sounds.initialized) {
                    XboxJS.UI.MediaTile._sounds.selectButtonClick = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///SelectButtonClick"));
                    XboxJS.UI.MediaTile._sounds.disabledButtonClick = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///DisabledButtonClick"));
                    XboxJS.UI.MediaTile._sounds.selectButtonPressingKinect = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///SelectButtonPressingKinect"));
                    XboxJS.UI.MediaTile._sounds.initialized = true;
                }

                if (this._contentRestrictions) {
                    this._contentRestrictions.addEventListener("restrictionschanged", this._handleRestrictionsChangedCallback, false);
                }

                // This time stamp keeps track of how long it takes to load the image element. This
                // value determines whether an image entrance animation should play or not.
                this._preloadImageStartTimeStamp = new Date().getTime();
                _numberOfAnimatingMediaTiles++;
            }, {
                // Item Container shared functions & properties

                /// <field type="Function" locid="XboxJS.UI.MediaTile.oninvoked" helpKeyword="XboxJS.UI.MediaTile.oninvoked">
                /// Raised when the user taps or clicks the item.
                /// </field>
                oninvoked: WinJS.Utilities._createEventProperty("invoked"),

                _fireInvokeEvent: function MediaTile_fireInvokeEvent(deviceSessionId) {
                    var eventObject = document.createEvent("CustomEvent");
                    // We set the deviceSessionId to zero for unrecognized devices (eg. if the event that caused the invoke event doesn't
                    // have a deviceSessionId). Invokation via voice is one example. 0 is just a convention.
                    eventObject.initCustomEvent("invoked", true, false, { deviceSessionId: deviceSessionId || 0 });
                    this.element.dispatchEvent(eventObject);

                    if (XboxJS.UI.MediaTile._sounds.selectButtonClick) {
                        XboxJS.UI.MediaTile._sounds.selectButtonClick.play();
                    }
                },

                // This is a helper function that will go away once ratings move to strings
                _convertContentType: function (origionalRating) {
                    var dataModelContentType = XboxJS.Data.ContentType;
                    var ratingCategory = Windows.Media.ContentRestrictions.RatedContentCategory;
                    var adjustedContentType = ratingCategory.general;
                    switch (origionalRating) {
                        case dataModelContentType.album:
                            adjustedContentType = ratingCategory.music;
                            break;
                        case dataModelContentType.movie:
                            adjustedContentType = ratingCategory.movie;
                            break;
                        case dataModelContentType.musicArtist:
                            adjustedContentType = ratingCategory.music;
                            break;
                        case dataModelContentType.musicVideo:
                            adjustedContentType = ratingCategory.movie;
                            break;
                        case dataModelContentType.track:
                            adjustedContentType = ratingCategory.music;
                            break;
                        case dataModelContentType.tvEpisode:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.tvSeason:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.tvSeries:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.tvShow:
                            adjustedContentType = ratingCategory.television;
                            break;
                        case dataModelContentType.webVideo:
                            adjustedContentType = ratingCategory.general;
                            break;
                        case dataModelContentType.webVideoCollection:
                            adjustedContentType = ratingCategory.general;
                            break;
                        default:
                            adjustedContentType = ratingCategory.general;
                            break;
                    };

                    return adjustedContentType;
                },
                _checkParentalControls: function () {

                    if (!WinJS.Utilities.hasWinRT ||
                        !Windows.Xbox ||
                        !this._metadata ||
                        !this._metadata.contentRating ||
                        !this._metadata.contentType) {
                        return;
                    }

                    var contentRestrictionsNamespace = Windows.Media.ContentRestrictions;
                    var contentType = this._convertContentType(this._metadata.contentType);
                    var contentDescription = new Windows.Media.ContentRestrictions.RatedContentDescription(
                        this._metadata.contentId,
                        this._metadata.title,
                        null,
                        contentType
                    );

                    contentDescription.category = contentType;
                    var ratingArray = [];
                    if (Array.isArray(this._metadata.contentRating)) {
                        ratingArray = this._metadata.contentRating;
                    } else {
                        ratingArray = [this._metadata.contentRating];
                    }
                    for (var i = 0, len = ratingArray.length; i < len; i++) {
                        contentDescription.ratings[i] = ratingArray[i];
                    }
                    var that = this;
                    return this._contentRestrictions.getRestrictionLevelAsync(contentDescription)
                        .then(function checkAccessPolicy(accessPolicyOutcome) {
                            var accessPolicy = contentRestrictionsNamespace.ContentAccessRestrictionLevel;
                            switch (accessPolicyOutcome) {
                                case accessPolicy.allow:
                                    // no-op, they can view the content so we proceed as we normally would.
                                    that._processUnHideTile();
                                    break;
                                case accessPolicy.block:
                                    // no-op, the block case will get handled by the MediaPlayer.
                                    that._processUnHideTile();
                                    break;
                                case accessPolicy.hide:
                                    // Ideally, we want this case to be handled with server side filtering so that hidden results
                                    // do not get returned from the service and we never hit this case. However, if this case does
                                    // occur, then we will render the tile as hidden.
                                    that._processHideTile();
                                    break;
                                case accessPolicy.warn:
                                    // no-op, we should never see this value.
                                    that._processUnHideTile();
                                    break;
                                default:
                                    // no-op
                                    break;
                            };
                        });
                },
                _fireEvent: function mediatile_fireEvent(type, detail) {
                    // Returns true if ev.preventDefault() was not called
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, true, true, detail);
                    return this.element.dispatchEvent(event);
                },
                _playImageEntranceAnimation: function (ev) {
                    var that = this;
                    // If there are too many MediaTiles, we just fade them in.
                    var shouldPlayElaborateAnimation = _numberOfAnimatingMediaTiles < 4;


                    // Set the animation to play at a random interval. That way we avoid a performance
                    // hit if they were to play all at once. Also, it looks better if the animations are
                    // staggered.
                    var staggerAnimationDelay = Math.random() * this._staggerImageEntranceTimeRange;
                    WinJS.Promise.timeout(staggerAnimationDelay).then(function afterStaggerAnimationDelay() {
                        if (!that ||
                            that._disposed ||
                            !that._captureProxy ||
                            !that._metadata) {
                            return;
                        }

                        that._imageElement.style.backgroundImage = "url(" + that._metadata.image + ")";
                        if (shouldPlayElaborateAnimation) {
                            // Color the click eating div white so it acts as a mask for the image so the
                            // image can fade from white.
                            WinJS.Utilities.addClass(that._captureProxy, "win-itemcontainer-imagemask");

                            var animationPromises = [];
                            // Animate the image element
                            animationPromises.push(WinJS.UI.executeTransition(that._imageElement,
                                [{
                                    property: "transform",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: "scale(1.20, 1.20)",
                                    to: "none"
                                },
                                {
                                    property: "opacity",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: 0,
                                    to: 1
                                }]));

                            animationPromises.push(WinJS.UI.executeTransition(that._captureProxy,
                                [{
                                    property: "opacity",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration / 3,
                                    timing: "linear",
                                    from: 0.7,
                                    to: 0
                                }]));

                            // Secondary animations for the text elements
                            animationPromises.push(WinJS.UI.executeTransition(that._titleElement,
                                [{
                                    property: "transform",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: "scale(1.20, 1.20)",
                                    to: "none"
                                },
                                {
                                    property: "opacity",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: 0,
                                    to: 1
                                }]));

                            animationPromises.push(WinJS.UI.executeTransition(that._titleBackgroundElement,
                                [{
                                    property: "transform",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: "scale(1.20, 1.20)",
                                    to: "none"
                                },
                                {
                                    property: "opacity",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: 0,
                                    to: 1
                                }]));

                            animationPromises.push(WinJS.UI.executeTransition(that._informationElement,
                                [{
                                    property: "transform",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: "scale(1.20, 1.20)",
                                    to: "none"
                                },
                                {
                                    property: "opacity",
                                    delay: 0,
                                    duration: that._entranceAniamtionDuration,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: 0,
                                    to: 1
                                }]));

                            WinJS.Promise.join(animationPromises).then(function () {
                                if (that._captureProxy) {
                                    WinJS.Utilities.removeClass(that._captureProxy, "win-itemcontainer-imagemask");
                                }
                                _numberOfAnimatingMediaTiles--;
                            });
                        } else {
                            WinJS.UI.Animation.fadeIn(that._element);
                            _numberOfAnimatingMediaTiles--;
                        }
                    });
                },
                _processHideTile: function () {
                    if (this._disposed) {
                        return;
                    }
                    this._isLocked = true;
                    WinJS.Utilities.addClass(this._element, "win-mediatile-familysafety-locked");
                },
                _processUnHideTile: function () {
                    if (this._disposed) {
                        return;
                    }
                    this._isLocked = false;
                    WinJS.Utilities.removeClass(this._element, "win-mediatile-familysafety-locked");
                },
                _render: function () {
                    if (this._template) {

                        // We create a dummy element for the sole purpose of getting
                        // innerHTML out of the render functions.
                        if (!this._useDefaultTemplate) {
                            var dummyElement = document.createElement("div");
                        }

                        this._element.innerHTML = "";
                        if (this._template.render) {
                            this._template.render(this, dummyElement);
                        } else if (this._template.winControl && this._template.winControl.render) {
                            this._template.winControl.render(this, dummyElement);
                        } else {
                            if (this._useDefaultTemplate) {
                                this._element.innerHTML = this._template(this);
                            } else {
                                this._element.innerHTML = this._template(this);
                            }
                        }

                        // Wrap the template in an ItemContainer
                        if (!this._useDefaultTemplate) {
                            this._element.innerHTML = "<div class='win-itembox'>" +
                                                    "  <div class='win-item'>" +
                                                    dummyElement.innerHTML +
                                                    "  </div>" +
                                                    "</div>" +
                                                    "<div class='win-tile-focusindicator'></div>" +
                                                    "<div class='win-voice-host'>" +
                                                    "<div class='win-voice-container'>" +
                                                    "  <div class='win-voice-overlay'></div>" +
                                                    "  <div class='win-voice-textdisplay win-voice-activetext'></div></div>" +
                                                    "</div>" +
                                                    "<div class='win-itemcontainer-captureproxy'></div>";
                        }

                        this._titleElement = this._element.querySelector("." + XboxJS.UI.MediaTile._ClassName.title);
                        this._titleBackgroundElement = this.element.querySelector("." + XboxJS.UI.MediaTile._ClassName.titleBackground);
                        this._imageElement = this._element.querySelector("." + XboxJS.UI.MediaTile._ClassName.backgroundImage);
                        this._contentRatingElement = this._element.querySelector("." + XboxJS.UI.MediaTile._ClassName.contentRating);
                        this._informationElement = this._element.querySelector("." + XboxJS.UI.MediaTile._ClassName.information);

                        // Get references to all ItemContainer variables
                        this._focusableIndicator = this._element.querySelector(".win-tile-focusindicator");
                        this._captureProxy = this._element.querySelector(".win-itemcontainer-captureproxy");
                        this._itemBox = this._element.querySelector(".win-itembox");

                        this._checkParentalControls();
                    }
                },
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.MediaTile.element" helpKeyword="XboxJS.UI.MediaTile.element">
                /// Gets the DOM element that hosts the MediaTile.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.MediaTile.isLocked" helpKeyword="XboxJS.UI.MediaTile.isLocked">
                /// Gets a property that indicates whether the MediaTile should be invokable based on family safety settings.
                /// </field>
                isLocked: {
                    get: function () {
                        return this._isLocked;
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.MediaTile.metadata" helpKeyword="XboxJS.UI.MediaTile.metadata">
                /// Gets or sets the collection of properties used to populate the MediaTile's UI.
                /// </field>
                metadata: {
                    get: function () {
                        return this._metadata;
                    },
                    set: function (value) {
                        if (!value) {
                            return;
                        }

                        this._metadata = value;
                        this._titleString = this._metadata.title;

                        if (this._metadata.contentRating &&
                            Windows.Xbox) {
                            this._convertedRating = this._convertContentType(this._metadata.contentType);
                        }

                        if (XboxJS.UI.Voice && !this._dataWinVoiceOverride) {
                            XboxJS.UI.Voice.updateVoiceAttribute(this._element, this._dataWinVoiceOverride, 'select(\".win-text-tiletitle\")', 'select(\".win-voice-activetext\")');
                            XboxJS.UI.Voice.refreshVoiceElements();
                        }

                        this._render();

                        if (this._metadata &&
                            this._metadata.image) {
                            var animationNotCanceled = this._fireEvent(XboxJS.UI.MediaTile._EventName.contentAnimating);
                            var rawElapsedTime = new Date().getTime() - this._preloadImageStartTimeStamp;
                            var elapsedTimeInSeconds = Math.floor(rawElapsedTime / 100) / 10;
                            if (this._imageElement &&
                                WinJS.UI.isAnimationEnabled() &&
                                animationNotCanceled &&
                                elapsedTimeInSeconds > this._playImageLoadAnimationTimeThreshold) {
                                this._imageElement.style.backgroundImage = "#";
                                this._preloadedImage.addEventListener("load", this._playImageEntranceAnimationBind, false);
                                if (this._preloadedImage.src !== this._metadata.image) {
                                    this._preloadedImage.src = this._metadata.image;
                                }
                            } else {
                                this._imageElement.style.backgroundImage = "url(" + this._metadata.image + ")";
                            }
                        }
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.MediaTile.dataWinVoiceOverride" helpKeyword="XboxJS.UI.MediaTile.dataWinVoiceOverride">
                /// Gets or sets the collection of properties used to voice enable the Media Tile UI.
                /// </field>
                dataWinVoiceOverride: {
                    get: function () {
                        return this._dataWinVoiceOverride;
                    },
                    set: function (value) {
                        if ((this._dataWinVoiceOverride === value) ||
                            ((this._dataWinVoiceOverride && value) &&
                             (this._dataWinVoiceOverride.pronunciation === value.pronunciation) &&
                             (this._dataWinVoiceOverride.confidence === value.confidence) &&
                             (this._dataWinVoiceOverride.phrase === value.phrase) &&
                             (this._dataWinVoiceOverride.enumerate === value.enumerate))) {
                            return;
                        }

                        this._dataWinVoiceOverride = value;

                        if (XboxJS.UI.Voice) {
                            XboxJS.UI.Voice.updateVoiceAttribute(this._element, this._dataWinVoiceOverride, 'select(\".win-text-tiletitle\")', 'select(\".win-voice-activetext\")');
                            XboxJS.UI.Voice.refreshVoiceElements();
                        }
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.MediaTile.template" helpKeyword="XboxJS.UI.MediaTile.template">
                /// Gets or sets the template used to render the MediaTile.
                /// </field>
                template: {
                    get: function () {
                        return this._template;
                    },
                    set: function (value) {
                        this._useDefaultTemplate = false;
                        this._template = value;
                        this._render();
                    }
                },
                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.MediaTile.dispose">
                    /// <summary locid="XboxJS.UI.MediaTile.dispose">
                    /// Disposes the control.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    this._element.removeEventListener("keydown", this._handleKeyDownBind);
                    this._element.removeEventListener("keyup", this._handleKeyUpBind);
                    this._element.removeEventListener("MSPointerDown", this._handlePointerDownBind);
                    this._element.removeEventListener("MSPointerUp", this._handlePointerUpBind);
                    this._element.removeEventListener("MSPointerOut", this._handlePointerOutBind);
                    this._element.removeEventListener("click", this._handleClickBind);
                    if (WinJS.Utilities.hasWinRT) {
                        Windows.UI.WebUI.WebUIApplication.removeEventListener("resuming", this._handleResumeCallback);
                    }

                    if (this._contentRestrictions) {
                        this._contentRestrictions.removeEventListener("restrictionschanged", this._handleRestrictionsChangedCallback);
                    }
                    this._handleRestrictionsChangedCallback = null;

                    this._handleKeyDownBind = null;
                    this._handleKeyUpBind = null;
                    this._handlePointerDownBind = null;
                    this._handlePointerUpBind = null;
                    this._handlePointerOutBind = null;
                    this._handleClickBind = null;
                    this._handleResumeCallback = null;

                    WinJS.Utilities.disposeSubTree(this.element);

                    this._captureProxy = null;
                    this._contentRatingElement = null;
                    this._contentRestrictions = null;
                    this._entranceAniamtionDuration = null;
                    this._focusableIndicator = null;
                    this._imageElement = null;
                    this._informationElement = null;
                    this._itemBox = null;
                    this._metadata = null;
                    this._playImageEntranceAnimationBind = null;
                    this._playImageLoadAnimationTimeThreshold = null;
                    this._preloadedImage = null;
                    this._preloadImageStartTimeStamp = null;
                    this._staggerImageEntranceTimeRange = null;
                    this._template = null;
                    this._titleBackgroundElement = null;
                    this._titleElement = null;
                    this._voiceOverlay = null;
                    this._voiceTextDisplay = null;
                    this._voiceUIContainer = null;
                    this._voiceUIhost = null;

                    this._titleString = null;
                    this._dataWinVoiceOverride = null;

                    this._element.winControl = null;
                    this._element = null;
                }
            }, {
                // Names of events fired by the MediaTile.
                _EventName: {
                    contentAnimating: "contentanimating"
                },
                // Names of classes used by the MediaTile.
                _ClassName: {
                    title: "win-mediatile-title",
                    titleBackground: "win-mediatile-metadatabackground",
                    season: "win-mediatile-season",
                    contentRating: "win-mediatile-contentrating",
                    backgroundImage: "win-mediatile-imagehost",
                    information: "win-mediatile-information"
                },

                _sounds: {
                    initialized: false,
                    selectButtonClick: null,
                    disabledButtonClick: null,
                    selectButtonPressingKinect: null
                }
            });
            WinJS.Class.mix(MediaTile, WinJS.UI.DOMEventMixin);
            return MediaTile;
        })
    })

})(this, WinJS);

(function () {
    "use strict";

    var appView = null;
    if (WinJS.Utilities.hasWinRT) {
        var appView = Windows.UI.ViewManagement.ApplicationView;
    }
    var nav = WinJS.Navigation;
    var utils = XboxJS.Utilities;

    var pagetransitioned = "pagetransitioned";

    WinJS.Namespace.define("XboxJS.UI.Pages", {
        /// <summary locid="XboxJS.UI.Pages.PageControlNavigator">
        /// A control that is used to navigate between different Page controls in your application.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.Pages.PageControlNavigator.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.Pages.PageControlNavigator.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.Pages.PageControlNavigator" data-win-options="{ home: "home.html" }"></div>]]></htmlSnippet>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.WinJS.1.0/css/ui-dark.css" shared="true" />
        PageControlNavigator: WinJS.Namespace._lazy(function () {
            var PageControlNavigator = WinJS.Class.define(function PageControlNavigator(element, options) {
                /// <signature helpKeyword="XboxJS.UI.Pages.PageControlNavigator">
                /// <summary locid="XboxJS.UI.Pages.PageControlNavigator.constructor">
                /// Creates a new PageControlNavigator.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.Pages.PageControlNavigator.constructor_p:element">
                /// The DOM element that hosts the PageControlNavigator.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.MediaTile.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.Pages.PageControlNavigator" locid="XboxJS.UI.Pages.PageControlNavigator.constructor_returnValue">
                /// The new PageControlNavigator.
                /// </returns>
                /// </signature>
                this._element = element || document.createElement("div");
                this._element.appendChild(this._createPageElement());

                WinJS.UI.setOptions(this, options);
                this._defaultEnterPageAnimationBind = this._defaultEnterPageAnimation.bind(this);
                this._defaultExitPageAnimationBind = this._defaultExitPageAnimation.bind(this);
                this._lastViewstate = appView.value;

                nav.onnavigated = this._navigated.bind(this);
                nav.onbeforenavigate = this._beforenavigate.bind(this);
                window.onresize = this._resized.bind(this);

                document.onkeyup = this._keyupHandler.bind(this);
                document.onkeypress = this._keypressHandler.bind(this);
                document.onmspointerup = this._mspointerupHandler.bind(this);

                // Boolean that prevents a new page transition to begin if one is currently taking place. If there
                // are multiple navigations happening simultaneously, then the user can get into a state where there
                // are multiple pages on screen at once and they randomly land on the wrong one and have no ability
                // to get back. Take this check out at your own risk.
                utils._isTransitioning = false;
                if (Windows.Media.SystemMediaTransportControls) {
                    this._smtControls = Windows.Media.SystemMediaTransportControls.getForCurrentView();
                    this._wasBackEnabledBeforeInstantiation = this._smtControls.isBackEnabled;
                    this._smtControls.isBackEnabled = true;
                    this._handleSystemTransportControlsButtonPressedBind = this._handleSystemTransportControlsButtonPressed.bind(this);
                    this._smtControls.addEventListener("buttonpressed", this._handleSystemTransportControlsButtonPressedBind, false);
                }
                WinJS.UI.Pages.navigator = this;

                if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.Pages.PageControlNavigator._sounds.initialized) {
                    XboxJS.UI.Pages.PageControlNavigator._sounds.backButtonClick = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///BackButtonClick"));
                    XboxJS.UI.Pages.PageControlNavigator._sounds.initialized = true;
                }
            }, {
                /// <field type="String" locid="XboxJS.UI.Pages.PageControlNavigator.home" helpKeyword="XboxJS.UI.Pages.PageControlNavigator.home">
                /// Represents the initial page of the application.
                /// </field>
                home: "",
                /// <field domElement="true" locid="1" />
                _element: null,
                _lastNavigationPromise: WinJS.Promise.as(),
                _lastViewstate: 0,
                _oldPageElement: null,
                _newPageElement: null,

                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.Pages.PageControlNavigator.dispose">
                    /// <summary locid="XboxJS.UI.Pages.PageControlNavigator.dispose">
                    /// Disposes the control.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    this._defaultEnterPageAnimationBind = null;
                    this._defaultExitPageAnimationBind = null;

                    nav.onnavigated = null;
                    nav.onbeforenavigate = null;
                    window.onresize = null;

                    document.onkeyup = null;
                    document.onkeypress = null;
                    document.onmspointerup = null;

                    if (this._smtControls) {
                        // Attempt to reset the back button to it's previous state before the control was instantiated
                        if (this._wasBackEnabledBeforeInstantiation &&
                            this._smtControls.isBackEnabled) {
                            this._smtControls.isBackEnabled = this._wasBackEnabledBeforeInstantiation;
                        }
                        this._smtControls.removeEventListener("buttonpressed", this._handleSystemTransportControlsButtonPressedBind);
                    }
                    this._handleSystemTransportControlsButtonPressedBind = null;
                    this._smtControls = null;
                },

                /// <field type="HTMLElement" domElement="true" locid="XboxJS.UI.Pages.PageControlNavigator.pageControl" helpKeyword="XboxJS.UI.Pages.PageControlNavigator.pageControl">
                /// Gets the currently loaded Page control.
                /// </field>
                pageControl: {
                    get: function () { return this.pageElement && this.pageElement.winControl; }
                },

                /// <field type="HTMLElement" domElement="true" locid="XboxJS.UI.Pages.PageControlNavigator.pageElement" helpKeyword="XboxJS.UI.Pages.PageControlNavigator.pageElement">
                /// Gets the root element of the page.
                /// </field>
                pageElement: {
                    get: function () { return this._element.firstElementChild; }
                },

                // Creates a container for a new page to be loaded into.
                _createPageElement: function () {
                    var element = document.createElement("div");
                    element.style.width = "100%";
                    element.style.height = "100%";
                    WinJS.Utilities.addClass(element, "win-layout-pagegrid");
                    return element;
                },

                // Handles global speech command for "Xbox, go back"
                _handleSystemTransportControlsButtonPressed: function (ev) {
                    var button = ev.button;
                    var systemMediaTransportControlsButton = Windows.Media.SystemMediaTransportControlsButton;
                    if (button === systemMediaTransportControlsButton.back) {
                        if (nav.canGoBack &&
                            !this._isThereVisibleFlyout()) {
                            nav.back();
                        }
                    }
                },

                // Returns true if there is a flyout in the DOM that is not hidden
                _isThereVisibleFlyout: function () {
                    var flyouts = document.querySelectorAll(".win-overlay");
                    for (var i = 0; i < flyouts.length; i++) {
                        var flyoutControl = flyouts[i].winControl;
                        if (flyoutControl && !flyoutControl.hidden) {
                            return true;
                        }
                    }

                    return false;
                },

                // Navigates back whenever the backspace key is pressed and
                // not captured by an input field.
                _keypressHandler: function (args) {
                    if (args.key === "Backspace") {
                        nav.back();
                    }
                },

                // Navigates back or forward when alt + left or alt + right
                // key combinations are pressed.
                _keyupHandler: function (args) {
                    if ((args.key === "Left" && args.altKey) || (args.key === "BrowserBack") || (args.key === "GamepadB")) {
                        if (!this._isThereVisibleFlyout()) {
                            nav.back();
                        }
                    } else if ((args.key === "Right" && args.altKey) || (args.key === "BrowserForward")) {
                        nav.forward();
                    }
                },

                // Helper function to turn off animations during a page navigation
                // to save on performance.
                _turnOffAnimations: function () {
                    while (WinJS.UI.isAnimationEnabled()) {
                        WinJS.UI.disableAnimations();
                    }
                },

                // Helper function to turn animations back on after they have been turned off.
                _turnOnAnimations: function () {
                    while (!WinJS.UI.isAnimationEnabled()) {
                        WinJS.UI.enableAnimations();
                    }
                },

                // This function responds to clicks to enable navigation using
                // back and forward mouse buttons.
                _mspointerupHandler: function (args) {
                    if (args.button === 3) {
                        nav.back();
                    } else if (args.button === 4) {
                        nav.forward();
                    }
                },

                // Responds to navigation by adding new pages to the DOM.
                _navigated: function (args) {
                    this._newPageElement = this._createPageElement();
                    var parentedComplete;
                    var parented = new WinJS.Promise(function (c) { parentedComplete = c; });

                    // Prevents a new page transition to begin if one is currently taking place.
                    if (this._lastNavigationPromise) {
                        this._lastNavigationPromise.cancel();
                    }

                    if (WinJS.UI.isAnimationEnabled()) {
                        var that = this;
                        utils._isTransitioning = true;
                        this._lastNavigationPromise = WinJS.Promise.timeout().then(function () {
                            return WinJS.UI.Pages.render(args.detail.location, that._newPageElement, args.detail.state, parented);
                        }).then(function parentElement(control) {
                            this._oldPageElement = this.pageElement;
                            var childPages = this._oldPageElement.querySelectorAll(".pagecontrol");
                            var animatePreviousPageForward = null;
                            var animateCurrentPageForward = null;
                            var animatePreviousPageBackward = null;
                            var animateCurrentPageBackward = null;

                            var enterPageAnimation = null;
                            var exitPageAnimation = null;

                            // Note: We need to set the initial opacity to zero, otherwise the page will be visible,
                            // before the animation begins which we don't want. We remove the class later on before
                            // the developer's animation kicks off.
                            WinJS.Utilities.addClass(this._newPageElement, "win-pagecontrol-hidden");
                            this._element.appendChild(this._newPageElement);

                            this._updateBackButton();
                            parentedComplete();

                            var isBackNavigation = utils._isBackwardNavigation;

                            // Animate Page Forward
                            if (!isBackNavigation) {
                                if (this._oldPageElement.winControl &&
                                    this._oldPageElement.winControl.exitPage) {
                                    exitPageAnimation = this._oldPageElement.winControl.exitPage;
                                } else {
                                    exitPageAnimation = this._defaultExitPageAnimationBind;
                                }

                                animatePreviousPageForward = exitPageAnimation(isBackNavigation);
                                animatePreviousPageForward.done(function animatePreviousPageForwardCompleted() {

                                    // unload child pages, if we have any
                                    for (var i = 0; i < childPages.length; i++) {
                                        var page = childPages[i];

                                        if (page.winControl && page.winControl.unload) {
                                            page.winControl.unload();
                                        }
                                    }

                                    // unload old top level page
                                    if (that._oldPageElement.winControl && that._oldPageElement.winControl.unload) {
                                        that._oldPageElement.winControl.unload();
                                    }
                                    WinJS.Utilities.disposeSubTree(that._oldPageElement);

                                    that._element.removeChild(that._oldPageElement);
                                    that._oldPageElement.innerText = "";

                                    // We need to reset the focusRoot in case it was set to an element on the
                                    // previous page. Otherwise, automatic focus will stop working, because our
                                    // focusRoot is no longer present in the UI.
                                    if (XboxJS.UI.AutomaticFocus.focusRoot) {
                                        XboxJS.UI.AutomaticFocus.focusRoot = that._newPageElement;
                                    }

                                    if (that._newPageElement.winControl &&
                                        that._newPageElement.winControl.enterPage) {
                                        enterPageAnimation = that._newPageElement.winControl.enterPage;
                                    } else {
                                        enterPageAnimation = that._defaultEnterPageAnimationBind;
                                    }

                                    WinJS.Utilities.removeClass(that._newPageElement, "win-pagecontrol-hidden");
                                    animateCurrentPageForward = enterPageAnimation(isBackNavigation);
                                    animateCurrentPageForward.done(function animateCurrentPageForwardCompleted() {
                                        utils._isTransitioning = false;
                                        XboxJS.UI.Pages.dispatchEvent(pagetransitioned, null);
                                    });
                                });
                                // Animate Page Backward
                            } else {
                                if (this._oldPageElement.winControl &&
                                    this._oldPageElement.winControl.exitPage) {
                                    exitPageAnimation = this._oldPageElement.winControl.exitPage;
                                } else {
                                    exitPageAnimation = this._defaultExitPageAnimationBind;
                                }

                                var animatePreviousPageBackward = exitPageAnimation(isBackNavigation);
                                animatePreviousPageBackward.done(function animatePreviousPageBackwardCompleted() {

                                    // unload child pages, if we have any
                                    for (var i = 0; i < childPages.length; i++) {
                                        var page = childPages[i];

                                        if (page.winControl && page.winControl.unload) {
                                            page.winControl.unload();
                                        }
                                    }

                                    // unload old top level page
                                    if (that._oldPageElement.winControl && that._oldPageElement.winControl.unload) {
                                        that._oldPageElement.winControl.unload();
                                    }
                                    WinJS.Utilities.disposeSubTree(that._oldPageElement);

                                    that._element.removeChild(that._oldPageElement);
                                    that._oldPageElement.innerText = "";

                                    // We need to reset the focusRoot in case it was set to an element on the
                                    // previous page. Otherwise, automatic focus will stop working, because our
                                    // focusRoot is no longer present in the UI.
                                    if (XboxJS.UI.AutomaticFocus.focusRoot) {
                                        XboxJS.UI.AutomaticFocus.focusRoot = that._newPageElement;
                                    }

                                    if (that._newPageElement.winControl &&
                                        that._newPageElement.winControl.enterPage) {
                                        enterPageAnimation = that._newPageElement.winControl.enterPage;
                                    } else {
                                        enterPageAnimation = that._defaultEnterPageAnimationBind;
                                    }

                                    WinJS.Utilities.removeClass(that._newPageElement, "win-pagecontrol-hidden");
                                    var animateCurrentPageBackward = enterPageAnimation(isBackNavigation);
                                    animateCurrentPageBackward.done(function animateCurrentPageBackwardCompleted() {
                                        utils._isTransitioning = false;
                                        XboxJS.UI.Pages.dispatchEvent(pagetransitioned, null);
                                    });
                                });
                            }
                        }.bind(this));

                        args.detail.setPromise(this._lastNavigationPromise);
                    } else {
                        var that = this;
                        this._lastNavigationPromise = WinJS.Promise.timeout().then(function () {
                            return WinJS.UI.Pages.render(args.detail.location, that._newPageElement, args.detail.state, parented);
                        }).then(function parentElement(control) {
                            this._oldPageElement = this.pageElement;
                            var childPages = this._oldPageElement.querySelectorAll(".pagecontrol");

                            // unload child pages, if we have any
                            for (var i = 0; i < childPages.length; i++) {
                                var page = childPages[i];

                                if (page.winControl && page.winControl.unload) {
                                    page.winControl.unload();
                                }
                            }

                            // unload old top level page
                            if (this._oldPageElement.winControl && this._oldPageElement.winControl.unload) {
                                this._oldPageElement.winControl.unload();
                            }
                            WinJS.Utilities.disposeSubTree(this._element);
                            this._element.appendChild(this._newPageElement);
                            this._element.removeChild(this._oldPageElement);
                            this._oldPageElement.innerText = "";

                            // We need to reset the focusRoot in case it was set to an element on the
                            // previous page. Otherwise, automatic focus will stop working, because our
                            // focusRoot is no longer present in the UI.
                            if (XboxJS.UI.AutomaticFocus.focusRoot) {
                                XboxJS.UI.AutomaticFocus.focusRoot = this._newPageElement;
                            }

                            this._updateBackButton();
                            parentedComplete();
                        }.bind(this));

                        args.detail.setPromise(this._lastNavigationPromise);
                    }
                },

                // Responds to resize events and call the updateLayout function
                // on the currently loaded page.
                _resized: function (args) {
                    if (this.pageControl && this.pageControl.updateLayout) {
                        this.pageControl.updateLayout.call(this.pageControl, this.pageElement, appView.value, this._lastViewstate);
                    }
                    this._lastViewstate = appView.value;
                },

                // Updates the back button state. Called after navigation has
                // completed.
                _updateBackButton: function () {
                    var backButton = this.pageElement.querySelector("header[role=banner] .win-backbutton");
                    if (backButton) {
                        backButton.onclick = function () { nav.back(); };

                        if (nav.canGoBack) {
                            backButton.removeAttribute("disabled");
                        } else {
                            backButton.setAttribute("disabled", "disabled");
                        }
                    }
                },

                _defaultEnterPageAnimation: function pageControlNavigator_defaultEnterPageAnimation(isBackNavigation) {

                    // It is possible for us to get HTML elements that are not actual page controls. If that is
                    // is true, we need to return immediately or we will cause errors. This case happens on the
                    // very first page load.
                    if (!this._newPageElement.winControl) {
                        return WinJS.Promise.wrap(null);
                    }

                    var fromScale = null;
                    var toScale = null;
                    var opacity = null;
                    var delay = 0;

                    if (!isBackNavigation) {
                        fromScale = "scale(.5 , .5)";
                        toScale = "scale(1 , 1)";
                        opacity = 1;
                        this._newPageElement.style.opacity = 0;
                    } else {
                        fromScale = "scale(1.5 , 1.5)";
                        toScale = "scale(1 , 1)";
                        opacity = 1;
                        this._newPageElement.style.opacity = 0;
                    }
                    var that = this;
                    return new WinJS.Promise(function (complete, error) {
                        var animationPromise = WinJS.UI.executeTransition(that._newPageElement,
                                [{
                                    property: "transform",
                                    delay: delay,
                                    duration: 340,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: fromScale,
                                    to: toScale
                                },
                                {
                                    property: "opacity",
                                    delay: delay,
                                    duration: 340,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    to: opacity
                                }]);
                        // Turn off animations
                        that._turnOffAnimations();
                        animationPromise.done(function afterAnimationCompleted() {

                            if (!isBackNavigation) {
                                that._newPageElement.style.zIndex = 1;
                            } else {
                                that._newPageElement.style.zIndex = 0;
                            }

                            // Turn animations back on
                            that._turnOnAnimations();
                            complete();
                        });
                    });
                },

                _defaultExitPageAnimation: function pageControlNavigator_defaultExitPageAnimation(isBackNavigation) {

                    // It is possible for us to get HTML elements that are not actual page controls. If that is
                    // is true, we need to return immediately or we will cause errors. This case happens on the
                    // very first page load.
                    if (!this._oldPageElement.winControl ||
                        !this._newPageElement.winControl) {
                        return WinJS.Promise.wrap(null);
                    }

                    if (!isBackNavigation) {
                        this._oldPageElement.style.zIndex = 0;
                        this._newPageElement.style.opacity = 0;
                        this._newPageElement.style.zIndex = -1;
                    } else {
                        this._oldPageElement.style.zIndex = 0;
                        this._newPageElement.style.opacity = 0;
                        this._newPageElement.style.zIndex = 1;
                    }

                    var fromScale = null;
                    var toScale = null;
                    var opacity = null;
                    var delay = 0;

                    if (!isBackNavigation) {
                        fromScale = "scale(1 , 1)";
                        toScale = "scale(1.5 , 1.5)";
                        opacity = 0;
                        this._oldPageElement.style.opacity = 1;
                    } else {
                        fromScale = "scale(1 , 1)";
                        toScale = "scale(.5 , .5)";
                        opacity = 0;
                        this._oldPageElement.style.opacity = 1;
                    }
                    var that = this;
                    return new WinJS.Promise(function (complete, error) {
                        var animationPromise = WinJS.UI.executeTransition(that._oldPageElement,
                                [{
                                    property: "transform",
                                    delay: delay,
                                    duration: 340,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: fromScale,
                                    to: toScale
                                },
                                {
                                    property: "opacity",
                                    delay: delay,
                                    duration: 340,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    to: opacity
                                }]);
                        // Turn off animations
                        that._turnOffAnimations();
                        animationPromise.done(function afterAnimationCompleted() {
                            // Turn animations back on
                            that._turnOnAnimations();
                            complete();
                        });
                    });
                },

                _beforenavigate: function pageControlNavigator_beforenavigate(args) {
                    if (XboxJS.Utilities._isBackwardNavigation && XboxJS.UI.Pages.PageControlNavigator._sounds.backButtonClick) {
                        XboxJS.UI.Pages.PageControlNavigator._sounds.backButtonClick.play();
                    }
                }
            }, {
                _sounds: {
                    initialized: false,
                    backButtonClick: null
                }
            });
            return PageControlNavigator;
        })
    });
    XboxJS.UI.Pages.prototype = XboxJS.UI.Pages;
    WinJS.Class.mix(XboxJS.UI.Pages, WinJS.Utilities.eventMixin);
})();


// Rating Picker
(function ratingPickerInit(global, WinJS, undefined) {
    "use strict";

    // Constants definition
    var CHANGE = "change",
        MIN_RATING = 1,
        MEDIAN_RATING_INDEX = 2,
        MAX_RATING = 5;

    var _getVoiceAttributeForRating = function (index) {
        if (index === 1) {
            return "data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/ONE_STAR_RATING_LABEL_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/ONE_STAR_RATING_LABEL_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/ONE_STAR_RATING_LABEL_VUI_PRON') + "', targetElement: select('.win-ratingpicker-voice') }\"";
        } else if (index === 2) {
            return "data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TWO_STARS_RATING_LABEL_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TWO_STARS_RATING_LABEL_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/TWO_STARS_RATING_LABEL_VUI_PRON') + "', targetElement: select('.win-ratingpicker-voice') }\"";
        } else if (index === 3) {
            return "data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/THREE_STARS_RATING_LABEL_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/THREE_STARS_RATING_LABEL_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/THREE_STARS_RATING_LABEL_VUI_PRON') + "', targetElement: select('.win-ratingpicker-voice') }\"";
        } else if (index === 4) {
            return "data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FOUR_STARS_RATING_LABEL_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FOUR_STARS_RATING_LABEL_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FOUR_STARS_RATING_LABEL_VUI_PRON') + "', targetElement: select('.win-ratingpicker-voice') }\"";
        } else if (index === 5) {
            return "data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FIVE_STARS_RATING_LABEL_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FIVE_STARS_RATING_LABEL_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/FIVE_STARS_RATING_LABEL_VUI_PRON') + "', targetElement: select('.win-ratingpicker-voice') }\"";
        } else {
            return "";
        }
    };

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.RatingPicker">
        /// An input control that allows the user to choose a rating.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.RatingPicker.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.RatingPicker.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.RatingPicker"></div>]]></htmlSnippet>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.WinJS.1.0/css/ui-dark.css" shared="true" />
        RatingPicker: WinJS.Namespace._lazy(function () {
            // Statics
            var strings = {
                get ratingPickerClearRating() { return WinJS.Resources._getWinJSString("tv/NO_RATING_LABEL_VUI_GUI").value; },
            };

            var RatingPicker = WinJS.Class.define(function ratingPicker_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.RatingPicker">
                /// <summary locid="XboxJS.UI.RatingPicker.constructor">
                /// Creates a new RatingPicker control that allows the user to choose a star rating.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.RatingPicker.constructor_p:element">
                /// The DOM element that hosts the RatingPicker.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.RatingPicker.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.RatingPicker" locid="XboxJS.UI.RatingPicker.constructor_returnValue">
                /// The new RatingPicker.
                /// </returns>
                /// </signature>

                this._element = element || document.createElement("div");
                options = options || {};
                this._element.winControl = this;

                this._disposed = false;
                this._enableclear = false;
                this._label = "";
                this._dataWinVoiceOverride = null;
                this._rateButton = document.createElement("div");
                var itemContainer = new XboxJS.UI.ItemContainer(this._rateButton);

                WinJS.Utilities.addClass(this._rateButton, "win-tile-horizontaltext");
                WinJS.Utilities.addClass(this._rateButton, XboxJS.UI.RatingPicker._ClassName.ratingButton);

                this._element.appendChild(this._rateButton);

                this._ratingPickerFlyout = new WinJS.UI.Flyout();
                this._buttonEventSubscriptions = [];
                this._pendingRefresh = true;

                var ratingPickerContainer = this._ratingPickerFlyout.element.querySelector(".win-overlay-container");
                WinJS.Utilities.addClass(ratingPickerContainer, "win-ratingpicker-container");

                var html = "<div class='win-ratingpicker-flyoutcenteringdiv'>";
                // Note: This option will only appear if the control's enableClear property is set to true
                html += "<button class='" + XboxJS.UI.RatingPicker._ClassName.ratingOption + " win-ratingpicker-clearrating' data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('tv/NO_RATING_LABEL_VUI_GUI') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('tv/NO_RATING_LABEL_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('tv/NO_RATING_LABEL_VUI_PRON') + "', targetElement: select('this') }\">" + strings.ratingPickerClearRating + "<span class='win-ratingpicker-voice'></span></button>";

                // Create control
                for (var i = MIN_RATING; i <= MAX_RATING; i++) {
                    // Create the option in the menu
                    // Select voice phrase
                    var dataWinVoice = _getVoiceAttributeForRating(i);
                    html = html + "<button class='" + XboxJS.UI.RatingPicker._ClassName.ratingOption + "' " + dataWinVoice + ">";
                    for (var j = 0; j < MAX_RATING; j++) {
                        if (j < i) {
                            html += "  <span class='win-star win-icon-rate win-full win-ratingpicker-nonvoice'></span>";
                        } else {
                            html += "  <span class='win-star win-icon-rate win-empty win-ratingpicker-nonvoice'></span>";
                        }
                    }
                    html += "    <span class='win-ratingpicker-voice'></span>";

                    html += "</button>";
                }
                html += "</div>"
                ratingPickerContainer.innerHTML = html;

                var that = this;
                this._handleRatingChosenBind = function _handleRatingChosen(numberOfStars) {
                    var dispatchedEvent = document.createEvent("Event");
                    dispatchedEvent.initEvent(CHANGE, true, true);
                    dispatchedEvent.detail = { tentativeRating: numberOfStars };

                    that._element.dispatchEvent(dispatchedEvent);
                    that._ratingPickerFlyout.hide();
                };

                WinJS.UI.setOptions(this, options);
                WinJS.Utilities.addClass(this._element, "win-disposable " + XboxJS.UI.RatingPicker._ClassName.ratingPicker);
                var winItem = this._rateButton.querySelector(".win-item");
                winItem.innerHTML = '<div class="win-text-tiletitle win-voice-inactivetext"></div>';
                var tileTitle = this._rateButton.querySelector(".win-text-tiletitle");
                tileTitle.innerText = this._label;
                if (XboxJS.UI.Voice) {
                    XboxJS.UI.Voice.updateVoiceAttribute(this._rateButton, this._dataWinVoiceOverride, 'select(".win-text-tiletitle")', 'select(".win-voice-textdisplay")');
                }
                this._pendingRefresh = false; // We set pendingRefresh to false when we've refreshed the label

                // Hook "click" event handlers
                this._addClickEventHandlers();

                this._element.appendChild(this._ratingPickerFlyout.element);
                WinJS.Utilities.addClass(this._ratingPickerFlyout.element, XboxJS.UI.RatingPicker._ClassName.ratingPickerOverlay);

                this._showRatingPickerFlyoutBind = function showRatingPickerFlyout(ev) {
                    that._ratingPickerFlyout.show(that._rateButton, "right");
                };

                this._handleKeydownBind = function showRatingPickerFlyout(ev) {
                    if (ev.key === "Enter" ||
                        ev.key === "Spacebar" ||
                        ev.key === "GamepadA") {
                        that._showRatingPickerFlyoutBind();
                    }
                };

                this._afterShowFlyoutBind = function _afterShowFlyout(ev) {
                    // Focus on the median rating
                    var medianRating = that._ratingPickerFlyout.element.querySelectorAll("." + XboxJS.UI.RatingPicker._ClassName.ratingOption)[MEDIAN_RATING_INDEX + 1];
                    setImmediate(function () {
                        if (medianRating &&
                            ratingPickerContainer && !ratingPickerContainer.contains(document.activeElement)) {
                            WinJS.Utilities._trySetActive(medianRating);
                        }
                    });
                };

                this._rateButton.addEventListener("click", this._showRatingPickerFlyoutBind, false);
                this._rateButton.addEventListener("keydown", this._handleKeydownBind, false);
                this._ratingPickerFlyout.addEventListener("aftershow", this._afterShowFlyoutBind, false);
            }, {
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.RatingPicker.element" helpKeyword="XboxJS.UI.RatingPicker.element">
                /// Gets the DOM element that hosts the RatingPicker.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="String" domElement="true" hidden="true" locid="XboxJS.UI.RatingPicker.enableClear" helpKeyword="XboxJS.UI.RatingPicker.enableClear">
                /// Gets or sets whether the control lets the user clear the rating.
                /// </field>
                enableClear: {
                    get: function () {
                        return this._enableClear;
                    },
                    set: function (value) {
                        if (value) {
                            WinJS.Utilities.addClass(this._element, "win-ratingpicker-enableclear");
                        } else {
                            WinJS.Utilities.removeClass(this._element, "win-ratingpicker-enableclear");
                        }
                        this._enableClear = value;
                    }
                },
                /// <field type="String" domElement="true" hidden="true" locid="XboxJS.UI.RatingPicker.label" helpKeyword="XboxJS.UI.RatingPicker.label">
                /// Gets or sets the label associated with the RatingPicker.
                /// </field>
                label: {
                    get: function () {
                        return this._label;
                    },
                    set: function (value) {
                        this._label = value;
                        if (!this._pendingRefresh) {
                            this._rateButton.querySelector(".win-text-tiletitle").innerText = this._label;
                        }
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.RatingPicker.dataWinVoiceOverride" helpKeyword="XboxJS.UI.RatingPicker.dataWinVoiceOverride">
                /// Gets or sets the collection of properties used to voice enable the Rating Picker Label.
                /// </field>
                dataWinVoiceOverride: {
                    get: function () {
                        return this._dataWinVoiceOverride;
                    },
                    set: function (value) {
                        if ((this._dataWinVoiceOverride === value) ||
                            ((this._dataWinVoiceOverride && value) &&
                             (this._dataWinVoiceOverride.pronunciation === value.pronunciation) &&
                             (this._dataWinVoiceOverride.confidence === value.confidence) &&
                             (this._dataWinVoiceOverride.phrase === value.phrase) &&
                             (this._dataWinVoiceOverride.enumerate === value.enumerate))) {
                            return;
                        }

                        this._dataWinVoiceOverride = value;

                        if (XboxJS.UI.Voice && !this._pendingRefresh) {
                            XboxJS.UI.Voice.updateVoiceAttribute(this._rateButton, this._dataWinVoiceOverride, 'select(".win-text-tiletitle")', 'select(".win-voice-textdisplay")');
                            XboxJS.UI.Voice.refreshVoiceElements();
                        }
                    }
                },
                // Add a click handler for a button. This method tracks keeps a list of the handlers so they can be unsubscribed later.
                _addClickEventHandlers: function (button, handler) {

                    var buttons = this._ratingPickerFlyout.element.querySelectorAll("BUTTON");
                    for (var i = 0, len = buttons.length; i < len; i++) {
                        var that = this;
                        var numberOfStars = i;
                        var buttonClickEventSubscription = {
                            button: buttons[i],
                            handler: (function generateHandleItemInvoked(numberOfStars) {
                                return function handleRatingChoiceButtonClick(ev) {
                                    that._handleRatingChosenBind(numberOfStars);

                                    // Note: We stop propagation of the click event. Otherwise, the click event will bubble up to the root
                                    // element and the flyout will show again.
                                    ev.stopPropagation();
                                };
                            })(numberOfStars)
                        }

                        buttons[i].addEventListener("click", buttonClickEventSubscription.handler, false);
                        this._buttonEventSubscriptions.push(buttonClickEventSubscription);
                    }
                },
                _refresh: function () {
                    var tileTitle = this._rateButton.querySelector(".win-text-tiletitle");
                    tileTitle.innerText = this._label;
                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.updateVoiceAttribute(this._rateButton, this._dataWinVoiceOverride, 'select(".win-text-tiletitle")', 'select(".win-voice-textdisplay")');
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }
                    this._pendingRefresh = false;
                },
                _removeClickEventHandlers: function () {

                    if (this._buttonEventSubscriptions) {
                        for (var i = 0; i < this._buttonEventSubscriptions.length; i++) {
                            var button = this._buttonEventSubscriptions[i].button;
                            var handler = this._buttonEventSubscriptions[i].handler;
                            button.removeEventListener("click", handler);
                        }

                        this._buttonEventSubscriptions = [];
                    }
                },
                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.RatingPicker.dispose">
                    /// <summary locid="XboxJS.UI.RatingPicker.dispose">
                    /// Disposes the control.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    // Remove click event handlers
                    this._removeClickEventHandlers();
                    this._buttonEventSubscriptions = null;

                    this._rateButton.removeEventListener("keydown", this._handleKeydownBind);
                    this._handleKeydownBind = null;

                    this._ratingPickerFlyout.removeEventListener("aftershow", this._afterShowFlyoutBind);
                    this._afterShowFlyoutBind = null;

                    this._rateButton.removeEventListener("click", this._showRatingPickerFlyoutBind);
                    this._rateButton.winControl.dispose();
                    this._rateButton = null;

                    this._handleRatingChosenBind = null;

                    this._showRatingPickerFlyoutBind = null;
                    this._ratingPickerFlyout.dispose();
                    this._ratingPickerFlyout = null;

                    this._dataWinVoiceOverride = null;
                    this._label = null;
                    this._rateButton = null;

                    this._element.winControl = null;
                    this._element = null;
                }
            }, {
                // Names of classes used by the RatingPicker.
                _ClassName: {
                    ratingButton: "win-ratingpicker-ratebutton",
                    ratingButtonIcon: "win-icon-rate",
                    ratingFlyoutCenteringGrid: "win-ratingpicker-flyoutcenteringdiv",
                    ratingPicker: "win-ratingpicker",
                    ratingPickerOverlay: "win-ratingpicker-overlay",
                    ratingOption: "win-ratingpicker-ratingoption"
                }
            });
            WinJS.Class.mix(RatingPicker, WinJS.Utilities.createEventProperties(CHANGE));
            WinJS.Class.mix(RatingPicker, WinJS.UI.DOMEventMixin);

            return RatingPicker;
        })
    });

})(this, WinJS);


// ScrollViewer
(function scrollViewerInit(global, WinJS, undefined) {
    "use strict";

    var _delayBeforeCheckingSizeOfScrollableRegion = 500;

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.ScrollMode">
        /// The input behavior for the ScrollViewer.
        /// </summary>
        ScrollMode: {
            /// <field type="String" locid="XboxJS.UI.ScrollMode.text" helpKeyword="XboxJS.UI.ScrollMode.text">
            /// Indicates the ScrollViewer contains text and must be invoked with the A button, then the contents can be scrolled
            /// using directional navigation.
            /// </field>
            text: "text",
            /// <field type="String" locid="XboxJS.UI.ScrollMode.nonModalText" helpKeyword="XboxJS.UI.ScrollMode.nonModalText">
            /// This mode is similar to text mode except the user does not need to press A to begin scrolling. Instead they move
            /// focus to the ScrollViewer and are able to scroll text. This mode should only be used if there are no focusable
            /// UI elements above or below the control.
            /// </field>
            nonModalText: "nonModalText",
            /// <field type="String" locid="XboxJS.UI.ScrollMode.list" helpKeyword="XboxJS.UI.ScrollMode.list">
            /// Indicates the ScrollViewer contains focusable elements and those elements that are off-screen are scrolled into view
            /// when the user selects those elements.
            /// </field>
            list: "list"
        },

        /// <summary locid="XboxJS.UI.ScrollViewer">
        /// Represents a scrollable area that can contain other visible elements.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.ScrollViewer.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.ScrollViewer.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.ScrollViewer" data-win-options="{metadata: {title: 'Title', image: 'image.png'}}"></div>]]></htmlSnippet>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.WinJS.1.0/css/ui-dark.css" shared="true" />
        ScrollViewer: WinJS.Namespace._lazy(function () {
            return WinJS.Class.define(function scrollViewer_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.ScrollViewer">
                /// <summary locid="XboxJS.UI.ScrollViewer.constructor">
                /// Creates a new ScrollViewer.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.ScrollViewer.constructor_p:element">
                /// The DOM element that hosts the ScrollViewer.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.ScrollViewer.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.ScrollViewer" locid="XboxJS.UI.ScrollViewer.constructor_returnValue">
                /// The new ScrollViewer.
                /// </returns>
                /// </signature>

                this._element = element || document.createElement("div");
                options = options || {};
                this._element.winControl = this;

                WinJS.Utilities.addClass(this._element, "win-disposable win-scrollviewer");

                this._disposed = false;
                this._handleKeyDownBind = this._handleKeyDown.bind(this);
                this._handleKeyUpBind = this._handleKeyUp.bind(this);
                this._isActive = false;
                this._previousFocusRoot = null;
                // _scrollMode is initialized later.
                this._scrollMode;
                this._SMALL_SCROLL_AMOUNT = 200;
                this._PERCENTAGE_OF_PAGE_TO_SCROLL = 0.8;
                this._THRESHOLD_TO_SHOW_TOP_ARROW = 50;

                this._scrollDownBySmallAmountBind = this._scrollDownBySmallAmount.bind(this);
                this._scrollUpBySmallAmountBind = this._scrollUpBySmallAmount.bind(this);
                this._scrollDownByLargeAmountBind = this._scrollDownByLargeAmount.bind(this);
                this._scrollUpByLargeAmountBind = this._scrollUpByLargeAmount.bind(this);

                this._scrollingIndicator = document.createElement("div");
                this._scrollingIndicator.className = "win-scrollindicator";

                var getWinJSStringName = XboxJS.UI.Voice.getWinJSStringName;
                this._scrollingIndicator.innerHTML = "<div class='win-overlay-arrowindicators'>" +
                                                     "  <div class='win-overlay-scrollupindicator'></div>" +
                                                     "  <div class='win-overlay-scrolldownindicator'></div>" +
                                                     "</div>" +
                                                     "<div class='win-overlay-voiceindicators'>" +
                                                     "  <div class='win-overlay-voice-command win-overlay-pageupindicator' data-win-voice=\"{" +
                                                     "    phrase: '" + getWinJSStringName('tv/PAGE_UP_COMMAND_VUI_ALM') + "'," +
                                                     "    confidence: '" + getWinJSStringName('tv/PAGE_UP_COMMAND_VUI_CONF') + "'," +
                                                     "    pronunciation: '" + getWinJSStringName('tv/PAGE_UP_COMMAND_VUI_PRON') + "'," +
                                                     "    targetElement: select('this')" +
                                                     "  }\"></div>" +
                                                     "  <div class='win-overlay-voice-command win-overlay-pagedownindicator' data-win-voice='{" +
                                                     "    phrase: \"" + getWinJSStringName('tv/PAGE_DOWN_COMMAND_VUI_ALM') + "\"," +
                                                     "    confidence: \"" + getWinJSStringName('tv/PAGE_DOWN_COMMAND_VUI_CONF') + "\"," +
                                                     "    pronunciation: \"" + getWinJSStringName('tv/PAGE_DOWN_COMMAND_VUI_PRON') + "\"," +
                                                     "    targetElement: select(\"this\")" +
                                                     "  }'></div>" +
                                                     "</div>";

                this._voicePageUpElement = this._scrollingIndicator.querySelector(".win-overlay-pageupindicator");
                this._voicePageUpElement.addEventListener("click", this._scrollUpByLargeAmountBind, false);

                this._voicePageDownElement = this._scrollingIndicator.querySelector(".win-overlay-pagedownindicator");
                this._voicePageDownElement.addEventListener("click", this._scrollDownByLargeAmountBind, false);

                this._scrollingContainer = document.createElement("div");
                this._scrollingContainer.tabIndex = 0;
                WinJS.Utilities.addClass(this._scrollingContainer, "win-scrollviewer-contentelement");

                // Put the contents in a scrolling container
                var child = this._element.firstChild;
                while (child) {
                    var sibling = child.nextSibling;
                    this._scrollingContainer.appendChild(child);
                    child = sibling;
                }

                this._element.appendChild(this._scrollingContainer);
                this._element.appendChild(this._scrollingIndicator);

                // Attach an event listener to the scroll event
                var that = this;
                this._handleScrollBind = function _handleScroll(ev) {
                    if (that._scrollingContainer.scrollTop >= that._THRESHOLD_TO_SHOW_TOP_ARROW) {
                        that._canScrollUp = true;
                    } else {
                        that._canScrollUp = false;
                    }
                    if (that._scrollingContainer.scrollTop >= (that._scrollingContainer.scrollHeight - that._element.clientHeight)) {
                        that._canScrollDown = false;
                    } else {
                        that._canScrollDown = true;
                    }

                    // Note: We remove the classes in order so we can avoid labels flashing
                    if (!that._canScrollUp &&
                        !that._canScrollDown) {
                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-down");
                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-up");

                        WinJS.Utilities.addClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.addClass(that._voicePageDownElement, "win-voice-disableoverride");
                    } else if (!that._canScrollUp &&
                        that._canScrollDown) {
                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");

                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-up");
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-down");

                        WinJS.Utilities.addClass(that._voicePageUpElement, "win-voice-disabledlabel");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disabledlabel");
                    } else if (that._canScrollUp &&
                        !that._canScrollDown) {
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-up");
                        WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-down");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disabledlabel");
                        WinJS.Utilities.addClass(that._voicePageDownElement, "win-voice-disabledlabel");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");
                    } else {
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-up");
                        WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-down");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disabledlabel");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disabledlabel");

                        WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                        WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");
                    }

                    // Refresh voice elements
                    XboxJS.UI.Voice.refreshVoiceElements();
                };

                // If focus leaves the ScrollViewer & it was in the "invoked" state,
                // we need to reset it's state.
                this._handleFocusOutBind = function _handleFocusOut(ev) {
                    if (that._isActive &&
                        !that._element.contains(document.activeElement)) {
                        WinJS.Utilities.removeClass(that._element, "win-active");
                        that._setInactive();
                    }
                };

                this._scrollingContainer.addEventListener("scroll", this._handleScrollBind, false);
                this._handleFocusBind = this._handleFocus.bind(this);
                this._scrollingContainer.addEventListener("focus", this._handleFocusBind, false);
                this._element.addEventListener("focusout", this._handleFocusOutBind, false);

                if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.ScrollViewer._sounds.initialized) {
                    XboxJS.UI.ScrollViewer._sounds.selectButtonClick = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///SelectButtonClick"));
                    XboxJS.UI.ScrollViewer._sounds.initialized = true;
                }

                // Set the default scroll mode
                this.scrollMode = XboxJS.UI.ScrollMode.text;
                WinJS.UI.setOptions(this, options);

                this._refreshVisuals();

                // The scroll viewer has two interaction modes:
                //   1. Normal - In this state there is focusable content within the scrollable
                //      region. Automatic focus handles directional navigation and scrolls
                //      elements into view. 
                //   2. Text - In this state there is no focusable content within the scrollable
                //      region. Typically, this case is free text. In this case, the ScrollViewer
                //      handles directional navigation and scrolls up and down.
                //
                //   To determine which mode we are in, we look for focusable content. If there
                //   is no focusable content, then we know we are in "Text" mode.

                // We need to wait for processAll to finish on the inner contents of the scrollable region, because we need accurate 
                // sizing information to determine if a region is scrollable or not.
                WinJS.Promise.timeout(_delayBeforeCheckingSizeOfScrollableRegion)
                    .then(function afterSetImmediate() {
                        if (!that._element ||
                            that._disposed) {
                            return;
                        }

                        that._refreshVisuals();
                    });
            }, {
                _handleFocus: function () {
                    if (this._scrollMode === XboxJS.UI.ScrollMode.nonModalText) {
                        this._setActive();
                    }
                },
                _setActive: function () {
                    this._isActive = true;
                    WinJS.Utilities.addClass(this._element, "win-active");

                    // We turn off automatic focus, otherwise automatic focus
                    // will eat the key events and we will not be able to scroll
                    // the scrollable region.
                    if (XboxJS.UI.AutomaticFocus.focusRoot) {
                        this._previousFocusRoot = XboxJS.UI.AutomaticFocus.focusRoot;
                        XboxJS.UI.AutomaticFocus.focusRoot = null;
                    }
                },
                _setInactive: function () {
                    if (this._isActive) {
                        WinJS.Utilities.removeClass(this._element, "win-active");
                        if (this._previousFocusRoot) {
                            XboxJS.UI.AutomaticFocus.focusRoot = this._previousFocusRoot;
                        }

                        this._isActive = false;
                    }
                },
                _handleKeyDown: function scrollViewer_handleKeyDown(ev) {
                    if (!this._scrollMode) {
                        return;
                    }

                    var key = ev.key;
                    
                    // Only set handled = true for shoulder button cases so that 
                    // scroll viewer doesn't trigger a hub interaction.
                    var handled = false;
                    
                    switch (key) {
                        case "GamepadDPadUp":
                        case "GamepadLeftThumbstickUp":
                            if (this._scrollMode === XboxJS.UI.ScrollMode.nonModalText) {
                                if (this._scrollingContainer.scrollTop >= this._THRESHOLD_TO_SHOW_TOP_ARROW) {
                                    // No-op - the user can scroll up.
                                } else {
                                    // Set the focusRoot to the previousFocusRoot to handle the case where the developer has specified a
                                    // focusRoot. For instance, if there's a ScrollViewer hosted in a modal dialog where the focusRoot has been
                                    // restricted to the modal dialog). We need to set the focusRoot to the _previousFocusRoot before calling
                                    // findNextFocusElement otherwise in the example of the modal dialog, we could end up setting focus outside
                                    // the modal dialog when the user moves focus up.
                                    if (this._previousFocusRoot) {
                                        XboxJS.UI.AutomaticFocus.focusRoot = this._previousFocusRoot;
                                    }
                                    var nextFocusElement = XboxJS.UI.AutomaticFocus.findNextFocusElement(WinJS.Utilities.Key.gamepadDPadUp);
                                    XboxJS.UI.AutomaticFocus.focusRoot = null;
                                    if (nextFocusElement) {
                                        nextFocusElement.focus();
                                    }
                                }
                            }
                            this._scrollUpBySmallAmount();
                            break;
                        case "GamepadDPadDown":
                        case "GamepadLeftThumbstickDown":
                            if (this._scrollMode === XboxJS.UI.ScrollMode.nonModalText) {
                                if (this._scrollingContainer.scrollTop >= (this._scrollingContainer.scrollHeight - this._element.clientHeight)) {
                                    // For more information on the following code see the comment in the above case statement for up movement.
                                    if (this._previousFocusRoot) {
                                        XboxJS.UI.AutomaticFocus.focusRoot = this._previousFocusRoot;
                                    }
                                    var nextFocusElement = XboxJS.UI.AutomaticFocus.findNextFocusElement(WinJS.Utilities.Key.gamepadDPadDown);
                                    XboxJS.UI.AutomaticFocus.focusRoot = null;
                                    if (nextFocusElement) {
                                        nextFocusElement.focus();
                                    }
                                } else {
                                    // No-op - the user can scroll down
                                }
                            }
                            this._scrollDownBySmallAmount();
                            break;
                        case "GamepadDPadLeft":
                        case "GamepadLeftThumbstickLeft":
                        case "GamepadDPadRight":
                        case "GamepadLeftThumbstickRight":
                            // If we successfully move focus to a new target element, then set the ScrollViewer as inactive
                            if (this._isActive) {
                                if (this._previousFocusRoot) {
                                    XboxJS.UI.AutomaticFocus.focusRoot = this._previousFocusRoot;
                                    var previousFocusRectangleObject = this._scrollingContainer.getBoundingClientRect();
                                    var previousFocusRectangle = {
                                        top: previousFocusRectangleObject.top,
                                        left: previousFocusRectangleObject.left,
                                        width: previousFocusRectangleObject.width,
                                        height: previousFocusRectangleObject.height
                                    };

                                    var nextFocusElement = XboxJS.UI.AutomaticFocus.findNextFocusElement(key, previousFocusRectangle);
                                    var wasEventCanceled = XboxJS.UI.AutomaticFocus.dispatchEvent("focuschanging", { nextFocusElement: nextFocusElement, keyCode: key });
                                    if (nextFocusElement &&
                                        !wasEventCanceled) {
                                        nextFocusElement.focus();
                                        this._setInactive();
                                        // Choose one of the 4 focus sounds to play at random
                                        var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                                        switch (indexOfFocusSoundToPlay) {
                                            case 1:
                                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus1) {
                                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus1.play();
                                                }
                                                break;
                                            case 2:
                                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus2) {
                                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus2.play();
                                                }
                                                break;
                                            case 3:
                                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus3) {
                                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus3.play();
                                                }
                                                break;
                                            case 4:
                                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus4) {
                                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus4.play();
                                                }
                                                break;
                                            default:
                                                if (XboxJS.UI.AutomaticFocus._sounds.elementFocus1) {
                                                    XboxJS.UI.AutomaticFocus._sounds.elementFocus1.play();
                                                }
                                                break;
                                        }
                                    }
                                }
                            }
                            break;
                        case "GamepadLeftShoulder":
                            this._scrollUpByLargeAmount();
                            handled = true;
                            break;
                        case "GamepadRightShoulder":
                            this._scrollDownByLargeAmount();
                            handled = true;
                            break;
                        case "GamepadMenu":
                            // Restore focus if the AppBar is invoked, while focus
                            // is in the scrollViewer
                            if (this._scrollMode &&
                                this._isActive &&
                                this._previousFocusRoot) {
                                XboxJS.UI.AutomaticFocus.focusRoot = this._previousFocusRoot;
                            }
                            break;
                        default:
                            break;
                    }
                    
                    if (handled) {
                        ev.stopPropagation();
                    }
                },
                _handleKeyUp: function scrollViewer_handleKeyUp(ev) {
                    if (this._scrollMode !== XboxJS.UI.ScrollMode.text) {
                        return;
                    }

                    var key = ev.key;
                    switch (key) {
                        case "GamepadA":
                        case "Enter":
                            this._setActive();
                            if (XboxJS.UI.ScrollViewer._sounds.selectButtonClick) {
                                XboxJS.UI.ScrollViewer._sounds.selectButtonClick.play();
                            }
                            break;
                        case "GamepadB":
                        case "Esc":
                            if (this._isActive) {
                                ev.stopPropagation();
                            }
                            this._setInactive();
                            break;
                        default:
                            break;
                    }
                },
                // We call this function any time the size of the contents within the ScrollViewer changes. This function
                // determines if we need to display the visual treatment for "more content".
                _refreshVisuals: function () {
                    var that = this;
                    setImmediate(function afterDOMProcessing() {
                        if (that._disposed) {
                            return;
                        }

                        // Set initial visibility for the arrow indicators if the contents of the scrollable region
                        // is bigger than the viewable area.
                        if (that._scrollingContainer.clientHeight < that._scrollingContainer.scrollHeight) {
                            if (that._scrollingContainer.scrollTop > 0) {
                                that._canScrollUp = true;
                            } else {
                                that._canScrollUp = false;
                            }
                            if (that._scrollingContainer.scrollTop >= (that._scrollingContainer.scrollHeight - that._element.clientHeight)) {
                                that._canScrollDown = false;
                            } else {
                                that._canScrollDown = true;
                            }

                            if (!that._canScrollUp &&
                                !that._canScrollDown) {
                                WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-down");
                                WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-up");

                                WinJS.Utilities.addClass(that._voicePageUpElement, "win-voice-disableoverride");
                                WinJS.Utilities.addClass(that._voicePageDownElement, "win-voice-disableoverride");
                            } else if (!that._canScrollUp &&
                                that._canScrollDown) {
                                WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                                WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");

                                WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-up");
                                WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-down");

                                WinJS.Utilities.addClass(that._voicePageUpElement, "win-voice-disabledlabel");
                                WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disabledlabel");
                            } else if (that._canScrollUp &&
                                !that._canScrollDown) {
                                WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                                WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");

                                WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-up");
                                WinJS.Utilities.removeClass(that._scrollingIndicator, "win-scrollable-down");

                                WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disabledlabel");
                                WinJS.Utilities.addClass(that._voicePageDownElement, "win-voice-disabledlabel");
                            } else {
                                WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disableoverride");
                                WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disableoverride");

                                WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-down");
                                WinJS.Utilities.addClass(that._scrollingIndicator, "win-scrollable-up");

                                WinJS.Utilities.removeClass(that._voicePageUpElement, "win-voice-disabledlabel");
                                WinJS.Utilities.removeClass(that._voicePageDownElement, "win-voice-disabledlabel");
                            }

                            // Refresh voice elements
                            XboxJS.UI.Voice.refreshVoiceElements();

                            // We only make the ScrollViewer focusable if it has text content and the
                            // text content does not fit on the screen. If the text content does fit
                            // on the screen then there is no reason to make the user scroll because
                            // they can see all of the text.
                            if (that._scrollMode === XboxJS.UI.ScrollMode.text ||
                                that._scrollMode === XboxJS.UI.ScrollMode.nonModalText) {
                                WinJS.Utilities.addClass(that._scrollingContainer, "win-focusable");
                            }

                            // Add a class to indicate that the content within the ScrollViewer is bigger than
                            // the visible area which means the ScrollViewer will need to be able to Scroll.
                            WinJS.Utilities.addClass(that._element, "win-scrollable");
                        } else {
                            WinJS.Utilities.removeClass(that._element, "win-scrollable");
                            WinJS.Utilities.addClass(that._voicePageUpElement, "win-voice-disableoverride");
                            WinJS.Utilities.addClass(that._voicePageDownElement, "win-voice-disableoverride");
                        }
                    });
                },
                _scrollDownBySmallAmount: function scrollViewer_scrollDownSmallAmount() {
                    if (this._isActive &&
                        this._scrollingContainer.msZoomTo) {
                        this._scrollingContainer.msZoomTo({ contentX: 0, contentY: this._scrollingContainer.scrollTop + this._SMALL_SCROLL_AMOUNT, viewportX: 0, viewportY: 0 });
                    }
                },
                _scrollUpBySmallAmount: function scrollViewer_scrollUpSmallAmount() {
                    if (this._isActive &&
                        this._scrollingContainer.msZoomTo) {
                        this._scrollingContainer.msZoomTo({ contentX: 0, contentY: this._scrollingContainer.scrollTop - this._SMALL_SCROLL_AMOUNT, viewportX: 0, viewportY: 0 });
                    }
                },
                _scrollDownByLargeAmount: function scrollViewer_scrollDownSmallAmount() {
                    // The second part of the if clause checks if voice is engaged
                    if ((this._isActive || XboxJS.Utilities._isVoiceEngaged) &&
                        this._scrollingContainer.msZoomTo) {
                        this._scrollingContainer.msZoomTo({ contentX: 0, contentY: this._scrollingContainer.scrollTop + (this._PERCENTAGE_OF_PAGE_TO_SCROLL * this._scrollingContainer.clientHeight), viewportX: 0, viewportY: 0 });
                    }
                },
                _scrollUpByLargeAmount: function scrollViewer_scrollUpSmallAmount() {
                    // The second part of the if clause checks if voice is engaged
                    if ((this._isActive || XboxJS.Utilities._isVoiceEngaged) &&
                        this._scrollingContainer.msZoomTo) {
                        this._scrollingContainer.msZoomTo({ contentX: 0, contentY: this._scrollingContainer.scrollTop - (this._PERCENTAGE_OF_PAGE_TO_SCROLL * this._scrollingContainer.clientHeight), viewportX: 0, viewportY: 0 });
                    }
                },
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.ScrollViewer.element" helpKeyword="XboxJS.UI.ScrollViewer.element">
                /// Gets the DOM element that hosts the ScrollViewer.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="String" locid="XboxJS.UI.ScrollViewer.interactionMode" helpKeyword="XboxJS.UI.ScrollViewer.interactionMode">
                /// Gets or sets a property that indicates whether there are focusable elements within the ScrollViewer. The default value is false.
                /// </field>
                scrollMode: {
                    get: function () {
                        return this._scrollMode;
                    },
                    set: function (value) {
                        this._scrollMode = value;

                        // If there are no focusable elements then we need to listen for the A button.
                        if (this._scrollMode === XboxJS.UI.ScrollMode.list) {
                            WinJS.Utilities.removeClass(this._element, "win-scrollviewer-scrollmode-text");
                            WinJS.Utilities.addClass(this._element, "win-scrollviewer-scrollmode-list");
                            this._element.removeEventListener("keydown", this._handleKeyDownBind, true);
                            this._element.removeEventListener("keyup", this._handleKeyUpBind, true);
                        } else {
                            WinJS.Utilities.removeClass(this._element, "win-scrollviewer-scrollmode-list");
                            WinJS.Utilities.addClass(this._element, "win-scrollviewer-scrollmode-text");
                            this._element.addEventListener("keydown", this._handleKeyDownBind, true);
                            this._element.addEventListener("keyup", this._handleKeyUpBind, true);
                        }
                    }
                },
                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.ScrollViewer.dispose">
                    /// <summary locid="XboxJS.UI.ScrollViewer.dispose">
                    /// Disposes the control.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    this._scrollingContainer.removeEventListener("scroll", this._handleScrollBind);
                    this._scrollingContainer.removeEventListener("focus", this._handleFocusBind);
                    this._element.removeEventListener("focusout", this._handleFocusOutBind);
                    this._element.removeEventListener("keydown", this._handleKeyDownBind);
                    this._element.removeEventListener("keyup", this._handleKeyUpBind);
                    this._voicePageUpElement.removeEventListener("click", this._scrollUpByLargeAmountBind);
                    this._voicePageDownElement.removeEventListener("click", this._scrollDownByLargeAmountBind);
                    this._handleScrollBind = null;
                    this._handleFocusBind = null;
                    this._handleFocusOutBind = null;
                    this._handleKeyDownBind = null;
                    this._handleKeyUpBind = null;
                    this._scrollDownBySmallAmountBind = null;
                    this._scrollUpBySmallAmountBind = null;
                    this._scrollDownByLargeAmountBind = null;
                    this._scrollUpByLargeAmountBind = null;

                    if (!XboxJS.UI.AutomaticFocus.focusRoot && this._previousFocusRoot) {
                        XboxJS.UI.AutomaticFocus.focusRoot = this._previousFocusRoot;
                    }
                    this._previousFocusRoot = null;

                    WinJS.Utilities.disposeSubTree(this.element);

                    this._moreUpArrow = null;
                    this._moreDownArrow = null;
                    this._contentElement = null;
                    this._scrollingContainer = null;
                    this._scrollingIndicator = null;
                    this._scrollMode = null;
                    this._voicePageUpElement = null;
                    this._voicePageDownElement = null;

                    this._SMALL_SCROLL_AMOUNT = null;
                    this._PERCENTAGE_OF_PAGE_TO_SCROLL = null;
                    this._THRESHOLD_TO_SHOW_TOP_ARROW = null;

                    this._element.winControl = null;
                    this._element = null;
                },
                refresh: function scrollViewer_refresh() {
                    /// <signature helpKeyword="XboxJS.UI.ScrollViewer.refresh">
                    /// <summary locid="XboxJS.UI.ScrollViewer.refresh">
                    /// Call this function whenever the contents of the ScrollViewer changes.
                    /// </summary>
                    /// </signature>
                    this._refreshVisuals();
                }
            }, {
                _sounds: {
                    initialized: false,
                    selectButtonClick: null,
                }
            });
        })
    })
})(this, WinJS);


(function tabInit(global, WinJS, undefined) {
    "use strict";

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.Tab">
        /// Tab is single group of content for a TabView.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.Tab.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.Tab.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.Tab" data-win-options="{header: 'Tab Header'}">Tab Content</div>]]></htmlSnippet>
        /// <part name="tabsection" class="win-tabview-tab" locid="XboxJS.UI.Tab_part:tabsection">The entire Tab control.</part>
        /// <part name="header" class="win-tabview-tab-header" locid="XboxJS.UI.Tab_part:header">The header region of the Tab.</part>
        /// <part name="headertabstop" class="win-tabview-tab-tabstop" locid="XboxJS.UI.Tab_part:headertabstop">The tab stop region of the header region of the Tab.</part>
        /// <part name="headercontent" class="win-tabview-tab-header-content" locid="XboxJS.UI.Tab_part:headercontent">The content region of the header region of the Tab.</part>
        /// <part name="headerchevron" class="win-tabview-tab-header-chevron" locid="XboxJS.UI.Tab_part:headerchevron">The chevron region of the header region of the Tab.</part>
        /// <part name="content" class="win-tabview-tab-content" locid="XboxJS.UI.Tab_part:content">The content region of the Tab.</part>
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.WinJS.1.0/css/ui-dark.css" shared="true" />
        Tab: WinJS.Namespace._lazy(function () {
            var strings = {
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; }
            };

            return WinJS.Class.define(function Tab_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.Tab">
                /// <summary locid="XboxJS.UI.Tab.constructor">
                /// Creates a new Tab.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.Tab.constructor_p:element">
                /// The DOM element that hosts the Tab control.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.Tab.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.Tab" locid="XboxJS.UI.Tab.constructor_returnValue">
                /// The new Tab.
                /// </returns>
                /// </signature>
                element = element || document.createElement("DIV");
                options = options || {};

                if (element.winControl) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.Tab.DuplicateConstruction", strings.duplicateConstruction);
                }

                // Attaching JS control to DOM element
                element.winControl = this;
                this._element = element;
                WinJS.Utilities.addClass(this.element, XboxJS.UI.Tab._ClassName.tabSection);
                WinJS.Utilities.addClass(this.element, "win-disposable");

                // Not using innerHTML here because there could have been some children already.
                this._headerElement = document.createElement("DIV");
                this._headerElement.className = XboxJS.UI.Tab._ClassName.tabSectionHeader;
                this._headerElement.innerHTML =
                    '<button type="button" role="link" class="' + XboxJS.UI.Tab._ClassName.tabSectionInteractive + ' ' + XboxJS.UI.Tab._ClassName.tabSectionHeaderTabStop + '">' +
                        '<span class="' + XboxJS.UI.Tab._ClassName.tabSectionHeaderContent + ' ' + XboxJS.UI.Tab._Constants.ellipsisTypeClassName + ' ' + XboxJS.UI.Tab._Constants.xLargeTypeClassName + '"></span>' +
                        '<span class="' + XboxJS.UI.Tab._ClassName.tabSectionHeaderChevron + ' ' + XboxJS.UI.Tab._Constants.ellipsisTypeClassName + ' ' + XboxJS.UI.Tab._Constants.xLargeTypeClassName + '"></span>' +
                    '</button>';
                this._headerTabStopElement = this._headerElement.firstElementChild;
                this._headerContentElement = this._headerTabStopElement.firstElementChild;
                this._headerChevronElement = this._headerTabStopElement.lastElementChild;
                element.appendChild(this._headerElement);

                this._contentElement = document.createElement("DIV");
                this._contentElement.className = XboxJS.UI.Tab._ClassName.tabSectionContent;
                element.appendChild(this._contentElement);

                // Re-parent any existing elements inside the new tab content element.
                var elementToMove = this.element.firstChild;
                while (elementToMove !== this._headerElement) {
                    var nextElement = elementToMove.nextSibling;
                    this._contentElement.appendChild(elementToMove);
                    elementToMove = nextElement;
                }

                this._dataWinVoiceOverride = null;

                WinJS.UI.setOptions(this, options);
            }, {
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.Tab.element" helpKeyword="XboxJS.UI.Tab.element">
                /// Gets the DOM element that hosts the Tab.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.Tab.header" helpKeyword="XboxJS.UI.Tab.header">
                /// Get or set the object which represents the Tab's header. When it is set the Tab renders the header again.
                /// </field>
                header: {
                    get: function () {
                        return this._header;
                    },
                    set: function (value) {
                        // Render again even if it is equal to itself.
                        this._header = value;
                        this._renderHeader();
                    }
                },
                _setHeaderTemplate: function Tab_setHeaderTemplate(template) {
                    this._template = template;
                    this._renderHeader();
                },
                _renderHeader: function Tab_renderHeader(voiceOnly) {
                    if (this._template) {
                        if (!voiceOnly) {
                            WinJS.Utilities._disposeElement(this._headerContentElement);
                            this._headerContentElement.innerHTML = "";
                            if (this._template.render) {
                                this._template.render(this, this._headerContentElement);
                            } else if (this._template.winControl && this._template.winControl.render) {
                                this._template.winControl.render(this, this._headerContentElement);
                            } else {
                                var developerHeaderElement = this._template(this);
                                this._headerContentElement.appendChild(developerHeaderElement);
                            }
                        }

                        if (XboxJS.UI.Voice) {
                            XboxJS.UI.Voice.updateVoiceAttribute(this._headerElement, this._dataWinVoiceOverride, 'select(\".win-tabview-tab-header-content\")');
                            XboxJS.UI.Voice.refreshVoiceElements();
                        }
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.Tab.dataWinVoiceOverride" helpKeyword="XboxJS.UI.Tab.dataWinVoiceOverride">
                /// Get or set the object which represents the overrides for data-win-voice options for the Tab. When it is set the Tab renders the header again.
                /// </field>
                dataWinVoiceOverride: {
                    get: function () {
                        return this._dataWinVoiceOverride;
                    },
                    set: function (value) {
                        if ((this._dataWinVoiceOverride === value) ||
                            ((this._dataWinVoiceOverride && value) &&
                             (this._dataWinVoiceOverride.pronunciation === value.pronunciation) &&
                             (this._dataWinVoiceOverride.confidence === value.confidence) &&
                             (this._dataWinVoiceOverride.phrase === value.phrase) &&
                             (this._dataWinVoiceOverride.enumerate === value.enumerate))) {
                            return;
                        }

                        this._dataWinVoiceOverride = value;

                        this._renderHeader(true);
                    }
                },
                dispose: function Tab_dispose() {
                    /// <signature helpKeyword="XboxJS.UI.Tab.dispose">
                    /// <summary locid="XboxJS.UI.Tab.dispose">
                    /// Disposes this control.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }

                    this._dataWinVoiceOverride = null;

                    this._disposed = true;

                    WinJS.Utilities._disposeElement(this._headerContentElement);
                    WinJS.Utilities.disposeSubTree(this._contentElement);
                }
            }, {
                // Names of classes used by the Tab control.
                _ClassName: {
                    tabSection: "win-tabview-tab",
                    tabSectionHeader: "win-tabview-tab-header",
                    tabSectionHeaderTabStop: "win-tabview-tab-tabstop",
                    tabSectionHidden: "win-tab-currentselected",
                    tabSectionInteractive: "win-tabview-tab-header-interactive",
                    tabSectionHeaderContent: "win-tabview-tab-header-content",
                    tabSectionHeaderChevron: "win-tabview-tab-header-chevron",
                    tabSectionContent: "win-tabview-tab-content"
                },
                _Constants: {
                    ellipsisTypeClassName: "win-type-ellipsis",
                    xLargeTypeClassName: "win-type-x-large"
                },
                isDeclarativeControlContainer: true
            });
        })
    });

})(this, WinJS);
(function tabViewInit(global, WinJS, undefined) {
    "use strict";

    function tabDefaultHeaderTemplate(tab) {
        var element = document.createTextNode(typeof tab.header === "object" ? JSON.stringify(tab.header) : ('' + tab.header));
        return element;
    }

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.TabView">
        /// Displays tabs of content.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.tabview.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.tabview.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.TabView">
        /// <div data-win-control="XboxJS.UI.Tab" data-win-options="{header: 'tab Header'}">Tab Content</div>
        /// </div>]]></htmlSnippet>
        /// <event name="contentanimating" bubbles="true" locid="XboxJS.UI.TabView_e:contentanimating">Raised when the TabView is about to play an entrance or a transition animation.</event>
        /// <part name="tabView" class="win-tabview" locid="XboxJS.UI.TabView_part:tabview">The entire TabView.</part>
        /// <part name="viewport" class="win-tab-viewport" locid="XboxJS.UI.TabView_part:viewport">The viewport of the Tab Control. </part>
        /// <part name="surface" class="win-tab-surface" locid="XboxJS.UI.TabView_part:surface">The scrollable region of the Tab Control.</part>
        /// <resource type="javascript" src="//Microsoft.WinJS.Preview.1/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.WinJS.Preview.1/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.WinJS.Preview.1/css/ui-dark.css" shared="true" />
        TabView: WinJS.Namespace._lazy(function () {
            var strings = {
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; },
                get duplicateSection() { return WinJS.Resources._getWinJSString("ui/duplicateSection").value; },
                get indexOutOfRange() { return WinJS.Resources._getWinJSString("ui/indexOutOfRange").value; },
                get invalidContent() { return WinJS.Resources._getWinJSString("ui/invalidHubContent").value; }
            };

            var TabView = WinJS.Class.define(function TabView_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.TabView.TabView">
                /// <summary locid="XboxJS.UI.TabView.constructor">
                /// Creates a new Tab Control.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.TabView.constructor_p:element">
                /// The DOM element that hosts the TabView control.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.TabView.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// Event names must begin with "on". For example, to provide a handler for the contentanimating event,
                /// add a property named "oncontentanimating" to the options object and set its value to the event handler.
                /// </param>
                /// <returns type="XboxJS.UI.TabView" locid="XboxJS.UI.TabView.constructor_returnValue">
                /// The new TabView.
                /// </returns>
                /// </signature>

                this._currentTab = -1;
                this._isFocusInHeaders = false;
                this._isPointerDown = false;
                this._tabsList = [];

                element = element || document.createElement("DIV");
                options = options || {};

                if (element.winControl) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.TabView.DuplicateConstruction", strings.duplicateConstruction);
                }

                // Attaching JS control to DOM element
                element.winControl = this;
                this._element = element;
                WinJS.Utilities.addClass(this.element, XboxJS.UI.TabView._ClassName.tab);
                WinJS.Utilities.addClass(this.element, "win-disposable");

                this._viewportElement = document.createElement("DIV");
                this._viewportElement.className = XboxJS.UI.TabView._ClassName.tabViewport;
                this._element.appendChild(this._viewportElement);

                this._surfaceElement = document.createElement("DIV");
                this._surfaceElement.className = XboxJS.UI.TabView._ClassName.tabSurface;
                this._viewportElement.appendChild(this._surfaceElement);

                this._tabHeaders = document.createElement("DIV");
                this._tabHeaders.className = "win-tabs-container";
                this._viewportElement.insertBefore(this._tabHeaders, this._viewportElement.firstChild);

                // Start invisible so that you do not see the content loading until the tabs are ready.
                this._visible = false;
                this._viewportElement.style.opacity = 0;

                this._fireEntrance = true;
                this._animateEntrance = true;
                this._loadId = 0;
                this._isPlayingTabTransitionAnimation = false;
                this._pendingCurrentTab = -1;
                this.runningAnimations = new WinJS.Promise.wrap();
                this._currentIndexForSezo = 0;

                // Animation constants            
                this._currentTabEntranceAnimationDelay = 100;
                this._currentTabEntranceAnimationDuration = 340;
                this._tabEaseInAnimationCurve = "cubic-bezier(0.1, 0.9, 0.2, 1)";
                this._oldTabExitAnimationDelay = 0;
                this._tabDefaultLeftPostion = "0px";

                // This internally assigns to this.tabs which causes tabs to be used.
                this._parse();

                WinJS.UI.setOptions(this, options);

                if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.TabView._sounds.initialized) {
                    XboxJS.UI.TabView._sounds.pageTransitionR = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///PageTransitionRight"));
                    XboxJS.UI.TabView._sounds.pageTransitionL = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///PageTransitionLeft"));
                    XboxJS.UI.TabView._sounds.initialized = true;
                }

                // Focus does not bubble up to window but it does run through the capture phase.
                this._tabHeaders.addEventListener("focusin", this._tabHeadersFocusIn.bind(this), true);
                this._tabHeaders.addEventListener("focusout", this._tabHeadersFocusOut.bind(this), true);

                if (XboxJS.UI.AutomaticFocus) {
                    this._handleFocusChangingBind = this._handleFocusChanging.bind(this);
                    XboxJS.UI.AutomaticFocus.addEventListener("focuschanging", this._handleFocusChangingBind, false);
                }

                this.element.addEventListener("keydown", this._handleKeydown.bind(this), false);

                this.element.addEventListener("MSPointerDown", this._MSPointerDown.bind(this));
                this.element.addEventListener("click", this._clickHandler.bind(this));

                this._handleTabChangedBind = this._handleTabChanged.bind(this);
                this._handleTabInsertedBind = this._handleTabInserted.bind(this);
                this._handleTabMovedBind = this._handleTabMoved.bind(this);
                this._handleTabRemovedBind = this._handleTabRemoved.bind(this);
                this._handleTabReloadBind = this._handleTabReload.bind(this);

                this._refresh();
            }, {
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.TabView.element" helpKeyword="XboxJS.UI.TabView.element">
                /// Gets the DOM element that hosts the TabView.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="HTMLElement" hidden="true" locid="XboxJS.UI.TabView.tabs" helpKeyword="XboxJS.UI.TabView.tabs">
                /// Gets or sets the collection of tabs in the TabView.
                /// </field>
                tabs: {
                    get: function () {
                        if (this._pendingTabs) {
                            return this._pendingTabs;
                        }
                        return this._tabs;
                    },
                    set: function (value) {
                        this._pendingTabs = value;
                        this._refresh();
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.TabView.headerTemplate" helpKeyword="XboxJS.UI.TabView.headerTemplate" potentialValueSelector="[data-win-control='WinJS.Binding.Template']">
                /// Gets or sets the template function that creates the DOM elements
                /// which represent the header for each Tab. Each header can
                /// contain multiple DOM elements, but we recommend that it have a single
                /// root element.
                /// </field>
                headerTemplate: {
                    get: function () {
                        if (this._pendingHeaderTemplate) {
                            return this._pendingHeaderTemplate;
                        }

                        if (!this._headerTemplate) {
                            this._headerTemplate = tabDefaultHeaderTemplate;
                        }

                        return this._headerTemplate;
                    },
                    set: function (value) {
                        this._pendingHeaderTemplate = value || tabDefaultHeaderTemplate;
                        this._refresh();
                    }
                },
                _refresh: function tabView_refresh() {
                    if (this._pendingRefresh) {
                        return;
                    }

                    this._loadId++;
                    this._setState(XboxJS.UI.TabView.LoadingState.loading);
                    // This is to coalesce property setting operations such as tabs.
                    this._pendingRefresh = true;
                    WinJS.Promise.timeout().done(this._refreshImpl.bind(this));

                },
                _refreshImpl: function tabView_refreshImpl() {
                    if (this._disposed) {
                        return;
                    }

                    var fadeOutAnimation = WinJS.Promise.wrap();
                    if (this._pendingTabs) {
                        this._animateEntrance = true;
                        this._fireEntrance = !this._visible;
                        if (!this._fireEntrance) {
                            this._visible = false;
                            this._viewportElement.style.opacity = 0;

                            if (WinJS.UI.isAnimationEnabled()) {
                                var animateTransition = this._fireEvent(XboxJS.UI.TabView._EventName.contentAnimating, {
                                    type: XboxJS.UI.TabView.AnimationType.contentTransition
                                });

                                if (animateTransition) {
                                    this._viewportElement.style["-ms-overflow-style"] = "none";
                                    fadeOutAnimation = WinJS.UI.Animation.fadeOut(this._viewportElement).then(function () {
                                        if (this._viewportElement) {
                                            this._viewportElement.style["-ms-overflow-style"] = "";
                                        }
                                    }.bind(this));
                                }
                                this._animateEntrance = animateTransition;
                            }
                        }
                    }

                    fadeOutAnimation.done(this._applyProperties.bind(this));
                },
                _applyProperties: function tabView_applyProperties() {
                    this._pendingRefresh = false;

                    var needsToLoadTabs = false;
                    if (this._pendingTabs) {
                        needsToLoadTabs = true;
                        this._updateEvents(this._tabs, this._pendingTabs);
                        this._tabs = this._pendingTabs;
                        this._pendingTabs = null;
                        WinJS.Utilities.empty(this._surfaceElement);
                    }

                    if (this._pendingHeaderTemplate) {
                        this._headerTemplate = this._pendingHeaderTemplate;
                        this._pendingHeaderTemplate = null;
                    }

                    this._assignHeaderTemplate();

                    if (needsToLoadTabs) {
                        this._attachTabs();
                    }

                    // Using current (or new) scroll location load the tabs
                    this._loadTabs();
                },
                _handleTabChanged: function tabView_handleTabChanged(ev) {
                    // Change is triggered by binding list setAt() API.
                    if (this._pendingTabs) {
                        return;
                    }

                    var newTab = ev.detail.newValue;
                    var oldTab = ev.detail.oldValue;
                    newTab._setHeaderTemplate(this.headerTemplate);
                    if (newTab.element !== oldTab.element) {
                        if (newTab.element.parentNode === this._surfaceElement) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.TabView.DuplicateSection", strings.duplicateSection);
                        }

                        this._surfaceElement.insertBefore(newTab.element, oldTab.element);
                        this._surfaceElement.removeChild(oldTab.element);

                        var newTabHeader = newTab.element.querySelector(".win-tabview-tab-header");
                        var oldTabHeader = this._tabsList[ev.detail.index];

                        if (newTabHeader) {
                            this._tabHeaders.insertBefore(newTabHeader, oldTabHeader);
                        }

                        this._tabHeaders.removeChild(oldTabHeader);

                        // We need to remove the old header from our internal headers list as well
                        this._tabsList.splice(ev.detail.index, 1);

                        this._loadTabs();
                    }
                },
                _handleTabInserted: function tabView_handleTabInserted(ev) {
                    // Insert is triggered by binding list insert APIs such as splice(), push(), and unshift().
                    if (this._pendingTabs) {
                        return;
                    }

                    var index = ev.detail.index;
                    var tab = ev.detail.value;

                    if (tab._animation) {
                        tab._animation.cancel();
                    }

                    var animation;
                    var result = this._fireEvent(XboxJS.UI.TabView._EventName.contentAnimating, {
                        type: XboxJS.UI.TabView.AnimationType.insert,
                        index: index,
                        tab: tab
                    });

                    if (result) {

                        var affectedElements = [];

                        for (var i = index + 1; i < this.tabs.length; i++) {
                            affectedElements.push(this.tabs.getAt(i).element);
                        }

                        animation = new WinJS.UI.Animation._createUpdateListAnimation([tab.element], [], affectedElements);
                    }

                    // Get the tab that was inserted
                    tab.element.winControl._setHeaderTemplate(this.headerTemplate);
                    if (index < this.tabs.length - 1) {
                        this._surfaceElement.insertBefore(tab.element, this.tabs.getAt(index + 1).element);

                        var tabHeader = tab.element.querySelector(".win-tabview-tab-header");
                        if (tabHeader) {

                            // Find the tab header to insert before
                            if (newIndex + 1 < this._tabsList.length) {
                                this._tabHeaders.insertBefore(tabHeader, this._tabsList[newIndex + 1].element);
                            }
                        }

                    } else {
                        this._surfaceElement.appendChild(tab.element);

                        var tabHeader = tab.element.querySelector(".win-tabview-tab-header");
                        if (tabHeader) {
                            this._tabHeaders.appendChild(tabHeader);
                        }
                    }
                    this._measured = false;

                    if (animation) {
                        var insertAnimation = animation.execute();
                        this.runningAnimations = WinJS.Promise.join([this.runningAnimations, insertAnimation]);
                    }

                    this._loadTabs();
                },
                _handleTabMoved: function tabView_handleTabMoved(ev) {
                    // Move is triggered by binding list move() API.
                    if (this._pendingTabs) {
                        return;
                    }

                    var newIndex = ev.detail.newIndex;
                    var tab = ev.detail.value;

                    if (newIndex < this.tabs.length - 1) {

                        this._surfaceElement.insertBefore(tab.element, this.tabs.getAt(newIndex + 1).element);

                        var tabHeader = tab.element.querySelector(".win-tabview-tab-header");
                        if (tabHeader) {

                            // Find the tab header to insert before
                            if (newIndex + 1 < this._tabsList.length) {
                                this._tabHeaders.insertBefore(tabHeader, this._tabsList[newIndex + 1].element);
                            }
                        }

                    } else {
                        this._surfaceElement.appendChild(tab.element);

                        var tabHeader = tab.element.querySelector(".win-tabview-tab-header");
                        if (tabHeader) {
                            this._tabHeaders.appendChild(tabHeader);
                        }
                    }

                    this._loadTabs();
                },
                _handleTabRemoved: function tabView_handleTabRemoved(ev) {
                    // Removed is triggered by binding list removal APIs such as splice(), pop(), and shift().
                    if (this._pendingTabs) {
                        return;
                    }

                    var tab = ev.detail.value;
                    var index = ev.detail.index;

                    var animationPromise = WinJS.Promise.wrap();
                    var result = this._fireEvent(XboxJS.UI.TabView._EventName.contentAnimating, {
                        type: XboxJS.UI.TabView.AnimationType.remove,
                        index: index,
                        tab: tab
                    });

                    if (result) {
                        var affectedElements = [];
                        for (var i = index; i < this.tabs.length; i++) {
                            affectedElements.push(this.tabs.getAt(i).element);
                        }

                        var animation = new WinJS.UI.Animation._createUpdateListAnimation([], [tab.element], affectedElements);

                        var offsetTop = tab.element.offsetTop;
                        var offsetLeft = tab.element.offsetLeft;
                        tab.element.style.position = "absolute";
                        tab.element.style.top = offsetTop;
                        tab.element.style.left = offsetLeft;
                        tab.element.style.opacity = 0;

                        animationPromise = animation.execute().then(function () {
                            if (tab._disposed) {
                                return;
                            }
                            tab.element.style.position = "";
                            tab.element.style.top = "";
                            tab.element.style.left = "";
                            tab.element.style.opacity = 1;
                        }.bind(this));
                    }

                    animationPromise.done(function () {
                        if (this._disposed) {
                            return;
                        }
                        // Remove the tab header, remove the tab section, then update
                        // focus if focus was on the removed header.

                        var oldTabHeader = this._tabsList[index];
                        if (oldTabHeader) {
                            this._tabHeaders.removeChild(oldTabHeader);

                            // We need to remove from our internal headers list as well.
                            this._tabsList.splice(index, 1);
                        }

                        if (document.activeElement === this._tabsList[index]) {
                            if (index + 1 < this._tabsList.length) {
                                this._tabsList[index + 1].focus();
                            } else {
                                // If we deleted the last TabView tab, then set focus to the first element to the right
                                var nextFocusElement = XboxJS.UI.AutomaticFocus.findNextFocusElement(WinJS.Utilities.Key.gamepadDPadRight);
                                if (nextFocusElement) {
                                    nextFocusElement.focus();
                                }
                            }
                        }

                        this._surfaceElement.removeChild(tab.element);
                    }.bind(this));

                    // Store animation promise in case it is inserted before remove animation finishes.
                    tab._animation = animationPromise;
                    this.runningAnimations = WinJS.Promise.join([this.runningAnimations, animationPromise]);

                    this._loadTabs();
                },
                _handleTabReload: function tabView_handleTabReload(ev) {
                    // Reload is triggered by large operations on the binding list such as reverse(). This causes 
                    // _pendingTabs to be true which ignores future insert/remove/modified/moved events until the new 
                    // tabs list is applied.
                    this.tabs = this.tabs;
                },
                _updateEvents: function tabView_updateEvents(oldTabs, newTabs) {
                    if (oldTabs) {
                        oldTabs.removeEventListener("itemchanged", this._handleTabChangedBind);
                        oldTabs.removeEventListener("iteminserted", this._handleTabInsertedBind);
                        oldTabs.removeEventListener("itemmoved", this._handleTabMovedBind);
                        oldTabs.removeEventListener("itemremoved", this._handleTabRemovedBind);
                        oldTabs.removeEventListener("reload", this._handleTabReloadBind);
                    }

                    newTabs.addEventListener("itemchanged", this._handleTabChangedBind);
                    newTabs.addEventListener("iteminserted", this._handleTabInsertedBind);
                    newTabs.addEventListener("itemmoved", this._handleTabMovedBind);
                    newTabs.addEventListener("itemremoved", this._handleTabRemovedBind);
                    newTabs.addEventListener("reload", this._handleTabReloadBind);
                },
                _animateLeftOldTab: function tab_animateLeftOldTab(oldTabIndex) {
                    var oldTab = this.tabs.getAt(oldTabIndex).element;
                    var moveLeft = "-100vw";
                    WinJS.Utilities.addClass(oldTab, "win-tabview-tab-visible");
                    return WinJS.UI.executeTransition(oldTab,
                                                    [{
                                                        property: "left",
                                                        delay: this._oldTabExitAnimationDelay,
                                                        duration: this._currentTabEntranceAnimationDuration,
                                                        timing: this._tabEaseInAnimationCurve,
                                                        from: this._tabDefaultLeftPostion,
                                                        to: moveLeft
                                                    }]);
                },
                _animateLeftCurrentTab: function tab_animateLeftCurrentTab(currentTabIndex) {
                    var currentTab = this.tabs.getAt(currentTabIndex).element;
                    WinJS.Utilities.addClass(currentTab, "win-tabview-tab-visible");
                    return WinJS.UI.executeTransition(currentTab,
                                                    [{
                                                        property: "left",
                                                        delay: this._currentTabEntranceAnimationDelay,
                                                        duration: this._currentTabEntranceAnimationDuration,
                                                        timing: this._tabEaseInAnimationCurve,
                                                        from: "100vw",
                                                        to: this._tabDefaultLeftPostion
                                                    }]);
                },

                _animateRightOldTab: function tab_animateRightOldTab(oldTabIndex) {
                    var oldTab = this.tabs.getAt(oldTabIndex).element;
                    var moveRight = "100vw";
                    WinJS.Utilities.addClass(oldTab, "win-tabview-tab-visible");
                    return WinJS.UI.executeTransition(oldTab,
                                                    [{
                                                        property: "left",
                                                        delay: this._oldTabExitAnimationDelay,
                                                        duration: this._currentTabEntranceAnimationDuration,
                                                        timing: this._tabEaseInAnimationCurve,
                                                        from: this._tabDefaultLeftPostion,
                                                        to: moveRight
                                                    }]);
                },
                _animateRightCurrentTab: function tab_animateRightCurrentTab(currIndex) {
                    var currentTab = this.tabs.getAt(currIndex).element;
                    WinJS.Utilities.addClass(currentTab, "win-tabview-tab-visible");
                    return WinJS.UI.executeTransition(currentTab,
                                                    [{
                                                        property: "left",
                                                        delay: this._currentTabEntranceAnimationDelay,
                                                        duration: this._currentTabEntranceAnimationDuration,
                                                        timing: this._tabEaseInAnimationCurve,
                                                        from: "-100vw",
                                                        to: this._tabDefaultLeftPostion
                                                    }]);
                },
                _attachTabs: function tabView_attachTabs() {
                    for (var i = 0; i < this.tabs.length; i++) {
                        var tab = this._tabs.getAt(i);
                        if (tab._animation) {
                            tab._animation.cancel();
                        }
                        if (tab.element.parentNode === this._surfaceElement) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.TabView.DuplicateSection", strings.duplicateSection);
                        }
                        this._surfaceElement.appendChild(tab.element);

                        var tabHeader = tab.element.querySelector(".win-tabview-tab-header");

                        // We need to test whether the tab header exists, because it's possible it was removed before attach
                        // tabs is called. This is the case when _attachTabs is called after the control is loaded. This can
                        // happen if the developer calls setAt on the tabs collection.
                        if (tabHeader) {
                            tabHeader.firstChild.tabIndex = -1;

                            this._tabHeaders.appendChild(tabHeader);
                            this._tabsList.push(tabHeader);
                        }

                        var tabContainer = tab._element;
                        WinJS.Utilities.addClass(tabContainer, "win-tabview-tab-hidden");
                    }

                    var currentTabIndex = this._currentTab;
                    if (currentTabIndex === -1 &&
                        this._tabsList.length) {
                        currentTabIndex = 0;
                    }

                    var currentTabHeader = this._tabsList[currentTabIndex];
                    if (currentTabHeader &&
                        this._tabs.getAt(currentTabIndex) &&
                        !this._tabs.getAt(currentTabIndex).isHeaderStatic) {
                        currentTabHeader.firstChild.tabIndex = 0;
                        WinJS.Utilities.addClass(currentTabHeader, "win-tab-currentselected");
                    }

                    var currentTabContainer = this._tabs.getAt(currentTabIndex);
                    if (currentTabContainer &&
                        currentTabContainer._element) {
                        WinJS.Utilities.removeClass(currentTabContainer._element, "win-tabview-tab-hidden");
                    }

                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }
                },
                _assignHeaderTemplate: function tabView_assignHeaderTemplate() {
                    for (var i = 0; i < this.tabs.length; i++) {
                        var tab = this._tabs.getAt(i);
                        tab._setHeaderTemplate(this.headerTemplate);
                    }
                },
                _loadTab: function tabView_loadTab(index) {
                    var tab = this._tabs.getAt(index);
                    if (!tab._processed) {
                        // Using visibility to avoid colliding with the Insert/Remove opacity animations.
                        tab.element.style.visibility = "hidden";
                        tab._processed = WinJS.UI.processAll(tab._contentElement);
                        tab._processed.done(function resetVisibility() {
                            if (tab._disposed) {
                                return;
                            }
                            tab.element.style.visibility = "visible";
                        });
                    }
                    return tab._processed;
                },
                _loadTabs: function tabView_loadTabs() {
                    this._setState(XboxJS.UI.TabView.LoadingState.loading);

                    // Used to know if another load has interrupted this one.
                    this._loadId++;
                    var loadId = this._loadId;
                    var that = this;
                    var onScreenItemsAnimatedPromise = WinJS.Promise.wrap();
                    var tabIndicesToLoad = [];
                    var allTabsLoadedPromise = WinJS.Promise.wrap();

                    function loadNextTabAfterPromise(promise) {
                        promise.then(function () {
                            setImmediate(loadNextTab);
                        });
                    }

                    function loadNextTab() {
                        if (loadId === that._loadId && !that._disposed) {
                            if (tabIndicesToLoad.length) {
                                var index = tabIndicesToLoad.shift();
                                var loadedPromise = that._loadTab(index);
                                loadNextTabAfterPromise(loadedPromise);
                            } else {
                                allTabsLoadedSignal.complete();
                            }
                        }
                    }

                    if (this.tabs.length) {
                        var allTabsLoadedSignal = new WinJS._Signal();
                        allTabsLoadedPromise = allTabsLoadedSignal.promise;

                        // Load the 1st tab synchronously.
                        var synchronousProcessPromises = [];
                        synchronousProcessPromises.push(this._loadTab(0));

                        // Load the rest of the tabs in order
                        for (var i = 1; i < this.tabs.length; i++) {
                            tabIndicesToLoad.push(i);
                        }

                        var onScreenTabsLoadedPromise = WinJS.Promise.join(synchronousProcessPromises);

                        // In case there are overlapping load calls
                        onScreenTabsLoadedPromise.done(function () {
                            setImmediate(function () {
                                if (loadId === this._loadId && !that._disposed) {
                                    if (!this._visible) {
                                        this._visible = true;
                                        if (this._viewportElement) {
                                            this._viewportElement.style.opacity = 1;
                                        }

                                        if (this._animateEntrance && WinJS.UI.isAnimationEnabled()) {
                                            var eventDetail = {
                                                type: XboxJS.UI.TabView.AnimationType.entrance
                                            };

                                            if (!this._fireEntrance || this._fireEvent(XboxJS.UI.TabView._EventName.contentAnimating, eventDetail)) {
                                                if (this._viewportElement) {
                                                    this._viewportElement.style["-ms-overflow-style"] = "none";
                                                }
                                                onScreenItemsAnimatedPromise = WinJS.UI.Animation.enterContent(this._viewportElement, [{ left: this._fireEntrance ? "100px" : "40px", top: "0px", rtlflip: true }]).then(function () {
                                                    if (this._viewportElement) {
                                                        this._viewportElement.style["-ms-overflow-style"] = "";
                                                    }
                                                }.bind(this));
                                            }
                                        }
                                    }
                                }
                            }.bind(this));
                        }.bind(this));

                        loadNextTabAfterPromise(onScreenTabsLoadedPromise);
                    }

                    WinJS.Promise.join([this.runningAnimations, onScreenItemsAnimatedPromise, allTabsLoadedPromise]).done(function () {
                        if (loadId === this._loadId && !that._disposed) {
                            this.runningAnimations = WinJS.Promise.wrap();
                            this._setState(XboxJS.UI.TabView.LoadingState.complete);

                            if (this._pendingCurrentTab !== -1) {
                                this.currentTab = this._pendingCurrentTab;
                            }

                            // Override automatic focus for the 1st and last tabs so that pressing left on the first
                            // tab stays on the first tab (as opposed to moving focus to something else below). Do the
                            // same thing for the last tab so pressing right will keep focus on the last tab.
                            if (this._tabsList.length) {
                                var oldFirstTabElement = this._tabHeaders.querySelector(".win-tabview-firsttab");
                                var newFirstTabElement = this._tabsList[0].firstChild;

                                var oldLastTabElement = this._tabHeaders.querySelector(".win-tabview-lasttab");
                                var newLastTabElement = this._tabsList[this._tabsList.length - 1].firstChild;

                                if (oldFirstTabElement !== newFirstTabElement) {
                                    if (oldFirstTabElement) {
                                        oldFirstTabElement.removeAttribute("data-win-focus");
                                    }
                                    WinJS.Utilities.addClass(newFirstTabElement, "win-tabview-firsttab");
                                    newFirstTabElement.setAttribute("data-win-focus", "{ left: '.win-tabview-firsttab' }");
                                }

                                if (oldLastTabElement !== newLastTabElement) {
                                    if (newLastTabElement) {
                                        newLastTabElement.removeAttribute("data-win-focus");
                                    }
                                    WinJS.Utilities.addClass(newLastTabElement, "win-tabview-lasttab");
                                    newLastTabElement.setAttribute("data-win-focus", "{ right: '.win-tabview-lasttab' }");
                                }
                            }
                        }
                    }.bind(this));
                },
                /// <field type="String" hidden="true" locid="XboxJS.UI.TabView.loadingState" helpKeyword="XboxJS.UI.TabView.loadingState">
                /// Gets a value that indicates whether the TabView is still loading or whether
                /// loading is complete.  This property can return one of these values:
                /// "loading" or "complete".
                /// </field>
                loadingState: {
                    get: function () {
                        return this._loadingState;
                    }
                },
                _setState: function tabView_setState(state) {
                    if (state !== this._loadingState) {
                        msWriteProfilerMark("XboxJS.UI.TabView:loadingStateChanged:" + state + ",info");
                        this._loadingState = state;
                        var eventObject = document.createEvent("CustomEvent");
                        eventObject.initCustomEvent(XboxJS.UI.TabView._EventName.loadingStateChanged, true, false, { loadingState: state });
                        this._element.dispatchEvent(eventObject);
                    }
                },
                _parse: function tabView_parse() {
                    var tabs = [];
                    var tabEl = this.element.firstElementChild;

                    while (tabEl !== this._viewportElement) {
                        WinJS.UI.processAll(tabEl);

                        var tabContent = tabEl.winControl;
                        if (tabContent) {
                            tabs.push(tabContent);
                        } else {
                            throw new WinJS.ErrorFromName("XboxJS.UI.TabView.InvalidContent", strings.invalidContent);
                        }

                        var nextTabEl = tabEl.nextElementSibling;
                        this.element.removeChild(tabEl);
                        tabEl = nextTabEl;
                    }

                    this.tabs = new WinJS.Binding.List(tabs);
                },
                _clickHandler: function tabView_clickHandler(ev) {
                    var headerElement = this._findHeader(ev.srcElement);

                    // If the tab header was clicked via voice, we need to call blur()
                    // on the currently focused tab so that the visual state changes.
                    if (ev.type === "click" &&
                        !ev.deviceSessionId) {
                        var focusedTab = this._tabHeaders.querySelector(".win-tabview-tab-tabstop:focus");
                        if (focusedTab) {
                            this._tabHeaders.querySelector(".win-tabview-tab-tabstop:focus").blur();
                        }
                    }

                    if (headerElement &&
                        headerElement.firstChild &&
                        WinJS.Utilities.hasClass(headerElement.firstChild, XboxJS.UI.Tab._ClassName.tabSectionInteractive)) {
                        this._setCurrentActiveHeader(headerElement);
                    }

                    WinJS.UI.executeAnimation(headerElement,
                        {
                            keyframe: "WinJS-tabview-pressheader",
                            property: "transform",
                            delay: 0,
                            duration: 100,
                            timing: "cubic-bezier(0.1, 0.9, 0.2, 1)"
                        });
                },
                _fireEvent: function tabView_fireEvent(type, detail) {
                    // Returns true if ev.preventDefault() was not called
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, true, true, detail);
                    return this.element.dispatchEvent(event);
                },
                _findHeader: function tabView_findHeader(element) {
                    if (element.parentNode) {
                        var matches = element.parentNode.querySelectorAll(".win-tabview-tab-header, .win-tabview-tab-header *");
                        var found = false;
                        for (var i = 0; i < matches.length; i++) {
                            if (matches[i] === element) {
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            while (!WinJS.Utilities.hasClass(element, "win-tabview-tab-header")) {
                                element = element.parentElement;
                            }
                            return element;
                        }
                    }
                    return null;
                },
                _findHeaderTabStop: function tabView_findHeaderTabStop(element) {
                    if (element.parentNode) {
                        if (element.msMatchesSelector(".win-tabview-tab-tabstop, .win-tabview-tab-tabstop *")) {
                            while (!WinJS.Utilities.hasClass(element, "win-tabview-tab-tabstop")) {
                                element = element.parentElement;
                            }
                            return element;
                        }
                    }
                    return null;
                },
                _tabHeadersFocusOut: function tabView_focusOut(ev) {

                    var headerTabStopElement = null;
                    if (ev.relatedTarget) {
                        headerTabStopElement = this._findHeader(ev.relatedTarget);
                    }

                    // The following checks if the new focus element is a tab, if it's not, then we've left the tab headers
                    if (this._isFocusInHeaders &&
                        !headerTabStopElement) {

                        this._isFocusInHeaders = false;

                        for (var i = 0; i < this._tabsList.length; i++) {
                            if (i === this._currentTab) {
                                this._tabsList[i].firstChild.tabIndex = 0;

                            } else {
                                this._tabsList[i].firstChild.tabIndex = -1;

                            }
                        }
                    }
                },
                _tabHeadersFocusIn: function tabView_focusIn(ev) {

                    var headerTabStopElement = this._findHeader(ev.srcElement);

                    for (var i = 0; i < this._tabsList.length; i++) {

                        // If previously focus was outside the tab headers, then we need to set all the tab headers'
                        // tabIndexes to 0 so the automatic focus algorithm can select them.
                        if (!this._isFocusInHeaders) {
                            this._tabsList[i].firstChild.tabIndex = 0;
                        }
                        if (this.currentTab !== i &&
                            headerTabStopElement === this._tabsList[i]) {
                            this.currentTab = i;
                        }
                    }

                    if (!this._isFocusInHeaders) {
                        if (this._currentTab !== -1) {
                            this._tabsList[this._currentTab].firstChild.focus();
                        }
                        this._isFocusInHeaders = true;
                    }
                },
                _handleFocusChanging: function tab_handleFocusChanging(ev) {
                    var keyCode = ev.detail.keyCode;
                    var nextFocusElement = ev.detail.nextFocusElement;

                    if (!this._surfaceElement.contains(document.activeElement)) {
                        return;
                    }

                    // Don't play focus sound on tab switch
                    if (ev.detail.nextFocusElement && WinJS.Utilities.hasClass(ev.detail.nextFocusElement, "win-tabview-tab-tabstop")) {
                        ev.detail.disableFocusSound = true;
                    }

                    // Check if we've focused off-screen, if so, move the tab over one.
                    if (nextFocusElement &&
                        document.activeElement) {
                        // Get the bounding rectangle of the focus element so we can do some math
                        var nextFocusElementRect = nextFocusElement.getBoundingClientRect();
                        if (keyCode === WinJS.Utilities.Key.rightArrow ||
                            keyCode === WinJS.Utilities.Key.gamepadDPadRight ||
                            keyCode === WinJS.Utilities.Key.gamepadLeftThumbstickRight ||
                            keyCode === WinJS.Utilities.Key.leftArrow ||
                            keyCode === WinJS.Utilities.Key.gamepadDPadLeft ||
                            keyCode === WinJS.Utilities.Key.gamepadLeftThumbstickLeft) {
                            if (!WinJS.Utilities.hasClass(document.activeElement, "win-tabview-tab-tabstop") &&
                                WinJS.Utilities.hasClass(nextFocusElement, "win-tabview-tab-tabstop")) {
                                // If the current focused element is in the current tab to prevent us from cycling
                                // too many tabs if the user is quickly moving focus while a tab transition animation is happening.
                                ev.preventDefault();
                            }
                        }
                    } else {
                        if (this._isPlayingTabTransitionAnimation) {
                            return;
                        }

                        if (keyCode === WinJS.Utilities.Key.rightArrow ||
                            keyCode === WinJS.Utilities.Key.gamepadDPadRight ||
                            keyCode === WinJS.Utilities.Key.gamepadLeftThumbstickRight) {
                            if (this._currentTab < this.tabs.length - 1) {
                                ev.detail.disableFocusSound = true;
                                this.currentTab = this.currentTab + 1;
                            }
                        }

                        if (keyCode === WinJS.Utilities.Key.leftArrow ||
                            keyCode === WinJS.Utilities.Key.gamepadDPadLeft ||
                            keyCode === WinJS.Utilities.Key.gamepadLeftThumbstickLeft) {
                            if (this._currentTab > 0) {
                                ev.detail.disableFocusSound = true;
                                this.currentTab = this.currentTab - 1;
                            }
                        }
                    }
                },
                _setCurrentActiveHeader: function (headerElement) {

                    for (var i = 0; i < this._tabsList.length; i++) {
                        if (headerElement === this._tabsList[i]) {
                            this.currentTab = i;
                            break;
                        }
                    }
                },
                // After the Tab changes we set focus to the first focusable element in the new tab section
                _setInitialTabFocus: function () {
                    // If the TabView hasn't loaded yet, the currentTab index will be -1 and the tab collection
                    // will be empty so any attempt to access the current tab will result in an exception.
                    if (this._currentTab === -1 ||
                        !this.tabs.length) {
                        return;
                    }

                    var currentTabElement = this.tabs.getAt(this._currentTab).element;
                    var initialFocusElement = currentTabElement.querySelector(".win-focusable, BUTTON:not([disabled]) BUTTON:not([tabIndex='-1']), INPUT:not([disabled]) INPUT:not([tabIndex='-1'])");
                    setImmediate(function afterDomProcessingHasFinished() {
                        if (initialFocusElement &&
                            currentTabElement && !currentTabElement.contains(document.activeElement)) {
                            initialFocusElement.focus();
                        }
                    });
                },
                _MSPointerDown: function tabView_MSPointerDown(ev) {

                    var headerElement = this._findHeader(ev.srcElement);

                    if (headerElement &&
                        headerElement.firstChild &&
                        WinJS.Utilities.hasClass(headerElement.firstChild, XboxJS.UI.Tab._ClassName.tabSectionInteractive)) {
                        this._setCurrentActiveHeader(headerElement);
                    }
                },
                _handleKeydown: function (ev) {
                    if (!this._element.contains(document.activeElement)) {
                        return;
                    }

                    if (ev.key === "GamepadLeftShoulder" ||
                        ev.key === "PageUp") {
                        if (this._currentTab > 0) {
                            this.currentTab = this.currentTab - 1;
                            this._setInitialTabFocus();
                        }
                    } else if (ev.key === "GamepadRightShoulder" ||
                        ev.key === "PageDown") {
                        if (this._currentTab < this.tabs.length - 1) {
                            this.currentTab = this.currentTab + 1;
                            this._setInitialTabFocus();
                        }
                    }
                },
                // Updates visual state of the tab headers
                _updateTabHeaderVisuals: function () {
                    var tabs = this.tabs;

                    for (var i = 0; i < tabs.length; i++) {
                        WinJS.Utilities.removeClass(this._tabsList[i], "win-tab-currentselected");
                        WinJS.Utilities.removeClass(this._tabsList[i], "win-voice-disableoverride");
                    }

                    if (this._currentTab !== -1) {
                        WinJS.Utilities.addClass(this._tabsList[this._currentTab], "win-tab-currentselected");
                        WinJS.Utilities.addClass(this._tabsList[this._currentTab], "win-voice-disableoverride");
                    }
                },
                // Hide the visible ones and show the invisible ones
                _updateTabVisibility: function () {
                    var tabs = null;
                    if (this._pendingTabs) {
                        tabs = this._pendingTabs;
                    } else {
                        tabs = this.tabs;
                    }

                    for (var i = 0; i < tabs.length; i++) {
                        WinJS.Utilities.addClass(tabs.getAt(i).element, "win-tabview-tab-hidden");
                        WinJS.Utilities.removeClass(tabs.getAt(i).element, "win-tabview-tab-visible");
                    }

                    if (this._currentTab !== -1) {
                        WinJS.Utilities.removeClass(tabs.getAt(this._currentTab).element, "win-tabview-tab-hidden");
                        WinJS.Utilities.addClass(tabs.getAt(this._currentTab).element, "win-tabview-tab-visible");
                    }

                    if (XboxJS.UI.Voice) {
                        XboxJS.UI.Voice.refreshVoiceElements();
                    }
                },
                currentTab: {
                    /// <signature helpKeyword="XboxJS.UI.TabView.currentTab">
                    /// <summary locid="XboxJS.UI.TabView.currentTab">
                    /// Returns the currently selected tab.
                    /// </summary>
                    /// </signature>
                    get: function () {
                        return this._currentTab;
                    },
                    set: function (value) {
                        if (value >= this.tabs.length ||
                            value < 0) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.TabView.indexOutOfRange", strings.indexOutOfRange);
                        }

                        if (this._currentTab !== value) {

                            if (this._loadingState !== XboxJS.UI.TabView.LoadingState.complete) {
                                this._pendingCurrentTab = value;
                                return;
                            }

                            var oldTabIndex = this._currentTab;

                            this._currentTab = value;

                            this._updateTabHeaderVisuals();

                            if (WinJS.UI.isAnimationEnabled()) {
                                var animateTransition = this._fireEvent(XboxJS.UI.TabView._EventName.contentAnimating, {
                                    type: XboxJS.UI.TabView.AnimationType.contentTransition,
                                    oldTabIndex: oldTabIndex,
                                    newTabIndex: this._currentTab
                                });

                                if (animateTransition) {
                                    if (oldTabIndex !== -1) {
                                        this._isPlayingTabTransitionAnimation = true;
                                        var oldTabAnimationPromise = null;
                                        var newTabAnimationPromise = null;
                                        if (this._currentTab > oldTabIndex) {
                                            if (XboxJS.UI.TabView._sounds.pageTransitionR) {
                                                XboxJS.UI.TabView._sounds.pageTransitionR.play();
                                            }
                                            oldTabAnimationPromise = this._animateLeftOldTab(oldTabIndex);
                                            newTabAnimationPromise = this._animateLeftCurrentTab(this._currentTab);
                                        } else {
                                            if (XboxJS.UI.TabView._sounds.pageTransitionL) {
                                                XboxJS.UI.TabView._sounds.pageTransitionL.play();
                                            }
                                            oldTabAnimationPromise = this._animateRightCurrentTab(this._currentTab);
                                            newTabAnimationPromise = this._animateRightOldTab(oldTabIndex);
                                        }

                                        var that = this;
                                        WinJS.Promise.join([oldTabAnimationPromise, newTabAnimationPromise]).done(function afterTabAnimationCompleted() {
                                            if (that._disposed) {
                                                return;
                                            }

                                            if (XboxJS.UI.Voice) {
                                                XboxJS.UI.Voice.refreshVoiceElements();
                                            }

                                            that._fireEvent(XboxJS.UI.TabView._EventName.currentTabChanged, {
                                                oldTabIndex: oldTabIndex,
                                                newTabIndex: that._currentTab
                                            });

                                            // This code attempts to set focus to the next element in the new tab that should recieve focus based on where the previous focus was.
                                            // It restricts the potential focus elements to elements within the current tab so we don't focus on a tab header or something outside
                                            // TabView.
                                            if (document.activeElement &&
                                                !that._tabHeaders.contains(document.activeElement)) {
                                                var direction = -1;
                                                if (oldTabIndex < that._currentTab) {
                                                    direction = WinJS.Utilities.Key.gamepadDPadRight;
                                                } else {
                                                    direction = WinJS.Utilities.Key.gamepadDPadLeft;
                                                }
                                                var currentTabElement = that.tabs.getAt(that.currentTab).element;
                                                var previousFocusRoot = XboxJS.UI.AutomaticFocus.focusRoot;
                                                XboxJS.UI.AutomaticFocus.focusRoot = currentTabElement;
                                                var nextFocusElement = XboxJS.UI.AutomaticFocus.findNextFocusElement(direction, document.activeElement.getBoundingClientRect());
                                                XboxJS.UI.AutomaticFocus.focusRoot = previousFocusRoot;
                                                setImmediate(function afterDomProcessingHasFinished() {
                                                    // Set focus to the first focusable element in the new tab. We also check to make sure focus wasn't set programatically or
                                                    // by the user.
                                                    if (nextFocusElement &&
                                                        currentTabElement && !currentTabElement.contains(document.activeElement)) {
                                                        nextFocusElement.focus();
                                                    }
                                                });
                                            }

                                            that._isPlayingTabTransitionAnimation = false;
                                            that._updateTabVisibility();
                                        });
                                    }
                                } else {
                                    this._fireEvent(XboxJS.UI.TabView._EventName.currentTabChanged, {
                                        oldTabIndex: oldTabIndex,
                                        newTabIndex: this._currentTab
                                    });
                                }
                            }
                        }
                    }
                },
                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.TabView.dispose">
                    /// <summary locid="XboxJS.UI.TabView.dispose">
                    /// Disposes this control.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    this._tabEaseInAnimationCurve = null;
                    if (XboxJS) {
                        XboxJS.UI.AutomaticFocus.removeEventListener("focuschanging", this._handleFocusChangingBind);
                    }

                    for (var i = 0; i < this.tabs.length; i++) {
                        this.tabs.getAt(i).dispose();
                    }

                    this._tabs.removeEventListener("itemchanged", this._handleTabChangedBind);
                    this._tabs.removeEventListener("iteminserted", this._handleTabInsertedBind);
                    this._tabs.removeEventListener("itemmoved", this._handleTabMovedBind);
                    this._tabs.removeEventListener("itemremoved", this._handleTabRemovedBind);
                    this._tabs.removeEventListener("reload", this._handleTabReloadBind);

                    this._handleTabChangedBind = null;
                    this._handleTabInsertedBind = null;
                    this._handleTabMovedBind = null;
                    this._handleTabRemovedBind = null;
                    this._handleTabReloadBind = null;

                    XboxJS.UI.AutomaticFocus.removeEventListener("focuschanging", this._handleFocusChangingBind);
                    this._handleFocusChangingBind = null;

                    this._tabs.length = 0;
                    this._tabs = null;

                    this._tabsList.length = 0;
                    this._tabsList = null;

                    this._viewportElement = null;
                    this._surfaceElement = null;
                    this._tabHeaders = null;
                    this.runningAnimations = null;
                    this._currentTabEntranceAnimationDelay = null;
                    this._currentTabEntranceAnimationDuration = null;
                    this._oldTabExitAnimationDelay = null;
                    this._tabDefaultLeftPostion = null;
                    this._tabEaseInAnimationCurve = null;

                    this._element.winControl = null;
                    this._element = null;
                }
            }, {
                /// <field locid="XboxJS.UI.TabView.AnimationType" helpKeyword="XboxJS.UI.TabView.AnimationType">
                /// Specifies whether the TabView animation is an entrance animation or a transition animation.
                /// </field>
                AnimationType: {
                    /// <field locid="XboxJS.UI.TabView.AnimationType.entrance" helpKeyword="XboxJS.UI.TabView.AnimationType.entrance">
                    /// The animation plays when the TabView is first displayed.
                    /// </field>
                    entrance: "entrance",
                    /// <field locid="XboxJS.UI.TabView.AnimationType.contentTransition" helpKeyword="XboxJS.UI.TabView.AnimationType.contentTransition">
                    /// The animation plays when the TabView is changing its content.
                    /// </field>
                    contentTransition: "contentTransition",
                    /// <field locid="XboxJS.UI.TabView.AnimationType.insert" helpKeyword="XboxJS.UI.TabView.AnimationType.insert">
                    /// The animation plays when a section is inserted into the TabView.
                    /// </field>
                    insert: "insert",
                    /// <field locid="XboxJS.UI.TabView.AnimationType.remove" helpKeyword="XboxJS.UI.TabView.AnimationType.remove">
                    /// The animation plays when a section is removed into the TabView.
                    /// </field>
                    remove: "remove",
                },
                /// <field locid="XboxJS.UI.TabView.LoadingState" helpKeyword="XboxJS.UI.TabView.LoadingState">
                /// Specifies the current state of the TabView.
                /// </field>
                LoadingState: {
                    /// <field locid="XboxJS.UI.TabView.LoadingState.loading" helpKeyword="XboxJS.UI.TabView.LoadingState.loading">
                    /// The TabView is loading tabs.
                    /// </field>
                    loading: "loading",
                    /// <field locid="XboxJS.UI.TabView.LoadingState.complete" helpKeyword="XboxJS.UI.TabView.LoadingState.complete">
                    /// All tabs are loaded and animations are complete.
                    /// </field>
                    complete: "complete"
                },
                // The name of the events fired by the TabView
                _EventName: {
                    contentAnimating: "contentanimating",
                    currentTabChanged: "currenttabchanged",
                    loadingStateChanged: "loadingstatechanged"
                },
                // Names of classes used by the TabView.
                _ClassName: {
                    tab: "win-tabview",
                    tabSurface: "win-tab-surface",
                    tabViewport: "win-tab-viewport"
                },
                isDeclarativeControlContainer: true,
                _sounds: {
                    initialized: false,
                    pageTransitionR: null,
                    pageTransitionL: null
                }
            });
            WinJS.Class.mix(TabView, WinJS.Utilities.createEventProperties(
                TabView._EventName.contentAnimating,
                TabView._EventName.currentTabChanged,
                TabView._EventName.loadingStateChanged));
            WinJS.Class.mix(TabView, WinJS.UI.DOMEventMixin);
            return TabView;
        })
    });

})(this, WinJS);
(function tvElementUtilities(global, WinJS, undefined) {
    "use strict";

    WinJS.Namespace.define("WinJS.Utilities.Key", {

        /// <field locid="WinJS.Utilities.Key.gamepadA" helpKeyword="WinJS.Utilities.Key.gamepadA">
        /// Gamepad A button.
        /// </field>
        gamepadA: 193,

        /// <field locid="WinJS.Utilities.Key.gamepadB" helpKeyword="WinJS.Utilities.Key.gamepadB">
        /// Gamepad B button.
        /// </field>
        gamepadB: 194,

        /// <field locid="WinJS.Utilities.Key.gamepadX" helpKeyword="WinJS.Utilities.Key.gamepadX">
        /// Gamepad X button.
        /// </field>
        gamepadX: 195,

        /// <field locid="WinJS.Utilities.Key.gamepadY" helpKeyword="WinJS.Utilities.Key.gamepadY">
        /// Gamepad Y button.
        /// </field>
        gamepadY: 196,

        /// <field locid="WinJS.Utilities.Key.gamepadRightShoulder" helpKeyword="WinJS.Utilities.Key.gamepadRightShoulder">
        /// Gamepad right shoulder button.
        /// </field>
        gamepadRightShoulder: 197,

        /// <field locid="WinJS.Utilities.Key.gamepadLeftShoulder" helpKeyword="WinJS.Utilities.Key.gamepadLeftShoulder">
        /// Gamepad left shoulder button.
        /// </field>
        gamepadLeftShoulder: 198,

        /// <field locid="WinJS.Utilities.Key.gamepadLeftTrigger" helpKeyword="WinJS.Utilities.Key.gamepadLeftTrigger">
        /// Gamepad left trigger button.
        /// </field>
        gamepadLeftTrigger: 199,

        /// <field locid="WinJS.Utilities.Key.gamepadRightTrigger" helpKeyword="WinJS.Utilities.Key.gamepadRightTrigger">
        /// Gamepad right trigger button.
        /// </field>
        gamepadRightTrigger: 200,

        /// <field locid="WinJS.Utilities.Key.gamepadDPadUp" helpKeyword="WinJS.Utilities.Key.gamepadDPadUp">
        /// Gamepad DPad Up.
        /// </field>
        gamepadDPadUp: 201,

        /// <field locid="WinJS.Utilities.Key.gamepadDPadDown" helpKeyword="WinJS.Utilities.Key.gamepadDPadDown">
        /// Gamepad DPad Down.
        /// </field>
        gamepadDPadDown: 202,

        /// <field locid="WinJS.Utilities.Key.gamepadDPadLeft" helpKeyword="WinJS.Utilities.Key.gamepadDPadLeft">
        /// Gamepad DPad Left.
        /// </field>
        gamepadDPadLeft: 203,

        /// <field locid="WinJS.Utilities.Key.gamepadDPadRight" helpKeyword="WinJS.Utilities.Key.gamepadDPadRight">
        /// Gamepad DPad Right.
        /// </field>
        gamepadDPadRight: 204,

        /// <field locid="WinJS.Utilities.Key.gamepadMenu" helpKeyword="WinJS.Utilities.Key.gamepadMenu">
        /// Gamepad menu button.
        /// </field>
        gamepadMenu: 205,

        /// <field locid="WinJS.Utilities.Key.gamepadView" helpKeyword="WinJS.Utilities.Key.gamepadView">
        /// Gamepad view button.
        /// </field>
        gamepadView: 206,

        /// <field locid="WinJS.Utilities.Key.gamepadLeftThumbstick" helpKeyword="WinJS.Utilities.Key.gamepadLeftThumbstick">
        /// Gamepad left thumbstick.
        /// </field>
        gamepadLeftThumbstick: 207,

        /// <field locid="WinJS.Utilities.Key.gamepadRightThumbstick" helpKeyword="WinJS.Utilities.Key.gamepadRightThumbstick">
        /// Gamepad right thumbstick.
        /// </field>
        gamepadRightThumbstick: 208,

        /// <field locid="WinJS.Utilities.Key.gamepadLeftThumbstickUp" helpKeyword="WinJS.Utilities.Key.gamepadLeftThumbstickUp">
        /// Gamepad left thumbstick up.
        /// </field>
        gamepadLeftThumbstickUp: 209,

        /// <field locid="WinJS.Utilities.Key.gamepadLeftThumbstickDown" helpKeyword="WinJS.Utilities.Key.gamepadLeftThumbstickDown">
        /// Gamepad left thumbstick down.
        /// </field>
        gamepadLeftThumbstickDown: 210,

        /// <field locid="WinJS.Utilities.Key.gamepadLeftThumbstickRight" helpKeyword="WinJS.Utilities.Key.gamepadLeftThumbstickRight">
        /// Gamepad left thumbstick right.
        /// </field>
        gamepadLeftThumbstickRight: 211,

        /// <field locid="WinJS.Utilities.Key.gamepadLeftThumbstickLeft" helpKeyword="WinJS.Utilities.Key.gamepadLeftThumbstickLeft">
        /// Gamepad left thumbstick left.
        /// </field>
        gamepadLeftThumbstickLeft: 212,

        /// <field locid="WinJS.Utilities.Key.gamepadRightThumbstickUp" helpKeyword="WinJS.Utilities.Key.gamepadRightThumbstickUp">
        /// Gamepad right thumbstick up.
        /// </field>
        gamepadRightThumbstickUp: 213,

        /// <field locid="WinJS.Utilities.Key.gamepadRightThumbstickDown" helpKeyword="WinJS.Utilities.Key.gamepadRightThumbstickDown">
        /// Gamepad right thumbstick down.
        /// </field>
        gamepadRightThumbstickDown: 214,

        /// <field locid="WinJS.Utilities.Key.gamepadRightThumbstickRight" helpKeyword="WinJS.Utilities.Key.gamepadRightThumbstickRight">
        /// Gamepad right thumbstick right.
        /// </field>
        gamepadRightThumbstickRight: 215,

        /// <field locid="WinJS.Utilities.Key.gamepadRightThumbstickLeft" helpKeyword="WinJS.Utilities.Key.gamepadRightThumbstickLeft">
        /// Gamepad right thumbstick left.
        /// </field>
        gamepadRightThumbstickLeft: 216
    });
})(this, WinJS);

(function globalVoiceInit(global) {
    "use strict";

    //
    // The VUI Manager object that is used for the current instance. This can be
    // communicating with the WinRT object (if this is the toplevel window) or with
    // the higher level window, if this is in an IFrame
    //
    var _vuiManager = null;

    //
    // Throwing this CSS class on objects will enable their bling mode
    //
    var _activeListeningClassName = "win-voice-activelistening";

    //
    // Throwing this CSS class on objects will enable their bling mode for disambiguation
    //
    var _disambiguationListeningClassName = "win-voice-disambiguationlistening";

    //
    // Throwing this CSS class on objects will indicate the bling is being activated for the 
    // first time rather than just as cause of navigation.
    //
    var _initialActiveListeningClassName = "win-voice-initial-activelistening";

    //
    // This class is thrown on the focus root, just to indicate that the voice mode is active
    // and any elements what want to appear specifically for voice, should do so. For example
    // the close flyout buttons for flyouts.
    //
    var _voiceModeClassName = "win-voice-voicemodeactive";

    //
    // Throwing this CSS class on objects will disable voice for them
    //
    var _disableVoiceClassName = "win-voice-disableoverride";

    //
    // Throwing this CSS class on objects will disable voice for them.
    // This is an internal only CSS class to be used by the framework.
    //
    var _internalDisableVoiceClassName = "win-voice-internaldisableoverride";

    //
    // The name of the attribute on the HTML elements that contain the data for
    // handling voice. Expected data are phrase, handler, confidence and an optional
    // pronunciation.
    //
    var _voiceAttributeName = "data-win-voice";

    //
    // A hidden attribute on the HTML elements that voice uses to map results
    // from the VUI Manager, back to an element
    //
    var _voiceUniqueId = "voice-unique-id";

    //
    // Time to wait for before refreshing voice elements
    //
    var _voiceRefreshTimeout = 250;

    //
    // Type of the message transmitted between IFrames
    //
    var _VmType = {
        none: 0,
        addElement: 1,
        removeElement: 2,
        startActiveListening: 3,
        endActiveListening: 4,
        startDisambiguation: 5,
        endDisambiguation: 6,
        matchPhrase: 7,
        registerChild: 8,
        unregisterChild: 9,
        maxValue: 10
    };
    
    //
    // Type of the disambiguation command
    //
    var _DisambiguationState = {
        none: 0,
        startDisambiguation: 1,
        endDisambiguation: 2,
        maxValue: 3
    };

    //
    // Type of the registration happening
    //
    var _PhraseRegistrationType = {
        None: 0,
        WinRTDirect: 1,
        WebBlendRedirect: 2,
        MaxValue: 3
    };
        
    //
    // Current State
    //
    var _VoiceManagerStatusType = {
        None: 0,
        Enabled: 1,
        ActiveListening: 2,
        InDisambiguation: 3,
        MaxValue: 4
    };

    //
    // DOM element that specifies that root of the voice activation.
    // If not specified, we will fall back to the focus root, and
    // if that is not specified then the BODY element.
    //
    var _voiceRoot = null;

    var _convertPropertyNameToHandler = function (fName, startingScope) {
        var namespaces = fName.split(".");
        var func = startingScope;
        for (var n = 0; n < namespaces.length - 1; n++) {
            func = func[namespaces[n]];
            if (!func) {
                return null;
            }            
        }
        var propDescriptor = {
            get : function () { return func[namespaces[namespaces.length - 1]]; },
            set : function (value) { func[namespaces[namespaces.length - 1]] = value; },
        };
        return propDescriptor;
    };

    var _standardizeUrl = function (url) {
        var standardizedUrl = url.toLowerCase();
        var replacementStrings = [
            { find: "ms-appx:///", replace: "ms-appx://" + window.location.hostname + "/" },
            { find: "ms-appx-web:///", replace: "ms-appx-web://" + window.location.hostname + "/" }
        ];

        for (var i = 0; i < replacementStrings.length; i++) {
            if (standardizedUrl.indexOf(replacementStrings[i].find) === 0 &&
                standardizedUrl.lastIndexOf(replacementStrings[i].find) === 0) {
                standardizedUrl = standardizedUrl.replace(replacementStrings[i].find, replacementStrings[i].replace);
                break;
            }
        }

        return standardizedUrl;
    };

    var _getFrameElement = function (frameSource) {
        var frameUrlStandardized = _standardizeUrl(frameSource);
        var frameElements = document.getElementsByTagName("IFRAME");
        for (var i = 0; i < frameElements.length; i++) {
            if (_standardizeUrl(frameElements[i].src) === frameUrlStandardized) {
                return frameElements[i];
            }
        }

        //
        // Temporary fix
        //
        if (frameElements.length === 1) {
            return frameElements[0];
        }
        return null;
    };

    //
    // Uses the IE specific document.uniqueID to generate unique IDs
    // for elements which can be used for quick look up based on the
    // client info passed back from the VUI Managers
    //
    var _getUniqueIdForElement = function (element) {
        var currentUniqueId = element.getAttribute(_voiceUniqueId);
        //
        // If existing one is not found, create a new one
        //
        if (!currentUniqueId) {
            var newId = document.uniqueID;
            currentUniqueId = newId.toString();
            element.setAttribute(_voiceUniqueId, currentUniqueId);
        }
        return currentUniqueId;
    };

    var _getElementOffsetRelativeWindow = function (element, rect) {
        var offset = { offsetLeft: 0, offsetHeight: 0, offsetTop: 0, offsetWidth: 0 };
        if (element && element !== window) {
            offset.offsetHeight = element.offsetHeight;
            offset.offsetWidth = element.offsetWidth;
        }
        offset.offsetTop = rect.top + window.pageYOffset;
        offset.offsetLeft = rect.left + window.pageXOffset;
        return offset;
    };

    var _isElementOnScreen = function (element, partialMatchAcceptable) {
        var rect = element.getBoundingClientRect(element);
        var correctedRect = {
            top: Math.floor(rect.top),
            bottom: Math.floor(rect.bottom),
            right: Math.floor(rect.right),
            left: Math.floor(rect.left),
            height: Math.floor(rect.height),
            width: Math.floor(rect.width)
        };

        if (correctedRect.width === 0 || correctedRect.height === 0) {
            return false;
        }

        var offset = _getElementOffsetRelativeWindow(element, correctedRect);
        if (!partialMatchAcceptable) {
            // Is it fully onscreen?
            if ((offset.offsetLeft >= window.pageXOffset) && // It is beyond the left edge
                ((offset.offsetLeft + offset.offsetWidth) <= (window.pageXOffset + window.innerWidth)) && // It is before the right edge
                (offset.offsetTop >= window.pageYOffset) && // It is beyond the top edge
                ((offset.offsetTop + offset.offsetHeight) <= (window.pageYOffset + window.innerHeight))) {
               return true;
           }
       } else {
            if (((offset.offsetLeft >= window.pageXOffset) && (offset.offsetLeft <= (window.pageXOffset + window.innerWidth))) ||
                (((offset.offsetLeft + offset.offsetWidth) >= window.pageXOffset) && ((offset.offsetLeft + offset.offsetWidth) <= (window.pageXOffset + window.innerWidth))) ||
                ((offset.offsetTop >= window.pageYOffset) && (offset.offsetTop <= (window.pageYOffset + window.innerHeight))) ||
                (((offset.offsetTop + offset.offsetHeight) >= window.pageYOffset) && ((offset.offsetTop + offset.offsetHeight) <= (window.pageYOffset + window.innerHeight)))) {
               return true;
           }
       }

       return false;
    };

    var _doesElementMatchActivationRequirement = function (element) {
        if (element.disabled) {
            return false;
        }

        var style = element.currentStyle;
        if (!style || style.display === "none" || style.visibility === "hidden" || style.width === "0px" ||
            style.width === "0%" || style.height === "0px" || style.height === "0%") {
            return false;
        }

        return true;
    };

    //
    // Runs through all elements on the screen that are captured by the focusRoot
    // and if they are valid Voice Elements (i.e. not Iframes and enabled elements)
    // which contain a voice attribute (data-win-voice), will process them as
    // appropriate by the perElementFunctor.
    //
    var _processElementsWithSpecifiedFocusRoot = function (perElementFunctor, focusRoot, initialTrigger) {
        var childrenElements = focusRoot.querySelectorAll("[data-win-voice]");
        var selectedElements = [];

        for (var i = 0; i < childrenElements.length; i++) {
            var currentElement = childrenElements[i];
            if (_isElementOnScreen(currentElement, false)) {              
               selectedElements.push(currentElement);
           }
        }
        childrenElements = null;
        
        for (var i = 0; i < selectedElements.length; i++) {
            var currentElement = selectedElements[i];
            // Filter out IFRAMES
            if (currentElement.tagName === "IFRAME") {
                continue;
            }
            // Filter out elements that have explictly disabled voice
            if (currentElement.classList.contains(_disableVoiceClassName)) {
                continue;
            }
            // Filter out elements that have explictly disabled voice
            if (currentElement.classList.contains(_internalDisableVoiceClassName)) {
                continue;
            }
            // Filter out elements that don't fit our criteria
            if (!_doesElementMatchActivationRequirement(currentElement)) {
                continue;
            }
            // Process element
            var vuiOptions = currentElement.getAttribute(_voiceAttributeName);
            if (vuiOptions) {
                perElementFunctor(currentElement, vuiOptions, initialTrigger);
            } else {
                continue;
            }
        }
    };

    var _getCurrentPageUrl = function () {
        //
        // Call this code ONLY inside an IFRAME.
        // If there is a problem, it will be in the sandboxed IFRAME code
        //
        var url = window.location.href;
        url = url.split('#')[0];

        return url;
    };

    //
    // Acquire VUI Manager
    //
    var _getVoiceManager = function (trustedDomains, inIFrame) {        
        var _elementMap = {};
        var _iFrameMap = {};
        var _auxGrammar = null;
        var _globalCommands = {};
        var _reverseGlobalCommands = {};
        var _iFrameDisambMap = {};

        var _status = _VoiceManagerStatusType.None;
        var _pendingRefresh = false;
        var _timerId = null;
        var _disableNonForcedRefresh = false;
        var _voiceManager = null;
        var _isTestMode = false;
        var _enumerations = {};

        var _registerEnumeration = function (enumName, arrayOfEnums) {
            if (arrayOfEnums instanceof Array) {
                _enumerations[enumName] = { indexToUse: 0, enums: arrayOfEnums };
            } else {
                throw new WinJS.ErrorFromName("XboxJS.UI.Voice.incorrectTypeOfEnumeration", strings.voiceIncorrectTypeOfEnumeration);
            }
        };

        var _unregisterEnumeration = function (enumName) {
            if (_enumerations[enumName]) {
                delete _enumerations[enumName];
            }
        };

        var _registerPhrase = function (phrase, clientData, confidence, pronunciation, disambCapable) {
            if (inIFrame) {
                window.parent.postMessage({
                    ms__winJSVoiceControlPostMessage: {
                        type: _VmType.addElement,
                        clientId: _getCurrentPageUrl(),
                        id: clientData,
                        phrase: phrase,
                        confidence: confidence,
                        pronunciation: pronunciation,
                        disambCapable: disambCapable
                    }
                }, "*");
                return {
                           registrationType: _PhraseRegistrationType.WebBlendRedirect,
                           pObject: clientData
                       };

            } else {
                try {
                    var phraseCreateInfo = null;
                    var phraseCreateComponent = null;
                    var phraseObject = null;
                    if (!_isTestMode) {
                        phraseCreateInfo = new Windows.Xbox.Speech.VuiManager.VuiPhraseCreateInfo;
                        phraseCreateComponent = new Windows.Xbox.Speech.VuiManager.VuiPhraseCreateInfoComponent;
                        phraseCreateComponent.text = phrase;
                        if (pronunciation) {
                            phraseCreateComponent.customPronunciation = pronunciation;
                        }
                        phraseCreateInfo.phraseConfidenceThreshold = confidence;
                        phraseCreateInfo.clientData = clientData;
                        phraseCreateInfo.phraseComponents.append(phraseCreateComponent);
                        
                        if (disambCapable) {
                            phraseObject = _voiceManager.createPhrase(phraseCreateInfo);
                        } else {
                            if (!_auxGrammar) {
                                _auxGrammar = _voiceManager.createAuxiliaryPhraseGroup();
                                _auxGrammar.enable();
                            }
                            phraseObject = _auxGrammar.createPhrase(phraseCreateInfo);
                        }
                        phraseObject.enable();
                    }
                    return {
                               registrationType: _PhraseRegistrationType.WinRTDirect,
                               pObject: phraseObject
                           };
                } catch (e) {
                    // ERROR - Ignore Error
                }
                return null;
            }
        };

        var _unregisterPhrase = function (obj) {
            if (obj.registrationType === _PhraseRegistrationType.WebBlendRedirect) {
                window.parent.postMessage({
                    ms__winJSVoiceControlPostMessage: {
                        type: _VmType.removeElement,
                        clientId: _getCurrentPageUrl(),
                        id: obj.pObject
                    }
                }, "*");
            } else {
                try {
                    if (!_isTestMode && obj.pObject) {
                        obj.pObject.disable();
                        obj.pObject.destroy();
                        delete obj.pObject;
                    }
                } catch (e) {
                    // ERROR - Ignore Error
                }
            }
        };

        var _disableGlobalCommands = function () {
            if (_status < _VoiceManagerStatusType.Enabled) {
                return;
            }
            for (var i in _globalCommands) {
                if (_globalCommands[i].pObject) {
                    _unregisterPhrase(_globalCommands[i].pObject);
                }
            }
        };

        var _enableGlobalCommands = function () {
            if (_status < _VoiceManagerStatusType.ActiveListening) {
                return;
            }                
            for (var gbl in _globalCommands) {
                var pObject = _registerPhrase(_globalCommands[gbl].phrase, gbl, _globalCommands[gbl].confidence,
                                              _globalCommands[gbl].pronunciation, false);
                if (pObject) {
                    _globalCommands[gbl].pObject = pObject;
                }
            }
        };

        var _registerGlobalCommand = function (phrase, callback, confidence, pronunciation) {
            var phraseProcessed = null;
            var confidenceProcessed = null;

            if (!phrase) {
                throw new WinJS.ErrorFromName("XboxJS.UI.Voice.missingPhraseFromGlobalCommandRegistration", strings.voiceMissingPhraseFromGlobalCommandRegistration);
                return;
            }
            if (typeof phrase !== "string") {
                throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidPhraseTypeFromGlobalCommandRegistration", strings.voiceInvalidPhraseTypeFromGlobalCommandRegistration);
                return;
            }
            if (!callback) {
                throw new WinJS.ErrorFromName("XboxJS.UI.Voice.missingHandlerFromGlobalCommandRegistration", strings.voiceMissingHandlerFromGlobalCommandRegistration);
                return;
            }
            if (typeof callback !== "function" ) {
                throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidHandlerTypeFromGlobalCommandRegistration", strings.voiceInvalidHandlerTypeFromGlobalCommandRegistration);
                return;
            }
            if (pronunciation) {
                if (typeof pronunciation !== "string") {
                    throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidPronunciationTypeFromGlobalCommandRegistration", strings.voiceInvalidPronunciationTypeFromGlobalCommandRegistration);
                    return;
                }
            } else {
                pronunciation = null;
            }

            //
            // See if we can get phrases/confidences/pronunciations from resources
            //

            var phraseProcessed = WinJS.Resources.getString(phrase);
            if (phraseProcessed && !phraseProcessed.empty) {
                if (phraseProcessed.value.toUpperCase() !== "STRING_EMPTY") {
                    phraseProcessed = phraseProcessed.value;
                } else {
                    // Don't throw exception here
                    return;
                }
            } else {
                phraseProcessed = phrase;
            }

            if (confidence) {
                if (typeof (confidence) === "number") {
                    confidenceProcessed = confidence;
                } else {
                    confidenceProcessed = WinJS.Resources.getString(confidence);
                    if (confidenceProcessed && !confidenceProcessed.empty) {
                        confidenceProcessed = confidenceProcessed.value;
                    } else {
                        confidenceProcessed = confidence;
                    }

                    if (confidenceProcessed) {
                        try {
                            confidenceProcessed = parseFloat(confidenceProcessed);
                        } catch (e) {
                            confidenceProcessed = null;
                        }
                    }
                }
            }

            if (confidenceProcessed === 0.0 || isNaN(confidenceProcessed)) {
                confidenceProcessed = 0.0;
            }

            if (confidenceProcessed && (confidenceProcessed <= 0.0 || confidenceProcessed > 1.0)) {
                confidenceProcessed = 0.0;
            }

            if (pronunciation) {
                pronunciation = WinJS.Resources.getString(pronunciation);
                if (pronunciation && !pronunciation.empty) {
                    if (pronunciation.value.toUpperCase() !== "STRING_EMPTY") {
                        pronunciation = pronunciation.value;
                    } else {
                        pronunciation = null;
                    }
                } else {
                    pronunciation = null;
                }
            }
            
            phraseProcessed = phraseProcessed.trim();

            // Convert to lower case to standardize
            var phraseToMap = phraseProcessed.toLowerCase();
            if (_reverseGlobalCommands[phraseToMap]) {
                // throw new WinJS.ErrorFromName("XboxJS.UI.Voice.failedDuplicateGlobalCommand", strings.voiceFailedDuplicateGlobalCommand);
                return;
            }

            var id = document.uniqueID;
            _globalCommands[id] = {
                phrase: phraseProcessed,
                confidence: confidenceProcessed,
                handler: callback,
                pronunciation: pronunciation
            };
            // Create a reverse Mapping
            _reverseGlobalCommands[phraseToMap] = id;

            // If already listening, register it with the manager
            if (_status >= _VoiceManagerStatusType.ActiveListening) {
                var pObject = _registerPhrase(phraseProcessed, id, confidenceProcessed, pronunciation, false);
                if (pObject) {
                    _globalCommands[id].pObject = pObject;
                }
            }
        };

        var _unregisterGlobalCommand = function (phrase) {
            if (!phrase) {
                throw newWinJS.ErrorFromName("XboxJS.UI.Voice.missingPhraseFromGlobalCommandUnregistration", strings.voiceMissingPhraseFromGlobalCommandUnregistration);
                return;
            }
            if (typeof phrase !== "string") {
                throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidPhraseTypeFromGlobalCommandUnregistration", strings.voiceInvalidPhraseTypeFromGlobalCommandUnregistration);
                return;
            }

            // Convert to lower case to standardize
            var phraseToMap = phrase.toLowerCase();
            if (!_reverseGlobalCommands[phraseToMap]) {
                return;
            }

            var id = _reverseGlobalCommands[phraseToMap];
            // If listening, destroy and remove phrase
            if (_status >= _VoiceManagerStatusType.ActiveListening) {
                _unregisterPhrase(_globalCommands[id].pObject);
            }
            delete _globalCommands[id];
            delete _reverseGlobalCommands[phraseToMap];
        };

        var _onWindowResize = function (eventObject) {
            if (XboxJS && XboxJS.UI && XboxJS.UI.Voice) {
                XboxJS.UI.Voice.refreshVoiceElements(true);
            }
        };

        var _onPhraseConfirmed = function (eventObject, uniqueId) {
            if (XboxJS.Utilities._isTransitioning) {
                return;
            }

            var evtObject = {
                element: null,
                phrase: eventObject.phrase,
                actualUtterance: eventObject.actualUtterance,
                confidence: eventObject.confidence,
                speakerId: eventObject.speakerId
            };
            if (_elementMap[uniqueId]) {
                if (_elementMap[uniqueId].handler) {
                    evtObject.element = _elementMap[uniqueId].element;
                    _elementMap[uniqueId].handler(evtObject);
                } else if (_elementMap[uniqueId].element) {
                    _elementMap[uniqueId].element.click();
                }
            } else if (_globalCommands[uniqueId]) {
                if (_globalCommands[uniqueId].handler) {
                    _globalCommands[uniqueId].handler(evtObject);
                }
            }
        };

        var _onVuiManagerPhraseConfirmed = function (eventObject) {
            try {
                var uniqueId = eventObject.target.phrase.clientData;
                var evtObject = {
                    phrase: eventObject.target.matchedPhraseText,
                    actualUtterance: eventObject.target.actualUtterance,
                    confidence: eventObject.target.confidence,
                    speakerId: eventObject.target.speakerId
                };
                _onPhraseConfirmed(evtObject, uniqueId);
            } catch (e) {
                // ERROR - Ignore Error
            }
        };

        var _generateElementActivators = function (textElement, styleElement, styleClass, initialActivationStyleClass) {
            var _cachedPhrase = null;
            var _isActive = false;
            var _initialActivation = true;

             return {
                 activateElement : function (newPhrase) {
                     if (_isActive) {
                         return;
                     }
                     
                     if (textElement) {
                         _cachedPhrase = textElement.innerText;
                         textElement.innerText = newPhrase;
                         if (styleElement && initialActivationStyleClass && _initialActivation) {
                             _initialActivation = false;
                             styleElement.classList.add(initialActivationStyleClass);
                         }
                         if (styleElement && styleClass) {
                             styleElement.classList.add(styleClass);
                         }
                     }
                     _isActive = true;
                     return _isActive;
                 },   
                 deactivateElement : function () {
                     if (!_isActive) {
                         return;
                     }
                     if (textElement) {
                         textElement.innerText = _cachedPhrase;
                     }
                     if (styleElement && styleClass) {
                         styleElement.classList.remove(styleClass);
                     }
                     if (styleElement && initialActivationStyleClass) {
                         styleElement.classList.remove(initialActivationStyleClass);
                     }

                     _cachedPhrase = null;
                     _isActive = false;
                     return _isActive;
                },
            };
        };

        var _getEnumerationValue = function (enumName) {
            if (!_enumerations[enumName]) {
                return null;
            }

            var currentIndex = _enumerations[enumName].indexToUse;
            var enumToUse = null;
            if (_enumerations[enumName].enums instanceof Array) {
                var length = _enumerations[enumName].enums.length;
                if (currentIndex < length) {
                    enumToUse = {
                        phrase: _enumerations[enumName].enums[currentIndex].phrase,
                        confidence: _enumerations[enumName].enums[currentIndex].confidence,
                        pronunciation: _enumerations[enumName].enums[currentIndex].pronunciation
                    };
                    _enumerations[enumName].indexToUse = currentIndex + 1;
                }
            }

            return enumToUse; 
        };

        var _resetEnumerations = function () {
            for(var enumName in _enumerations) {
                _enumerations[enumName].indexToUse = 0;
            }
        };

        var _perElementProcessor = function (element, vuiOptionsString, initialTrigger) {
            var getContext = function (context) {
                if (context === 'element') {
                    return element;
                } else {
                    return null;
                }
            };
            WinJS.Utilities.markSupportedForProcessing(getContext);

            var select = function (value) { return value; };
            WinJS.Utilities.markSupportedForProcessing(select);

            var vuiOptions = null;
            try {
                vuiOptions = WinJS.UI.optionsParser(vuiOptionsString, global,
                                                       {
                                                           getContext : getContext, 
                                                           select : select
                                                       });
            } catch (e) {
            }
            if (!vuiOptions) {
                return;
            }
            if (!(vuiOptions instanceof Array)) {
                var tempOptions = [];
                tempOptions.push(vuiOptions);
                vuiOptions = tempOptions;
            }

            for (var i in vuiOptions) {
                var phrase = null;
                var fHandle = null;
                var disambHandlers = null;
                var currentSourceElement = null;
                var currentTargetElement = null;
                var elementBlingHandler = null;
                var confidence = null;
                var pronunciation = null;
                var selectedOptions = vuiOptions[i];

                if (selectedOptions.srcElement) {
                    if (selectedOptions.srcElement === "this") {
                        currentSourceElement = element;
                    } else {
                        currentSourceElement = element.querySelector(selectedOptions.srcElement);
                    }
                }

                if (selectedOptions.targetElement) {
                    if (selectedOptions.targetElement === "this") {
                        currentTargetElement = element;
                    } else {
                        currentTargetElement = element.querySelector(selectedOptions.targetElement);
                    }
                }

                if (currentTargetElement && parseInt(i) !== 0) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.Voice.tooManyVoiceBlingElements", strings.voicetooManyVoiceBlingElements);
                }

                if (currentSourceElement && !currentTargetElement) {
                    if (parseInt(i) === 0) {
                        currentTargetElement = currentSourceElement;
                    }
                }

                //
                // Is this an enumeration?
                //

                if (selectedOptions.enumerate) {
                    if (selectedOptions.phrase || selectedOptions.confidence || selectedOptions.pronunciation) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.enumerationConflictWithDeclrativePhrase", strings.voiceEnumerationConflictWithDeclrativePhrase);
                    }
                    var enumerationOptions = _getEnumerationValue(selectedOptions.enumerate);
                    if (!enumerationOptions) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.tooManyEnumerations", strings.voiceTooManyEnumerations);
                    }

                    selectedOptions.phrase = enumerationOptions.phrase;
                    selectedOptions.confidence = enumerationOptions.confidence;
                    selectedOptions.pronunciation = enumerationOptions.pronunciation;
                }

                if (selectedOptions.phrase) {
                    phrase = WinJS.Resources.getString(selectedOptions.phrase);
                    if (phrase && !phrase.empty) {
                        if (phrase.value.toUpperCase() !== "STRING_EMPTY") {
                            phrase = phrase.value;
                        } else {
                            phrase = null;
                        }
                    } else {
                        phrase = selectedOptions.phrase;
                    }
                }
                if (phrase) {
                    phrase = phrase.trim();
                }

                if ((!phrase || phrase.length === 0) && currentSourceElement){
                    phrase = currentSourceElement.innerText;
                    if (phrase) {
                        phrase = phrase.trim();
                    }
                }

                if (!phrase || phrase.length === 0) {
                    continue;
                }

                if (selectedOptions.confidence) {
                    if (typeof (selectedOptions.confidence) === "number") {
                        confidence = selectedOptions.confidence;
                    } else {
                        confidence = WinJS.Resources.getString(selectedOptions.confidence);
                        if (confidence && !confidence.empty) {
                            confidence = confidence.value;
                        } else {
                            confidence = selectedOptions.confidence;
                        }

                        if (confidence) {
                            try {
                                confidence = parseFloat(confidence);
                            } catch (e) {
                                confidence = null;
                            }
                        }
                    }
                }

                if (confidence === 0.0 || isNaN(confidence)) {
                    confidence = null;
                }

                if (confidence && (confidence <= 0.0 || confidence > 1.0)) {
                    confidence = null;
                }

                if (selectedOptions.pronunciation) {
                    pronunciation = WinJS.Resources.getString(selectedOptions.pronunciation);
                    if (pronunciation && !pronunciation.empty) {
                        if (pronunciation.value.toUpperCase() !== "STRING_EMPTY") {
                            pronunciation = pronunciation.value;
                        } else {
                            pronunciation = null;
                        }
                    } else {
                        pronunciation = null;
                    }
                }

                if (pronunciation && pronunciation.length === 0) {
                    pronunciation = null;
                }

                if (selectedOptions.handler) {
                    fHandle = selectedOptions.handler;
                } else {
                    // Is this a list view item?
                    if (WinJS.Utilities.hasClass(element, "win-voice-listviewitem")) {
                        var contextElement = element;
                        while(contextElement && !WinJS.Utilities.hasClass(contextElement, "win-item")) {
                            contextElement = contextElement.parentElement;
                        }
                        if (contextElement) {
                            fHandle = function () {
                                var selectedElement = contextElement;
                                return function () { selectedElement.click(); };
                            }();
                        }
                    }
                }

                // Create Bling And Disambiguation Handlers and Relevant Context
                if (currentTargetElement) {
                    if (initialTrigger) {
                        elementBlingHandler = _generateElementActivators(currentTargetElement, element, _activeListeningClassName, _initialActiveListeningClassName);
                    } else {
                        elementBlingHandler = _generateElementActivators(currentTargetElement, element, _activeListeningClassName);
                    }
                    disambHandlers = _generateElementActivators(currentTargetElement, element, _disambiguationListeningClassName);
                } else {
                    elementBlingHandler = null;
                    disambHandlers = null;
                }
                try {
                    _vuiManager.addElement({
                        element: element,
                        phrase: phrase,
                        handler: fHandle,
                        confidence: confidence,
                        pronunciation: pronunciation,
                        disambHandlers: disambHandlers,
                        blingHandlers: elementBlingHandler
                    });
                } catch (e) {
                    return;
                }
            }
        };

        var _onActiveListeningStartImpl = function (triggerEvents) {
            var focusRoot = null;
            if (_status < _VoiceManagerStatusType.Enabled || _status >= _VoiceManagerStatusType.ActiveListening) {
                return;
            }

            _status = _VoiceManagerStatusType.ActiveListening;

            if (XboxJS.Utilities._isTransitioning) {
                return;
            }

            focusRoot = XboxJS.UI.Voice.voiceRoot;
            if (!focusRoot && XboxJS.UI.AutomaticFocus) {
                focusRoot = XboxJS.UI.AutomaticFocus.focusRoot;
            }
            if (!focusRoot) {
                if (document.body) {
                    focusRoot = document.body;
                } else {
                    // If document.body is null, then the rest of the function will fail
                    // so we exit rather then throwing exceptions.
                    return;
                }
            }

            // Activate listeningstart event handlers
            if (triggerEvents) {
                XboxJS.UI.Voice.dispatchEvent("listeningstart", null);
            }
            // Activate voiceonly elements
            WinJS.Utilities.addClass(focusRoot, _voiceModeClassName);
            // Reset Enumerations
            _resetEnumerations();
            // Process each element under the focusRoot
            _processElementsWithSpecifiedFocusRoot(_perElementProcessor, focusRoot, triggerEvents);
            // Process Global Commands
            _enableGlobalCommands();
            // Call children iframes
            for (var iFrame in _iFrameMap) {
                var frame = _getFrameElement(iFrame);
                if (frame) {
                    if(_isElementOnScreen(frame, true) && _doesElementMatchActivationRequirement(frame)) {
                        _iFrameMap[iFrame].status = 1;
                        _iFrameMap[iFrame].window.postMessage({
                            ms__winJSVoiceControlPostMessage: {
                                type: _VmType.startActiveListening,
                                triggerEvents: triggerEvents
                            }
                        }, _iFrameMap[iFrame].domain);
                    }
                } else {
                    _clearIFrameGrammars(iFrame);
                    _iFrameMap[iFrame].window = null;
                    delete _iFrameMap[iFrame];
                }
            }
        };

        var _onActiveListeningStart = function (eventObject) {
            _onActiveListeningStartImpl(true);
        };

        var _onActiveListeningEndImpl = function (triggerEvents) {
            if (_status < _VoiceManagerStatusType.ActiveListening) {
                return;
            }

            // Even if you are navigating, you can end active listening

            for (var e in _elementMap) {
                if (_elementMap[e].inDisamb) {
                    _elementMap[e].inDisamb = false;
                    if (_elementMap[e].disambHandlers) {
                        _elementMap[e].disambHandlers.deactivateElement();
                    }
                }
                _removeElement(e);
            }
            // Process Global Commands
            _disableGlobalCommands();
            // Activate listeningend event handlers
            if (triggerEvents) {
                XboxJS.UI.Voice.dispatchEvent("listeningend", null);
            }
            // Deactivate voiceonly elements
            var voiceModeElements = document.body.querySelectorAll("." + _voiceModeClassName);
            for (var i = 0; i < voiceModeElements.length; i++) {
                var currentElement = voiceModeElements[i];
                WinJS.Utilities.removeClass(currentElement, _voiceModeClassName);
            }
            voiceModeElements = null;
            WinJS.Utilities.removeClass(document.body, _voiceModeClassName);
            // Call children iframes
            for (var iFrame in _iFrameMap) {
                var frame = _getFrameElement(iFrame);
                if (frame && _iFrameMap[iFrame].status > 0) {
                    _iFrameMap[iFrame].status = 0;
                    _iFrameMap[iFrame].window.postMessage({
                        ms__winJSVoiceControlPostMessage: {
                            type: _VmType.endActiveListening,
                            triggerEvents: triggerEvents
                        }
                    }, _iFrameMap[iFrame].domain);
                } else if (!frame) {
                    _clearIFrameGrammars(iFrame);
                    _iFrameMap[iFrame].window = null;
                    delete _iFrameMap[iFrame];
                }
            }

            _status = _VoiceManagerStatusType.Enabled;
        };

        var _onActiveListeningEnd = function (eventObject) {
            _onActiveListeningEndImpl(true);
        };

        var _onDisambiguationStart = function (candidates) {
            if (_status < _VoiceManagerStatusType.ActiveListening || _status >= _VoiceManagerStatusType.InDisambiguation) {
                return;
            }

            _status = _VoiceManagerStatusType.InDisambiguation;

            if (XboxJS.Utilities._isTransitioning) {
                return;
            }

            if (!candidates) {
                return;
            }
            // Clear iFrame Disamb data, if any
            for (var i in _iFrameDisambMap) {
                delete _iFrameDisambMap[i];
            }

            // Need to take the slow path, processing one at a time
            for (var e in _elementMap) {
                if (_elementMap[e].blingHandlers) {
                    _elementMap[e].blingHandlers.deactivateElement();
                }
                if (candidates[e]) {
                    if (_elementMap[e].disambHandlers) {
                        _elementMap[e].inDisamb = _elementMap[e].disambHandlers.activateElement(candidates[e]);
                    }
                }
            }
            // Call each iframe, with their respective disambiguation data
            for (var iFrame in _iFrameMap) {
                var frame = _getFrameElement(iFrame);
                if (frame && _iFrameMap[iFrame].status > 0) {
                    if (_iFrameDisambMap[iFrame]) {
                        _iFrameMap[iFrame].window.postMessage({
                            ms__winJSVoiceControlPostMessage: {
                                type: _VmType.startDisambiguation,
                                candidates: _iFrameDisambMap[iFrame].candidates
                            }
                        }, _iFrameMap[iFrame].domain);
                    } else {
                        _iFrameMap[iFrame].window.postMessage({
                            ms__winJSVoiceControlPostMessage: {
                                type: _VmType.startDisambiguation,
                                candidates: null
                            }
                        }, _iFrameMap[iFrame].domain);
                    }
                } else if (!frame) {
                    _clearIFrameGrammars(iFrame);
                    _iFrameMap[iFrame].window = null;
                    delete _iFrameMap[iFrame];
                }
            }
            // Clear iFrame Disamb data, if any
            for (var i in _iFrameDisambMap) {
                delete _iFrameDisambMap[i];
            } 
        };

        var _onVuiManagerDisambStart = function (eventObject) {
            try {
                var candidates = {};
                for (var i = 0; i < eventObject.target.candidates.size; i++) {
                    candidates[eventObject.target.candidates[i].phrase.clientData] = eventObject.target.candidates[i].disambiguationPhrase;
                }
                _onDisambiguationStart(candidates);
                candidates = null;
            } catch (e) {
                // ERROR - Ignore Error
            }
        };

        var _onDisambiguationEnd = function (eventObject) {
            if (_status !== _VoiceManagerStatusType.InDisambiguation) {
                return;
            }

            // Even if navigation is happening, disamb can end.

            // Process all elements
            for (var e in _elementMap) {
                if (_elementMap[e].inDisamb) {
                    _elementMap[e].inDisamb = false;
                    if (_elementMap[e].disambHandlers) {
                        _elementMap[e].disambHandlers.deactivateElement();
                    }
                }
                if (_elementMap[e].blingHandlers) {
                    _elementMap[e].blingHandlers.activateElement(_elementMap[e].phrase);
                }
            }
            // Call each iFrame and notify them
            for (var iFrame in _iFrameMap) {
                var frame = _getFrameElement(iFrame);
                if (frame && _iFrameMap[iFrame].status > 0) {
                    _iFrameMap[iFrame].window.postMessage({
                        ms__winJSVoiceControlPostMessage: {
                            type: _VmType.endDisambiguation
                        }
                    }, _iFrameMap[iFrame].domain);
                } else if (!frame) {
                    _clearIFrameGrammars(iFrame);
                    _iFrameMap[iFrame].window = null;
                    delete _iFrameMap[iFrame];
                }
            }

            _status = _VoiceManagerStatusType.ActiveListening;
        };

        var _removeElement = function (uniqueId) {
            if (_status < _VoiceManagerStatusType.Enabled) {
                return;
            }

            if (_elementMap[uniqueId]) {
                _unregisterPhrase(_elementMap[uniqueId].pObject);
                if (_elementMap[uniqueId].blingHandlers) {
                    _elementMap[uniqueId].blingHandlers.deactivateElement();
                }
                _elementMap[uniqueId].element = null;
                _elementMap[uniqueId] = null;
                delete _elementMap[uniqueId];
            }
        };

        var _addElement = function (uniqueId, element, handler, phrase, confidence, pronunciation, blingHandlers, disambHandlers, disambCapable) {
            if (_status < _VoiceManagerStatusType.ActiveListening) {
                return;
            }

            if (_elementMap[uniqueId]) {
                _removeElement(uniqueId);
            }
            var pObject = _registerPhrase(phrase, uniqueId, confidence, pronunciation, disambCapable);
            if (pObject) {
                if (blingHandlers) {
                    blingHandlers.activateElement(phrase);
                }
                _elementMap[uniqueId] = {
                    handler: handler,
                    phrase: phrase,
                    element: element,
                    pObject: pObject,
                    disambHandlers: disambHandlers,
                    blingHandlers: blingHandlers,
                    inDisamb: false,
                    disambCapable : disambCapable
                };
            }
        };

        var _clearIFrameGrammars = function (iFrameSource) {
            for (var e in _elementMap) {
                if (_elementMap[e].element === iFrameSource) {
                    _removeElement(e);
                }
            }
        };

        var _onVoiceMessage = function (eventObject) {
            // TODO: Trusted Domains Validation
            if (!eventObject.isTrusted) {
                // Not trusted
                return;
            }
            if (!eventObject.data || !eventObject.data.ms__winJSVoiceControlPostMessage) {
                // Unusable
                return;
            }
            var messageData = eventObject.data.ms__winJSVoiceControlPostMessage;
            var _messageType = messageData.type;

            if (_messageType === _VmType.addElement) {
                (function vmTypeAddElementHandler() {
                    var cachedId = messageData.id;
                    var phrase = messageData.phrase;
                    var confidence = messageData.confidence;
                    var pronunciation = messageData.pronunciation;
                    var disambCapable = messageData.disambCapable;
                    var source = _getFrameElement(messageData.clientId);
                    if (!source) {
                        return;
                    }

                    var uniqueId = _getUniqueIdForElement(source);
                    var messageSource = messageData.clientId;

                    if (!_iFrameMap[messageSource]) {
                        return;
                    }
                    if(_iFrameMap[messageSource].status !== 1) {
                        return;
                    }

                    if (_status < _VoiceManagerStatusType.ActiveListening) {
                        return;
                    }

                    //  Validate Input
                    if (!cachedId || !phrase || typeof phrase !== "string" || typeof confidence !== "number" 
                        || confidence < 0.0 || confidence > 1.0 ) {
                        return;
                    }
                    if (pronunciation) {
                        if (typeof pronunciation !== "string") {
                            return;
                        }
                    } else {
                        pronunciation = null;
                    }
                    if (!disambCapable) {
                        disambCapable = false;
                    }
                    phrase = phrase.trim();

                    var handler = function () {
                        var window_to_target = source.contentWindow;
                        var origin = eventObject.origin;
                        return function (eventObject) {
                            window_to_target.postMessage({
                                ms__winJSVoiceControlPostMessage: {
                                    type: _VmType.matchPhrase,
                                    id: cachedId,
                                    phrase: eventObject.phrase,
                                    confidence: eventObject.confidence,
                                    actualUtterance: eventObject.actualUtterance
                                }
                            }, origin);
                        };
                    }();

                    var disambHandlers = function() {
                        var ms = messageSource;
                        var id = cachedId;
                        var capable = disambCapable;
                        return {
                            activateElement : function (newPhrase) {
                                if (!capable) {
                                    return false;
                                }
                                if (!_iFrameDisambMap[ms]) {
                                    _iFrameDisambMap[ms] = { candidates: {} };
                                }
                                _iFrameDisambMap[ms].candidates[id] = newPhrase;
                                return true;
                            },
                            deactivateElement : function () {
                                if (_iFrameDisambMap[ms] && _iFrameDisambMap[ms].candidates[id]) {
                                    delete _iFrameDisambMap[ms].candidates[id];
                                }
                            }
                        };
                    }();

                    _addElement(uniqueId + cachedId, messageSource, handler, phrase, confidence, pronunciation, null, disambHandlers, disambCapable);
                })();
            } else if (_messageType === _VmType.removeElement) {
                (function vmTypeRemoveElementHandler() {
                    var cachedId = messageData.id;
                    var source = _getFrameElement(messageData.clientId);
                    if (!source) {
                        return;
                    }

                    var uniqueId = _getUniqueIdForElement(source);
                    if (!_iFrameMap[messageData.clientId]) {
                        return;
                    }
                    if (_status < _VoiceManagerStatusType.Enabled) {
                        return;
                    }

                    //  Validate Input
                    if (!cachedId) {
                        return;
                    }
                    _removeElement(uniqueId + cachedId);
                })();
            } else if (_messageType === _VmType.startActiveListening) {
                if (inIFrame) {
                    _onActiveListeningStartImpl(messageData.triggerEvents);
                }
            } else if (_messageType === _VmType.endActiveListening) {
                if (inIFrame) {
                    _onActiveListeningEndImpl(messageData.triggerEvents);
                }
            } else if (_messageType === _VmType.startDisambiguation) {
                if (inIFrame) {
                    _onDisambiguationStart(messageData.candidates);
                }
            } else if (_messageType === _VmType.endDisambiguation) {
                if (inIFrame) {
                    _onDisambiguationEnd();
                }
            } else if (_messageType === _VmType.matchPhrase) {
                if (inIFrame) {
                    var phrase = messageData.phrase;
                    var confidence = messageData.confidence;
                    var actualUtterance = messageData.actualUtterance;
                    var cachedId = messageData.id;

                    //  Validate Input
                    if (!cachedId || !phrase || typeof phrase !== "string" ||
                        typeof confidence !== "number" || !actualUtterance || typeof actualUtterance !== "string") {
                        return;
                    }
                        
                    var eObject = {
                        phrase: phrase,
                        confidence: confidence,
                        actualUtterance: actualUtterance
                    };
                    _onPhraseConfirmed(eObject, cachedId);
                }
            } else if (_messageType === _VmType.registerChild) {
                var source = _getFrameElement(messageData.clientId);
                if (!source) {
                    return;
                }

                if (_iFrameMap[messageData.clientId]) {
                    return;
                }

                //
                // Clear stale junk if overriding iframe values
                //
                for (var i in _iFrameMap) {
                    var tempFrame = _getFrameElement(i);
                    if (tempFrame === source) {
                        // Same as current attempt to register
                        _clearIFrameGrammars(i);
                        _iFrameMap[i].window = null;
                        delete _iFrameMap[i];
                    }
                }

                _iFrameMap[messageData.clientId] = {
                    status: 0,
                    window: source.contentWindow,
                    domain: eventObject.origin
                };

                if (_status >= _VoiceManagerStatusType.ActiveListening) {
                    if (_iFrameMap[messageData.clientId].status !== 1) {
                        if (_isElementOnScreen(source, true)) {
                            _iFrameMap[messageData.clientId].status = 1;
                            _iFrameMap[messageData.clientId].window.postMessage({
                                ms__winJSVoiceControlPostMessage: {
                                    type: _VmType.startActiveListening
                                }
                            }, _iFrameMap[messageData.clientId].domain);
                        }
                    }
                }
            } else if (_messageType === _VmType.unregisterChild) {
                var source = _getFrameElement(messageData.clientId);
                if (!source) {
                    return;
                }

                if (_iFrameMap[messageData.clientId]) {
                    _clearIFrameGrammars(messageData.clientId);
                    _iFrameMap[messageData.clientId].window = null;
                    delete _iFrameMap[messageData.clientId];
                }
            } else {
                // no-op
            }
        };

        var _onDomMessage = function (messageData) {
            var _messageType = messageData.type;

            if (_messageType === _VmType.startActiveListening) {
                _onActiveListeningStart();
            } else if (_messageType === _VmType.endActiveListening) {
                _onActiveListeningEnd();
            } else if (_messageType === _VmType.matchPhrase) {
                if (_status < _VoiceManagerStatusType.ActiveListening) {
                    return;
                }
                var ph = messageData.phrase;
                for (var e in _elementMap) {
                    if (_elementMap[e].phrase === ph) {
                        _onPhraseConfirmed({ actualUtterance: ph, confidence: 0.5, phrase: ph }, e);
                        break;
                    }
                }
            } else {
                // no-op
            }
        };

        var _enableVM = function () {
            if (_status >= _VoiceManagerStatusType.Enabled) {
                return;
            }

            // Register for window messages
            window.addEventListener("message", _onVoiceMessage);
            window.addEventListener("resize", _onWindowResize);

            // Register for navigation messages
            if (WinJS && WinJS.Navigation && XboxJS.UI.Pages) {
                WinJS.Navigation.addEventListener("navigated", function () {
                                                                   if (!WinJS.UI.isAnimationEnabled()) {
                                                                       XboxJS.UI.Voice.refreshVoiceElements(true);
                                                                   }
                                                               });

                XboxJS.UI.Pages.addEventListener("pagetransitioned", function() {
                                                                         if (WinJS.UI.isAnimationEnabled()) {
                                                                             XboxJS.UI.Voice.refreshVoiceElements(true);
                                                                         }
                                                                     });
            }

            if (!inIFrame) {
                if (!WinJS.Utilities.hasWinRT || !Windows || !Windows.Xbox || !Windows.Xbox.Speech || !Windows.Xbox.Speech.VuiManager) {
                    _isTestMode = true;
                    _status = _VoiceManagerStatusType.Enabled;
                    return;
                }
                try {
                    _voiceManager = Windows.Xbox.Speech.VuiManager.VuiManager.getInstance();
                    _voiceManager.addEventListener("systemactivelisteningstart", _onActiveListeningStart);
                    _voiceManager.addEventListener("systemactivelisteningend", _onActiveListeningEnd);
                    _voiceManager.addEventListener("phraseconfirmed", _onVuiManagerPhraseConfirmed);
                    _voiceManager.addEventListener("disambiguationstart", _onVuiManagerDisambStart);
                    _voiceManager.addEventListener("disambiguationend", _onDisambiguationEnd);
                    setImmediate(function () {
                        if (_voiceManager &&
                            (_status === _VoiceManagerStatusType.Enabled) &&
                            (_voiceManager.listeningState === Windows.Xbox.Speech.VuiManager.VuiManagerListeningState.openListening)) {
                            _onActiveListeningStartImpl(true);
                        }
                    });
                } catch (e) {
                    _voiceManager = null;
                    return;
                }
            } else {
                window.parent.postMessage({
                    ms__winJSVoiceControlPostMessage: {
                        type: _VmType.registerChild,
                        clientId: _getCurrentPageUrl(),
                        version: 1.0
                    }
                }, "*");
            }
            _status = _VoiceManagerStatusType.Enabled;
        };

        var _disableVM = function () {
            if (_status < _VoiceManagerStatusType.Enabled) {
                return;
            }

            if (!inIFrame) {
                try {
                    if (_voiceManager) {
                        _voiceManager.removeEventListener("phraseconfirmed", _onVuiManagerPhraseConfirmed);
                        _voiceManager.removeEventListener("systemactivelisteningstart", _onActiveListeningStart);
                        _voiceManager.removeEventListener("systemactivelisteningend", _onActiveListeningEnd);
                        _voiceManager.removeEventListener("disambiguationstart", _onVuiManagerDisambStart);
                        _voiceManager.removeEventListener("disambiguationend", _onDisambiguationEnd);
                    }
                } catch (e) {
                }
            } else {
                window.parent.postMessage({
                    ms__winJSVoiceControlPostMessage: {
                        type: _VmType.unregisterChild,
                        clientId: _getCurrentPageUrl()
                    }
                }, "*");
            }

            _onActiveListeningEnd();
            _status = _VoiceManagerStatusType.None;

            // Unregister Window messages
            window.removeEventListener("message", _onVoiceMessage);
            window.removeEventListener("resize", _onWindowResize);

            if (_voiceManager) {
                _voiceManager.shutdown();
                _voiceManager = null;
            }
        };

        var _refreshVoiceElementsImpl = function () {
            if (_status < _VoiceManagerStatusType.ActiveListening) {
                _pendingRefresh = false;
                _timerId = null;
                return;
            }

            _onActiveListeningEndImpl(false);
            _onActiveListeningStartImpl(false);
            _pendingRefresh = false;
            _timerId = null;
        };

        var _disableAutomaticVoiceRefreshImpl = function () {
            _disableNonForcedRefresh = true;
        };

        var _enableAutomaticVoiceRefreshImpl = function () {
            _disableNonForcedRefresh = false;
        };

        var _getDefaultConfidence = function () {
            if (_voiceManager) {
                return _voiceManager.defaultConfidenceThreshold;
            }
            
            return 0.0
        };

        var _setDefaultConfidence = function (value) {
            if (_voiceManager) {
                _voiceManager.defaultConfidenceThreshold = value;
            }
        };

        return {
            enableVoiceManager: _enableVM,
            disableVoiceManager: _disableVM,
            disableAutomaticVoiceRefresh: _disableAutomaticVoiceRefreshImpl,
            enableAutomaticVoiceRefresh: _enableAutomaticVoiceRefreshImpl,
            refreshVoiceElements: function refreshVoice(force) {
                if (_pendingRefresh) {
                    if (_timerId) {
                        clearTimeout(_timerId);
                        _timerId = null;
                    }
                }
                if (force) {
                    if (_timerId) {
                        clearTimeout(_timerId);
                        _timerId = null;
                    }
                    setImmediate(function () { _refreshVoiceElementsImpl() } );
                } else if (!_disableNonForcedRefresh) {
                    _timerId = setTimeout(function() {
                                   XboxJS.UI.Voice.refreshVoiceElements(true);
                                   }, _voiceRefreshTimeout);
                    _pendingRefresh = true;
                }
            },

            addElement: function (elementObject) {
                if (_status < _VoiceManagerStatusType.ActiveListening) {
                    return;
                }

                var uniqueId = _getUniqueIdForElement(elementObject.element);
                var handler = elementObject.handler;
                var phrase = elementObject.phrase;
                var confidence = elementObject.confidence;
                var pronunciation = elementObject.pronunciation;
                var disambHandlers = elementObject.disambHandlers;
                var blingHandlers = elementObject.blingHandlers;

                if (phrase) {
                    phrase = phrase.trim();
                }
                if (!phrase || typeof phrase !== "string" || phrase.length === 0) {
                    return;
                }
                  
                if (handler) {
                    if (typeof handler !== "function" ) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidHandlerTypeFromStandardCommandRegistration", strings.voiceInvalidHandlerTypeFromStandardCommandRegistration);
                        return;
                    }
                } else {
                    handler = null;
                }

                if (confidence) {
                    if (typeof confidence !== "number") {
                        WinJS.ErrorFromName("XboxJS.UI.Voice.invalidConfidenceTypeFromStandardCommandRegistration", strings.voiceInvalidConfidenceTypeFromStandardCommandRegistration);
                        return;
                    }
                    if (confidence < 0.0 || confidence > 1.0) {
                        WinJS.ErrorFromName("XboxJS.UI.Voice.invalidConfidenceValueFromStandardCommandRegistration", strings.voiceInvalidConfidenceValueFromStandardCommandRegistration);
                        return;
                    }
                } else {
                    confidence = 0.0;
                }

                if (pronunciation) {
                    if (typeof pronunciation !== "string") {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidPronunciationTypeFromStandardCommandRegistration", strings.voiceInvalidPronunciationTypeFromStandardCommandRegistration);
                        return;
                    }
                    if (pronunciation.length === 0) {
                        pronunciation = null;
                    }
                } else {
                    pronunciation = null;
                }

                if (disambHandlers) {
                    if (typeof disambHandlers !== "object") {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidDisambiguationHandlersTypeFromStandardCommandRegistration", strings.voiceInvalidDisambiguationHandlersTypeFromStandardCommandRegistration);
                        return;
                    }    
                    if (!disambHandlers.activateElement || typeof disambHandlers.activateElement !== "function") {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidDisambiguationStartHandlerFromStandardCommandRegistration", strings.voiceInvalidDisambiguationStartHandlerFromStandardCommandRegistration);
                        return;
                    }   
                    if (!disambHandlers.deactivateElement || typeof disambHandlers.deactivateElement !== "function") {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidDisambiguationEndHandlerFromStandardCommandRegistration", strings.voiceInvalidDisambiguationEndHandlerFromStandardCommandRegistration);
                        return;
                    }
                } else {
                    disambHandlers = null;
                }

                if (blingHandlers) {
                    if (typeof blingHandlers !== "object") {
                        WinJS.ErrorFromName("XboxJS.UI.Voice.invalidBlingHandlersTypeFromStandardCommandRegistration", strings.voiceInvalidBlingHandlersTypeFromStandardCommandRegistration);
                        return;
                    }        
                    if (!blingHandlers.activateElement || typeof blingHandlers.activateElement !== "function") {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidBlingStartHandlerFromStandardCommandRegistration", strings.voiceInvalidBlingStartHandlerFromStandardCommandRegistration);
                        return;
                    }   
                    if (!blingHandlers.deactivateElement || typeof blingHandlers.deactivateElement !== "function") {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Voice.invalidBlingEndHandlerFromStandardCommandRegistration", strings.voiceInvalidBlingEndHandlerFromStandardCommandRegistration);
                        return;
                    }
                } else {
                    blingHandlers = null;
                }

                _addElement(uniqueId + phrase, elementObject.element, handler, phrase, confidence, pronunciation, blingHandlers, disambHandlers, (disambHandlers === null) ? false : true);
                return true;
            },

            removeElement: function (element, phrase) {
                var uniqueId = _getUniqueIdForElement(element);
                _removeElement(uniqueId + phrase);
            },

            getDefaultConfidence: _getDefaultConfidence,
            setDefaultConfidence: _setDefaultConfidence,

            registerEnumeration: _registerEnumeration,
            unregisterEnumeration: _unregisterEnumeration,

            registerGlobalCommand: _registerGlobalCommand,
            unregisterGlobalCommand: _unregisterGlobalCommand,
            onDomMessage: _onDomMessage, // TEST TEST TEST
        };
    };

    //
    // Initialize VUI Manager
    //

    if (!_vuiManager) {
        //
        // Initialize VUI Manager
        //
        if (window.top === window.self) {
            //
            // Will use WinRT VUI Manager
            //
            _vuiManager = _getVoiceManager([], false);
        } else {
            //
            // Will channel events up to parent
            //
            _vuiManager = _getVoiceManager([], true);
        }

        //
        // Enable Vui Manager
        //
        _vuiManager.enableVoiceManager();
    }

    WinJS.Namespace.define("XboxJS.UI.Voice", {
        VmType: _VmType,

        DisambiguationState: _DisambiguationState,

        /// <signature helpKeyword="XboxJS.UI.Voice.refreshVoiceElements">
        /// <summary locid="XboxJS.UI.Voice.refreshVoiceElements">
        /// Refreshes the voice elements registered with the system based on
        /// what is present on the screen at the given time.
        /// </summary>
        /// </signature>
        refreshVoiceElements: function (force) {
            if (_vuiManager) {
                _vuiManager.refreshVoiceElements(force);
            }
        },

        /// <field type="Object" locid="XboxJS.UI.Voice.defaultConfidence" helpKeyword="XboxJS.UI.Voice.defaultConfidence">
        /// Get or set the default confidence level to use with voice commands. Defaults to 0.75. Valid values are between 0.0 and 1.0
        /// </field>
        defaultConfidence: {
            get: function () {
                return _vuiManager.getDefaultConfidence();
            },
            set: function (value) {
                if (value > 0.0 && value <= 1.0) {
                    _vuiManager.setDefaultConfidence(value);
                } else {
                    WinJS.ErrorFromName("XboxJS.UI.Voice.invalidDefaultConfidenceValue", strings.voiceInvalidDefaultConfidenceValue);
                }
            }
        },

        /// <field type="Object" locid="XboxJS.UI.Voice.disableAutomaticVoiceRefresh" helpKeyword="XboxJS.UI.Voice.disableAutomaticVoiceRefresh">
        /// Disable automatic voice refresh for WinJS Controls
        /// </field>
        disableAutomaticVoiceRefresh: function () {
            if (_vuiManager) {
                _vuiManager.disableAutomaticVoiceRefresh();
            }
        },

        /// <field type="Object" locid="XboxJS.UI.Voice.enableAutomaticVoiceRefresh" helpKeyword="XboxJS.UI.Voice.enableAutomaticVoiceRefresh">
        /// Enable automatic voice refresh for WinJS Controls
        /// </field>
        enableAutomaticVoiceRefresh: function () {
            if (_vuiManager) {
                _vuiManager.enableAutomaticVoiceRefresh();
            }
        },

        /// <signature helpKeyword="XboxJS.UI.Voice.disableVoiceManager">
        /// <summary locid="XboxJS.UI.Voice.disableVoiceManager">
        /// Disables the Voice Manager
        /// </summary>
        /// </signature>
        disableVoiceManager: function () {
            if (_vuiManager) {
                _vuiManager.disableVoiceManager();
            }
        },

        /// <signature helpKeyword="XboxJS.UI.Voice.enableVoiceManager">
        /// <summary locid="XboxJS.UI.Voice.enableVoiceManager">
        /// Enables the Voice Manager
        /// </summary>
        /// </signature>
        enableVoiceManager: function () {
            if (_vuiManager) {
                _vuiManager.enableVoiceManager();
            }
        },

        /// <signature helpKeyword="XboxJS.UI.Voice.registerGlobalCommand">
        /// <summary locid="XboxJS.UI.Voice.registerGlobalCommand">
        /// Adds a global command and an associated callback handler
        /// <param name="phrase" type="String" locid="XboxJS.UI.Voice.registerGlobalCommand_p:phrase">
        /// The phrase to register for the global command. Required
        /// </param>
        /// <param name="callback" type="Object" locid="XboxJS.UI.Voice.registerGlobalCommand_p:callback">
        /// The callback to call when the phrase is matched. Required
        /// </param>
        /// <param name="confidence" type="Number" locid="XboxJS.UI.Voice.registerGlobalCommand_p:confidence">
        /// The confidence to match the phrase at. Values valid between 0.0 and 1.0. Optional
        /// </param>
        /// <param name="pronunciation" type="String" locid="XboxJS.UI.Voice.registerGlobalCommand_p:pronunciation">
        /// The pronunciation of the phrase. Optional
        /// </param>
        /// </summary>
        /// </signature>
        registerGlobalCommand: function (phrase, callback, confidence, pronunciation) { return _vuiManager.registerGlobalCommand(phrase, callback, confidence, pronunciation); },

        /// <signature helpKeyword="XboxJS.UI.Voice.unregisterGlobalCommand">
        /// <summary locid="XboxJS.UI.Voice.unregisterGlobalCommand">
        /// Removes a previously registered global command.
        /// <param name="phrase" type="String" locid="XboxJS.UI.Voice.unregisterGlobalCommand_p:phrase">
        /// The phrase to unregister from the global grammar. This must be the same phrase as the one used to register. Required.
        /// </param>
        /// </summary>
        /// </signature>
        unregisterGlobalCommand: function (arg) { return _vuiManager.unregisterGlobalCommand(arg); },

        /// <field type="Function" locid="XboxJS.UI.Voice.registerEnumeration" helpKeyword="XboxJS.UI.Voice.registerEnumeration">
        /// Register a new enumeration
        /// </field>
        registerEnumeration : function (enumName, arrayOfEnums) {
            _vuiManager.registerEnumeration(enumName, arrayOfEnums);
        },

        /// <field type="Function" locid="XboxJS.UI.Voice.unregisterEnumeration" helpKeyword="XboxJS.UI.Voice.unregisterEnumeration">
        /// Unregister a previously registered enumeration
        /// </field>
        unregisterEnumeration : function (enumName) {
            _vuiManager.unregisterEnumeration(enumName);
        },

        /// <field type="Object" locid="XboxJS.UI.Voice.voiceRoot" helpKeyword="XboxJS.UI.Voice.voiceRoot">
        /// Get or set the DOM element that acts as the root of the elements to activate when voice is active.
        /// If not set, the default root is the focusRoot specified in XboxJS.UI.AutomaticFocus.
        /// If the focusRoot is not specified, the BODY element is used.
        /// </field>
        voiceRoot: {
            get: function () {
                return _voiceRoot;
            },
            set: function (value) {
                _voiceRoot = value;
                XboxJS.UI.Voice.refreshVoiceElements();
            }
        },


        onDomMessage: function (messageData) { _vuiManager.onDomMessage(messageData); }, // TEST TEST TEST
    });

    XboxJS.UI.Voice.prototype = XboxJS.UI.Voice;
    WinJS.Class.mix(XboxJS.UI.Voice, WinJS.Utilities.eventMixin);

    // Statics
    var strings = {
        get voiceMissingPhraseFromGlobalCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceMissingPhraseFromGlobalCommandRegistration").value; },
        get voiceInvalidPhraseTypeFromGlobalCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidPhraseTypeFromGlobalCommandRegistration").value; },
        get voiceMissingHandlerFromGlobalCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceMissingHandlerFromGlobalCommandRegistration").value; },
        get voiceInvalidHandlerTypeFromGlobalCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidHandlerTypeFromGlobalCommandRegistration").value; },
        get voiceInvalidConfidenceValueFromGlobalCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidConfidenceValueFromGlobalCommandRegistration").value; },
        get voiceInvalidPronunciationTypeFromGlobalCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidPronunciationTypeFromGlobalCommandRegistration").value; },
        get voiceFailedDuplicateGlobalCommand() { return WinJS.Resources._getWinJSString("tv/voiceFailedDuplicateGlobalCommand").value; },
        get voiceMissingPhraseFromGlobalCommandUnregistration() { return WinJS.Resources._getWinJSString("tv/voiceMissingPhraseFromGlobalCommandUnregistration").value; },
        get voiceInvalidPhraseTypeFromGlobalCommandUnregistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidPhraseTypeFromGlobalCommandUnregistration").value; },
        get voiceInvalidHandlerTypeFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidHandlerTypeFromStandardCommandRegistration").value; },
        get voiceInvalidConfidenceTypeFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidConfidenceTypeFromStandardCommandRegistration").value; },
        get voiceInvalidConfidenceValueFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidConfidenceValueFromStandardCommandRegistration").value; },
        get voiceInvalidPronunciationTypeFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/voiceInvalidPronunciationTypeFromStandardCommandRegistration").value; },
        get voiceInvalidDefaultConfidenceValue() { return WinJS.Resources._getWinJSString("tv/voiceInvalidDefaultConfidenceValue").value; },
        get voicetooManyVoiceBlingElements() { return WinJS.Resources._getWinJSString("tv/voicetooManyVoiceBlingElements").value; },
        get voiceTargetElementRequiresSourceElement() { return WinJS.Resources._getWinJSString("tv/voiceTargetElementRequiresSourceElement").value; },
        get invalidDisambiguationHandlersTypeFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/invalidDisambiguationHandlersTypeFromStandardCommandRegistration").value; },
        get invalidDisambiguationStartHandlerFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/invalidDisambiguationStartHandlerFromStandardCommandRegistration").value; },
        get invalidDisambiguationEndHandlerFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/invalidDisambiguationEndHandlerFromStandardCommandRegistration").value; },
        get invalidBlingHandlersTypeFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/invalidBlingHandlersTypeFromStandardCommandRegistration").value; },
        get invalidBlingStartHandlerFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/invalidBlingStartHandlerFromStandardCommandRegistration").value; },
        get invalidBlingEndHandlerFromStandardCommandRegistration() { return WinJS.Resources._getWinJSString("tv/invalidBlingEndHandlerFromStandardCommandRegistration").value; },
    };

})(this);


(function hubInit(global, WinJS, undefined) {
    "use strict";

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.Hub">
        /// Displays sections of content.
        /// </summary>
        /// <icon src="ui_xboxjs.ui.hub.12x12.png" width="12" height="12" />
        /// <icon src="ui_xboxjs.ui.hub.16x16.png" width="16" height="16" />
        /// <htmlSnippet supportsContent="true"><![CDATA[<div data-win-control="XboxJS.UI.Hub">
        /// <div data-win-control="XboxJS.UI.HubSection" data-win-options="{header: 'HubSection Header'}">HubSection Content</div>
        /// </div>]]></htmlSnippet>
        /// <event name="contentanimating" bubbles="true" locid="XboxJS.UI.Hub_e:contentanimating">Raised when the Hub is about to play an entrance or a transition animation.</event>
        /// <event name="headerinvoked" bubbles="true" locid="XboxJS.UI.Hub_e:headerinvoked">Raised when a header is invoked.</event>
        /// <event name="loadingstatechanged" bubbles="true" locid="XboxJS.UI.Hub_e:loadingstatechanged">Raised when the loading state changes.</event>
        /// <part name="hub" class="win-hub" locid="XboxJS.UI.Hub_part:hub">The entire Hub control.</part>
        /// <part name="progress" class="win-hub-progress" locid="XboxJS.UI.Hub_part:progress">The progress indicator for the Hub.</part>
        /// <part name="viewport" class="win-hub-viewport" locid="XboxJS.UI.Hub_part:viewport">The viewport of the Hub.</part>
        /// <part name="surface" class="win-hub-surface" locid="XboxJS.UI.Hub_part:surface">The scrollable region of the Hub.</part>
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.Xbox.WinJS.1.0/css/ui-dark.css" shared="true" />
        Hub: WinJS.Namespace._lazy(function () {
            function hubResize(ev) {
                var hub = ev.srcElement && ev.srcElement.winControl;
                if (hub && hub._resizeHandler) {
                    hub._resizeHandler(ev);
                }
            }

            function hubContentResize(ev) {
                var hub = ev.srcElement && ev.srcElement.parentNode && ev.srcElement.parentNode.parentNode && ev.srcElement.parentNode.parentNode.winControl;
                if (hub && hub._contentResizeHandler) {
                    hub._contentResizeHandler(ev);
                }
            }

            function hubDefaultHeaderTemplate(section) {
                var element = document.createTextNode(typeof section.header === "object" ? JSON.stringify(section.header) : ('' + section.header));
                return element;
            }

            var createEvent = WinJS.Utilities._createEventProperty;
            var eventNames = {
                contentAnimating: "contentanimating",
                headerInvoked: "headerinvoked",
                loadingStateChanged: "loadingstatechanged"
            };

            // Delay time before progress dots are shown when loading hub section(s) on screen.
            var progressDelay = 500;

            var verticalNames = {
                scrollPos: "scrollTop",
                scrollSize: "scrollHeight",
                offsetPos: "offsetTop",
                offsetSize: "offsetHeight",
                oppositeOffsetSize: "offsetWidth",
                marginStart: "marginTop",
                marginEnd: "marginBottom",
                borderStart: "borderTopWidth",
                borderEnd: "borderBottomWidth",
                paddingStart: "paddingTop",
                paddingEnd: "paddingBottom",
                start: "top"
            };
            var rtlHorizontalNames = {
                scrollPos: "scrollLeft",
                scrollSize: "scrollWidth",
                offsetPos: "offsetLeft",
                offsetSize: "offsetWidth",
                oppositeOffsetSize: "offsetHeight",
                marginStart: "marginRight",
                marginEnd: "marginLeft",
                borderStart: "borderRightWidth",
                borderEnd: "borderLeftWidth",
                paddingStart: "paddingRight",
                paddingEnd: "paddingLeft",
                start: "right"
            };
            var ltrHorizontalNames = {
                scrollPos: "scrollLeft",
                scrollSize: "scrollWidth",
                offsetPos: "offsetLeft",
                offsetSize: "offsetWidth",
                oppositeOffsetSize: "offsetHeight",
                marginStart: "marginLeft",
                marginEnd: "marginRight",
                borderStart: "borderLeftWidth",
                borderEnd: "borderRightWidth",
                paddingStart: "paddingLeft",
                paddingEnd: "paddingRight",
                start: "left"
            };



            var Hub = WinJS.Class.define(function Hub_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.Hub.Hub">
                /// <summary locid="XboxJS.UI.Hub.constructor">
                /// Creates a new Hub.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.Hub.constructor_p:element">
                /// The DOM element that hosts the Hub control.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.Hub.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// Event names must begin with "on". For example, to provide a handler for the contentanimating event,
                /// add a property named "oncontentanimating" to the options object and set its value to the event handler.
                /// </param>
                /// <returns type="XboxJS.UI.Hub" locid="XboxJS.UI.Hub.constructor_returnValue">
                /// The new Hub.
                /// </returns>
                /// </signature>
                element = element || document.createElement("DIV");
                options = options || {};

                if (element.winControl) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.Hub.DuplicateConstruction", strings.duplicateConstruction);
                }

                this._id = element.id || element.uniqueID;
                this._writeProfilerMark("constructor,StartTM");

                this._windowKeyDownHandlerBound = this._windowKeyDownHandler.bind(this);
                window.addEventListener('keydown', this._windowKeyDownHandlerBound);

                // Attaching JS control to DOM element
                element.winControl = this;
                this._element = element;
                WinJS.Utilities.addClass(this.element, XboxJS.UI.Hub._ClassName.hub);
                WinJS.Utilities.addClass(this.element, "win-disposable");

                this._viewportElement = document.createElement("DIV");
                this._viewportElement.className = XboxJS.UI.Hub._ClassName.hubViewport;
                this._element.appendChild(this._viewportElement);
                this._viewportElement.setAttribute("role", "group");
                this._viewportElement.setAttribute("aria-label", strings.hubViewportAriaLabel);

                this._surfaceElement = document.createElement("DIV");
                this._surfaceElement.className = XboxJS.UI.Hub._ClassName.hubSurface;
                this._viewportElement.appendChild(this._surfaceElement);

                // Start invisible so that you do not see the content loading until the sections are ready.
                this._visible = false;
                this._viewportElement.style.opacity = 0;

                if (!options.orientation) {
                    this._orientation = WinJS.UI.Orientation.horizontal;
                    WinJS.Utilities.addClass(this.element, XboxJS.UI.Hub._ClassName.hubHorizontal);
                }

                this._fireEntrance = true;
                this._animateEntrance = true;
                this._loadId = 0;
                this.runningAnimations = new WinJS.Promise.wrap();
                this._currentIndexForSezo = 0;

                this._previousFocusRoot = null;
                // 100 is the size of the title safe area in pixels
                this._leftBoundaryToTriggerFixedFocusMode = 100;
                this._rightBoundaryToTriggerFixedFocusMode = window.innerWidth - this._leftBoundaryToTriggerFixedFocusMode;

                // This internally assigns this.sections which causes section to be used (even from options) before
                // scrollPosition or sectionOnScreen.
                this._parse();

                WinJS.UI.setOptions(this, options);

                this.element.addEventListener("focusin", this._focusin.bind(this));
                this.element.addEventListener("keydown", this._keyDownHandler.bind(this));
                this.element.addEventListener("click", this._clickHandler.bind(this));
                this.element.addEventListener("mselementresize", hubResize);
                this._viewportElement.addEventListener("scroll", this._scrollHandler.bind(this));
                this._surfaceElement.addEventListener("mselementresize", hubContentResize);

                this._handleSectionChangedBind = this._handleSectionChanged.bind(this);
                this._handleSectionInsertedBind = this._handleSectionInserted.bind(this);
                this._handleSectionMovedBind = this._handleSectionMoved.bind(this);
                this._handleSectionRemovedBind = this._handleSectionRemoved.bind(this);
                this._handleSectionReloadBind = this._handleSectionReload.bind(this);

                if (XboxJS) {
                    this._nextPageBind = this._nextPage.bind(this);
                    this._previousPageBind = this._previousPage.bind(this);

                    // Append the voice elements
                    var nextPreviousPageVoiceElements = document.createElement("div");
                    nextPreviousPageVoiceElements.className = XboxJS.UI.Hub._ClassName.previousNextVoiceContainer;
                    nextPreviousPageVoiceElements.innerHTML = '<div class="' + XboxJS.UI.Hub._ClassName.previousPageLabel + ' win-hidden" data-win-voice="{' +
                                                                                           ' phrase: \'' + XboxJS.UI.Voice.getWinJSStringName('tv/PREVIOUS_PAGE_COMMAND_VUI_ALM') + '\', ' +
                                                                                           ' confidence: \'' + XboxJS.UI.Voice.getWinJSStringName('tv/PREVIOUS_PAGE_COMMAND_VUI_CONF') + '\', ' +
                                                                                           ' pronunciation: \'' + XboxJS.UI.Voice.getWinJSStringName('tv/PREVIOUS_PAGE_COMMAND_VUI_PRON') + '\', ' +
                                                                                           ' targetElement: select(\'this\') ' +
                                                                                           '}">' +
                                                                strings.listViewPreviousPage + // This is just a place holder. Is not used
                                                                '</div>' +
                                                                '<div class="' + XboxJS.UI.Hub._ClassName.nextPageLabel + ' win-hidden" data-win-voice="{' +
                                                                                                                                ' phrase: \'' + XboxJS.UI.Voice.getWinJSStringName('tv/NEXT_PAGE_COMMAND_VUI_ALM') + '\', ' +
                                                                                                                                ' confidence: \'' + XboxJS.UI.Voice.getWinJSStringName('tv/NEXT_PAGE_COMMAND_VUI_CONF') + '\', ' +
                                                                                                                                ' pronunciation: \'' + XboxJS.UI.Voice.getWinJSStringName('tv/NEXT_PAGE_COMMAND_VUI_PRON') + '\', ' +
                                                                                                                                ' targetElement: select(\'this\') ' +
                                                                                                                                '}">' +
                                                                strings.listViewNextPage + // This is just a place holder. Is not used
                                                                '</div>';
                    this._viewportElement.appendChild(nextPreviousPageVoiceElements);

                    // Hook up the event handlers
                    this._previousPageVoiceLabelElement = this._element.querySelector("." + XboxJS.UI.Hub._ClassName.previousPageLabel + "");
                    this._nextPageVoiceLabelElement = this._element.querySelector("." + XboxJS.UI.Hub._ClassName.nextPageLabel + "");
                    this._previousPageVoiceLabelElement.addEventListener("click", this._previousPageBind, false);
                    this._nextPageVoiceLabelElement.addEventListener("click", this._nextPageBind, false);

                    this._lastKeydownLeft = 0;
                    this._lastKeydownRight = 0;

                    // This variable keeps track of the initial scroll position for use with gesture & controller interaction.
                    this._initialScrollPosition = -1;

                    this._handleGestureDisengagedBind = this._handleGestureDisengaged.bind(this);
                    window.addEventListener("gesturedisengaged", this._handleGestureDisengagedBind, false);
                    this._updatePreviousNextVoiceLabelsBind = this._updatePreviousNextVoiceLabels.bind(this);
                    XboxJS.UI.Voice.addEventListener("listeningstart", this._updatePreviousNextVoiceLabelsBind, false);

                    // Listen to changes in screen size so we can recalculate the "scroll into view" thresholds
                    this._handleResizeBind = this._handleResize.bind(this);
                    window.addEventListener("resize", this._handleResizeBind, false);

                    if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.Hub._sounds.initialized) {
                        XboxJS.UI.Hub._sounds.pageTransitionLeft = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///PageTransitionLeft"));
                        XboxJS.UI.Hub._sounds.pageTransitionRight = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///PageTransitionRight"));
                        XboxJS.UI.Hub._sounds.elementFocus1 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus1"));
                        XboxJS.UI.Hub._sounds.elementFocus2 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus2"));
                        XboxJS.UI.Hub._sounds.elementFocus3 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus3"));
                        XboxJS.UI.Hub._sounds.elementFocus4 = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///ElementFocus4"));
                        XboxJS.UI.Hub._sounds.initialized = true;
                    }
                }

                this._refresh();

                this._writeProfilerMark("constructor,StopTM");
            }, {
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.Hub.element" helpKeyword="XboxJS.UI.Hub.element">
                /// Gets the DOM element that hosts the Hub.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="WinJS.UI.Orientation" locid="XboxJS.UI.Hub.orientation" helpKeyword="XboxJS.UI.Hub.orientation">
                /// Gets or sets the orientation to pack sections inside the Hub.
                /// </field>
                orientation: {
                    get: function () {
                        return this._orientation;
                    },
                    set: function (value) {
                        this._measured = false;
                        if (value === WinJS.UI.Orientation.vertical) {
                            WinJS.Utilities.removeClass(this.element, XboxJS.UI.Hub._ClassName.hubHorizontal);
                            WinJS.Utilities.addClass(this.element, XboxJS.UI.Hub._ClassName.hubVertical);
                        } else {
                            value = WinJS.UI.Orientation.horizontal;
                            WinJS.Utilities.removeClass(this.element, XboxJS.UI.Hub._ClassName.hubVertical);
                            WinJS.Utilities.addClass(this.element, XboxJS.UI.Hub._ClassName.hubHorizontal);
                        }
                        this._orientation = value;
                        if (WinJS.Utilities.Scheduler) {
                            WinJS.Utilities.Scheduler.schedule(this._updateSnapList.bind(this), WinJS.Utilities.Scheduler.Priority.idle);
                        } else {
                            setImmediate(this._updateSnapList.bind(this));
                        }
                    }
                },
                /// <field type="WinJS.Binding.List" locid="XboxJS.UI.Hub.sections" helpKeyword="XboxJS.UI.Hub.sections">
                /// Gets or sets the Binding List of HubSection objects that are packed inside the Hub.
                /// </field>
                sections: {
                    get: function () {
                        if (this._pendingSections) {
                            return this._pendingSections;
                        }
                        return this._sections;
                    },
                    set: function (value) {
                        var resetScrollPosition = !this._pendingSections;
                        this._pendingSections = value;
                        this._refresh();
                        if (resetScrollPosition) {
                            this.scrollPosition = 0;
                        }
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.Hub.headerTemplate" helpKeyword="XboxJS.UI.Hub.headerTemplate" potentialValueSelector="[data-win-control='WinJS.Binding.Template']">
                /// Gets or sets the template function that creates the DOM elements
                /// which represent the header for each HubSection. Each header can
                /// contain multiple DOM elements, but we recommend that it have a single
                /// root element.
                /// </field>
                headerTemplate: {
                    get: function () {
                        if (this._pendingHeaderTemplate) {
                            return this._pendingHeaderTemplate;
                        }

                        if (!this._headerTemplate) {
                            this._headerTemplate = hubDefaultHeaderTemplate;
                        }

                        return this._headerTemplate;
                    },
                    set: function (value) {
                        this._pendingHeaderTemplate = value || hubDefaultHeaderTemplate;
                        this._refresh();
                    }
                },
                /// <field type="Number" integer="true" locid="XboxJS.UI.Hub.scrollPosition" helpKeyword="XboxJS.UI.Hub.scrollPosition">
                /// Gets or sets the position of the Hub's scrollbar.
                /// </field>
                scrollPosition: {
                    get: function () {
                        if (+this._pendingScrollLocation === this._pendingScrollLocation) {
                            return this._pendingScrollLocation;
                        }

                        this._measure();
                        return this._scrollPosition;
                    },
                    set: function (value) {
                        value = Math.max(0, value);
                        if (this._pendingRefresh) {
                            // Unable to constrain length because sections may have changed.
                            this._pendingScrollLocation = value;
                            this._pendingSectionOnScreen = null;
                        } else {
                            this._measure();
                            var targetScrollPos = Math.max(0, Math.min(this._scrollLength - this._viewportSize, value));
                            this._viewportElement[this._names.scrollPos] = this._scrollPosition = targetScrollPos;
                        }
                    }
                },

                /// <field type="Number" integer="true" locid="XboxJS.UI.Hub.sectionOnScreen" helpKeyword="XboxJS.UI.Hub.sectionOnScreen">
                /// Gets or sets the index of first section in view. Use for launch or resume scenarios.
                /// </field>
                sectionOnScreen: {
                    get: function () {
                        if (+this._pendingSectionOnScreen === this._pendingSectionOnScreen) {
                            return this._pendingSectionOnScreen;
                        }

                        this._measure();
                        for (var i = 0; i < this._sectionSizes.length; i++) {
                            var sectionSize = this._sectionSizes[i];
                            if ((sectionSize.offset + sectionSize.size - sectionSize.borderEnd - sectionSize.paddingEnd) > (this._scrollPosition + this._startSpacer + sectionSize.borderStart + sectionSize.paddingStart)) {
                                return i;
                            }
                        }
                        return -1;
                    },
                    set: function (value) {
                        value = Math.max(0, value);
                        if (this._pendingRefresh) {
                            this._pendingSectionOnScreen = value;
                            this._pendingScrollLocation = null;
                        } else {
                            this._measure();
                            if (value >= 0 && value < this._sectionSizes.length) {
                                // On Xbox, we do an animated scroll into view
                                if (XboxJS) {
                                    this._scrollToSection(value, true);
                                } else {
                                    this._scrollToSection(value);
                                }
                            }
                        }
                    }
                },
                /// <field type="Number" integer="true" isAdvanced="true" locid="XboxJS.UI.Hub.indexOfFirstVisible" helpKeyword="XboxJS.UI.Hub.indexOfFirstVisible">
                /// Gets or sets the index of first section at least partially in view. Use for animations.
                /// </field>
                indexOfFirstVisible: {
                    get: function () {
                        this._measure();
                        for (var i = 0; i < this._sectionSizes.length; i++) {
                            var sectionSize = this._sectionSizes[i];
                            if ((sectionSize.offset + sectionSize.size - sectionSize.borderEnd - sectionSize.paddingEnd) > this._scrollPosition) {
                                return i;
                            }
                        }
                        return -1;
                    }
                },
                /// <field type="Number" integer="true" isAdvanced="true" locid="XboxJS.UI.Hub.indexOfLastVisible" helpKeyword="XboxJS.UI.Hub.indexOfLastVisible">
                /// Gets or sets the index of last section at least partially in view. Use for animations.
                /// </field>
                indexOfLastVisible: {
                    get: function () {
                        this._measure();
                        for (var i = this._sectionSizes.length - 1; i >= 0; i--) {
                            var sectionSize = this._sectionSizes[i];
                            if ((sectionSize.offset + sectionSize.paddingStart + sectionSize.borderStart) < (this._scrollPosition + this._viewportSize)) {
                                return i;
                            }
                        }
                        return -1;
                    }
                },

                /// <field type="Function" locid="XboxJS.UI.Hub.onheaderinvoked" helpKeyword="XboxJS.UI.Hub.onheaderinvoked">
                /// Fired  whenever a user clicks on an interactive header.
                /// </field>
                onheaderinvoked: createEvent(eventNames.headerInvoked),

                /// <field type="Function" locid="XboxJS.UI.Hub.onloadingstatechanged" helpKeyword="XboxJS.UI.Hub.onloadingstatechanged">
                /// Occurs when the hub has switched between loading and ready states.
                /// </field>
                onloadingstatechanged: createEvent(eventNames.loadingStateChanged),

                /// <field type="Function" locid="XboxJS.UI.Hub.oncontentanimating" helpKeyword="XboxJS.UI.Hub.oncontentanimating">
                /// Occurs when Hub is about to play entrance, contentTransition, insert or remove animations.
                /// </field>
                oncontentanimating: createEvent(eventNames.contentAnimating),

                _refresh: function hub_refresh() {
                    if (this._pendingRefresh) {
                        return;
                    }

                    this._loadId++;
                    this._setState(XboxJS.UI.Hub.LoadingState.loading);
                    // This is to coalesce property setting operations such as sections and scrollPosition.
                    this._pendingRefresh = true;

                    if (WinJS.Utilities.Scheduler) {
                        WinJS.Utilities.Scheduler.schedule(this._refreshImpl.bind(this), WinJS.Utilities.Scheduler.Priority.high);
                    } else {
                        setImmediate(this._refreshImpl.bind(this));
                    }
                },
                _refreshImpl: function hub_refreshImpl() {
                    if (this._disposed) {
                        return;
                    }

                    var fadeOutAnimation = WinJS.Promise.wrap();
                    if (this._pendingSections) {
                        this._animateEntrance = true;
                        this._fireEntrance = !this._visible;
                        if (!this._fireEntrance) {
                            this._visible = false;
                            this._viewportElement.style.opacity = 0;

                            if (WinJS.UI.isAnimationEnabled()) {
                                var animateTransition = this._fireEvent(XboxJS.UI.Hub._EventName.contentAnimating, {
                                    type: XboxJS.UI.Hub.AnimationType.contentTransition
                                });

                                if (animateTransition) {
                                    this._viewportElement.style["-ms-overflow-style"] = "none";
                                    fadeOutAnimation = WinJS.UI.Animation.fadeOut(this._viewportElement).then(function () {
                                        if (this._viewportElement) {
                                            this._viewportElement.style["-ms-overflow-style"] = "";
                                        }
                                    }.bind(this));
                                }
                                this._animateEntrance = animateTransition;
                            }
                        }
                    }

                    fadeOutAnimation.done(this._applyProperties.bind(this));
                },
                _applyProperties: function hub_applyProperties() {
                    if (this._disposed) {
                        return;
                    }
                    this._pendingRefresh = false;

                    var needsToLoadSections = false;
                    if (this._pendingSections) {
                        needsToLoadSections = true;
                        this._updateEvents(this._sections, this._pendingSections);
                        this._sections = this._pendingSections;
                        this._pendingSections = null;
                        // Remove any declaratively specified hub sections before attachSections.
                        while (this.element.firstElementChild !== this._viewportElement) {
                            var toRemove = this.element.firstElementChild;
                            toRemove.parentNode.removeChild(toRemove);
                        }
                        WinJS.Utilities.empty(this._surfaceElement);
                    }

                    if (this._pendingHeaderTemplate) {
                        this._headerTemplate = this._pendingHeaderTemplate;
                        this._pendingHeaderTemplate = null;
                    }

                    this._assignHeaderTemplate();

                    if (needsToLoadSections) {
                        this._attachSections();
                    }

                    // Scroll after headers are rendered and sections are attached so the scroll thumb is correct.
                    if (+this._pendingSectionOnScreen === this._pendingSectionOnScreen) {
                        // If there are both pending section on screen and scroll location use section on screen.
                        this.sectionOnScreen = this._pendingSectionOnScreen;
                    } else if (+this._pendingScrollLocation === this._pendingScrollLocation) {
                        this.scrollPosition = this._pendingScrollLocation;
                    } else {
                        // Sections reset without sectionOnScreen or scrollPosition APIs.
                        this.scrollPosition = 0;
                    }

                    this._pendingSectionOnScreen = null;
                    this._pendingScrollLocation = null;

                    // Using current (or new) scroll location load the sections
                    this._setState(XboxJS.UI.Hub.LoadingState.loading);
                    this._loadSections();
                },
                _handleSectionChanged: function hub_handleSectionChanged(ev) {
                    // Change is triggered by binding list setAt() API.
                    if (this._pendingSections) {
                        return;
                    }

                    var newSection = ev.detail.newValue;
                    var oldSection = ev.detail.oldValue;
                    newSection._setHeaderTemplate(this.headerTemplate);
                    if (newSection.element !== oldSection.element) {
                        if (newSection.element.parentNode === this._surfaceElement) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.Hub.DuplicateSection", strings.duplicateSection);
                        }

                        this._surfaceElement.insertBefore(newSection.element, oldSection.element);
                        this._surfaceElement.removeChild(oldSection.element);
                        this._measured = false;

                        this._setState(XboxJS.UI.Hub.LoadingState.loading);
                        this._loadSections();
                    }
                },
                _handleSectionInserted: function hub_handleSectionInserted(ev) {
                    // Insert is triggered by binding list insert APIs such as splice(), push(), and unshift().
                    if (this._pendingSections) {
                        return;
                    }

                    var index = ev.detail.index;
                    var section = ev.detail.value;

                    if (section._animation) {
                        section._animation.cancel();
                    }

                    var animation;
                    var result = this._fireEvent(XboxJS.UI.Hub._EventName.contentAnimating, {
                        type: XboxJS.UI.Hub.AnimationType.insert,
                        index: index,
                        section: section
                    });

                    if (result) {

                        var affectedElements = [];

                        for (var i = index + 1; i < this.sections.length; i++) {
                            affectedElements.push(this.sections.getAt(i).element);
                        }

                        animation = new WinJS.UI.Animation._createUpdateListAnimation([section.element], [], affectedElements);
                    }

                    if (section.element.parentNode === this._surfaceElement) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Hub.DuplicateSection", strings.duplicateSection);
                    }

                    section._setHeaderTemplate(this.headerTemplate);
                    if (index < this.sections.length - 1) {
                        this._surfaceElement.insertBefore(section.element, this.sections.getAt(index + 1).element);
                    } else {
                        this._surfaceElement.appendChild(section.element);
                    }
                    this._measured = false;

                    if (animation) {
                        var insertAnimation = animation.execute();
                        this.runningAnimations = WinJS.Promise.join([this.runningAnimations, insertAnimation]);
                    }

                    this._setState(XboxJS.UI.Hub.LoadingState.loading);
                    this._loadSections();
                },
                _handleSectionMoved: function hub_handleSectionMoved(ev) {
                    // Move is triggered by binding list move() API.
                    if (this._pendingSections) {
                        return;
                    }

                    var newIndex = ev.detail.newIndex;
                    var section = ev.detail.value;

                    if (newIndex < this.sections.length - 1) {
                        this._surfaceElement.insertBefore(section.element, this.sections.getAt(newIndex + 1).element);
                    } else {
                        this._surfaceElement.appendChild(section.element);
                    }
                    this._measured = false;

                    this._setState(XboxJS.UI.Hub.LoadingState.loading);
                    this._loadSections();
                },
                _handleSectionRemoved: function hub_handleSectionRemoved(ev) {
                    // Removed is triggered by binding list removal APIs such as splice(), pop(), and shift().
                    if (this._pendingSections) {
                        return;
                    }

                    var section = ev.detail.value;
                    var index = ev.detail.index;

                    var animationPromise = WinJS.Promise.wrap();
                    var result = this._fireEvent(XboxJS.UI.Hub._EventName.contentAnimating, {
                        type: XboxJS.UI.Hub.AnimationType.remove,
                        index: index,
                        section: section
                    });

                    if (result) {
                        var affectedElements = [];

                        for (var i = index; i < this.sections.length; i++) {
                            affectedElements.push(this.sections.getAt(i).element);
                        }

                        var animation = new WinJS.UI.Animation._createUpdateListAnimation([], [section.element], affectedElements);

                        this._measure();
                        var offsetTop = section.element.offsetTop;
                        var offsetLeft = section.element.offsetLeft;
                        section.element.style.position = "absolute";
                        section.element.style.top = offsetTop;
                        section.element.style.left = offsetLeft;
                        section.element.style.opacity = 0;
                        this._measured = false;

                        animationPromise = animation.execute().then(function () {
                            if (XboxJS && section._disposed) {
                                return;
                            }
                            section.element.style.position = "";
                            section.element.style.top = "";
                            section.element.style.left = "";
                            section.element.style.opacity = 1;
                        }.bind(this));
                    }

                    animationPromise.done(function () {
                        if (!this._disposed) {
                            this._surfaceElement.removeChild(section.element);
                            this._measured = false;
                        }
                    }.bind(this));

                    // Store animation promise in case it is inserted before remove animation finishes.
                    section._animation = animationPromise;
                    this.runningAnimations = WinJS.Promise.join([this.runningAnimations, animationPromise]);

                    this._setState(XboxJS.UI.Hub.LoadingState.loading);
                    this._loadSections();
                },
                _handleSectionReload: function hub_handleSectionReload(ev) {
                    // Reload is triggered by large operations on the binding list such as reverse(). This causes 
                    // _pendingSections to be true which ignores future insert/remove/modified/moved events until the new 
                    // sections list is applied.
                    this.sections = this.sections;
                },
                _updateEvents: function hub_updateEvents(oldSections, newSections) {
                    if (oldSections) {
                        oldSections.removeEventListener("itemchanged", this._handleSectionChangedBind);
                        oldSections.removeEventListener("iteminserted", this._handleSectionInsertedBind);
                        oldSections.removeEventListener("itemmoved", this._handleSectionMovedBind);
                        oldSections.removeEventListener("itemremoved", this._handleSectionRemovedBind);
                        oldSections.removeEventListener("reload", this._handleSectionReloadBind);
                    }

                    if (newSections) {
                        newSections.addEventListener("itemchanged", this._handleSectionChangedBind);
                        newSections.addEventListener("iteminserted", this._handleSectionInsertedBind);
                        newSections.addEventListener("itemmoved", this._handleSectionMovedBind);
                        newSections.addEventListener("itemremoved", this._handleSectionRemovedBind);
                        newSections.addEventListener("reload", this._handleSectionReloadBind);
                    }
                },
                _attachSections: function hub_attachSections() {
                    this._measured = false;
                    for (var i = 0; i < this.sections.length; i++) {
                        var section = this._sections.getAt(i);
                        if (section._animation) {
                            section._animation.cancel();
                        }
                        if (section.element.parentNode === this._surfaceElement) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.Hub.DuplicateSection", strings.duplicateSection);
                        }
                        this._surfaceElement.appendChild(section.element);
                    }
                },
                _assignHeaderTemplate: function hub_assignHeaderTemplate() {
                    this._measured = false;
                    for (var i = 0; i < this.sections.length; i++) {
                        var section = this._sections.getAt(i);
                        section._setHeaderTemplate(this.headerTemplate);
                    }
                },
                _loadSection: function hub_loadSection(index) {
                    var section = this._sections.getAt(index);
                    return section._process().then(function resetVisibility() {
                        if (XboxJS && section._disposed) {
                            return;
                        }
                        var style = section.contentElement.style;
                        if (style.visibility !== "") {
                            style.visibility = "";
                        }
                    });
                },
                _loadSections: function hub_loadSections() {
                    // Used to know if another load has interrupted this one.
                    this._loadId++;
                    var loadId = this._loadId;
                    var that = this;
                    var onScreenItemsAnimatedPromise = WinJS.Promise.wrap();
                    var sectionIndicesToLoad = [];
                    var allSectionsLoadedPromise = WinJS.Promise.wrap();

                    function loadNextSectionAfterPromise(promise) {
                        promise.then(function () {
                            if (WinJS.Utilities.Scheduler) {
                                WinJS.Utilities.Scheduler.schedule(loadNextSection, WinJS.Utilities.Scheduler.Priority.idle);
                            } else {
                                setImmediate(loadNextSection);
                            }
                        });
                    }

                    function loadNextSection() {
                        if (loadId === that._loadId && !that._disposed) {
                            if (sectionIndicesToLoad.length) {
                                var index = sectionIndicesToLoad.shift();
                                var loadedPromise = that._loadSection(index);
                                loadNextSectionAfterPromise(loadedPromise);
                            } else {
                                allSectionsLoadedSignal.complete();
                            }
                        }
                    }

                    if (!this._showProgressPromise) {
                        this._showProgressPromise = WinJS.Promise.timeout(progressDelay).then(function () {
                            if (this._disposed) {
                                return;
                            }

                            if (!this._progressBar) {
                                this._progressBar = document.createElement("progress");
                                WinJS.Utilities.addClass(this._progressBar, XboxJS.UI.Hub._ClassName.hubProgress);
                                this._progressBar.max = 100;
                            }
                            if (!this._progressBar.parentNode) {
                                this.element.insertBefore(this._progressBar, this._viewportElement);
                            }
                            this._showProgressPromise = null;
                        }.bind(this), function () {
                            this._showProgressPromise = null;
                        }.bind(this));
                    }

                    if (this.sections.length) {
                        var allSectionsLoadedSignal = new WinJS._Signal();
                        allSectionsLoadedPromise = allSectionsLoadedSignal.promise;
                        // Synchronously load the sections on screen.
                        var synchronousProcessPromises = [];
                        var start = Math.max(0, this.indexOfFirstVisible);
                        var end = Math.max(0, this.indexOfLastVisible);
                        for (var i = start; i <= end; i++) {
                            synchronousProcessPromises.push(this._loadSection(i));
                        }

                        // Determine the order to load the rest of the sections.
                        start--;
                        end++;
                        while (start >= 0 || end < this.sections.length) {
                            if (end < this.sections.length) {
                                sectionIndicesToLoad.push(end);
                                end++;
                            }
                            if (start >= 0) {
                                sectionIndicesToLoad.push(start);
                                start--;
                            }
                        }

                        var onScreenSectionsLoadedPromise = WinJS.Promise.join(synchronousProcessPromises);

                        // In case there are overlapping load calls
                        onScreenSectionsLoadedPromise.done(function () {
                            if (loadId === this._loadId && !that._disposed) {
                                if (this._showProgressPromise) {
                                    this._showProgressPromise.cancel();
                                }

                                if (this._progressBar && this._progressBar.parentNode) {
                                    this._progressBar.parentNode.removeChild(this._progressBar);
                                }

                                setImmediate(function () {
                                    if (loadId === this._loadId && !that._disposed) {
                                        if (!this._visible) {
                                            this._visible = true;
                                            this._viewportElement.style.opacity = 1;
                                            if (this._animateEntrance && WinJS.UI.isAnimationEnabled()) {
                                                var eventDetail = {
                                                    type: XboxJS.UI.Hub.AnimationType.entrance
                                                };

                                                if (!this._fireEntrance || this._fireEvent(XboxJS.UI.Hub._EventName.contentAnimating, eventDetail)) {
                                                    if (XboxJS) {
                                                        this._viewportElement.style["-ms-overflow-style"] = "none";
                                                        var elementsToAnimate = this._viewportElement.querySelectorAll(".win-hub-section-header, .win-hub-section-content");
                                                        onScreenItemsAnimatedPromise = XboxJS.UI.Animation.showCollection(elementsToAnimate).then(function () {
                                                            if (this._viewportElement) {
                                                                this._viewportElement.style["-ms-overflow-style"] = "";
                                                            }
                                                        }.bind(this));
                                                    } else {
                                                        onScreenItemsAnimatedPromise = WinJS.UI.Animation.enterContent(this._viewportElement, [{ left: this._fireEntrance ? "100px" : "40px", top: "0px", rtlflip: true }]).then(function () {
                                                            this._viewportElement.style["-ms-overflow-style"] = "";
                                                        }.bind(this));
                                                    }
                                                }
                                                if (this._element === document.activeElement) {
                                                    this._moveFocusIn(this.sectionOnScreen);
                                                }
                                            }
                                            // Refresh the voice labels right before animating the content. Note, we need to make this
                                            // call before animating the content otherwise, the developer may have canceled the animation promise
                                            // and the voice labels won't update.
                                            setImmediate(function () {
                                                if (XboxJS) {
                                                    that._updatePreviousNextVoiceLabels();
                                                }
                                            });
                                        }

                                        if (XboxJS.UI.Voice) {
                                            XboxJS.UI.Voice.refreshVoiceElements();
                                        }
                                    }
                                }.bind(this));

                                loadNextSectionAfterPromise(onScreenSectionsLoadedPromise);
                            } else {
                                if (this._showProgressPromise) {
                                    this._showProgressPromise.cancel();
                                }

                                if (this._progressBar && this._progressBar.parentNode) {
                                    this._progressBar.parentNode.removeChild(this._progressBar);
                                }
                            }
                        }.bind(this));
                    }

                    WinJS.Promise.join([this.runningAnimations, onScreenItemsAnimatedPromise, allSectionsLoadedPromise]).done(function () {
                        if (loadId === this._loadId && !that._disposed) {
                            this.runningAnimations = WinJS.Promise.wrap();
                            this._setState(XboxJS.UI.Hub.LoadingState.complete);

                            if (WinJS.Utilities.Scheduler) {
                                WinJS.Utilities.Scheduler.schedule(this._updateSnapList.bind(this), WinJS.Utilities.Scheduler.Priority.idle);
                            } else {
                                setImmediate(this._updateSnapList.bind(this));
                            }
                        }
                    }.bind(this));
                },
                /// <field type="String" hidden="true" locid="XboxJS.UI.Hub.loadingState" helpKeyword="XboxJS.UI.Hub.loadingState">
                /// Gets a value that indicates whether the Hub is still loading or whether
                /// loading is complete.  This property can return one of these values:
                /// "loading" or "complete".
                /// </field>
                loadingState: {
                    get: function () {
                        return this._loadingState;
                    }
                },
                _setState: function Hub_setState(state) {
                    if (state !== this._loadingState) {
                        this._writeProfilerMark("loadingStateChanged:" + state + ",info");
                        this._loadingState = state;
                        var eventObject = document.createEvent("CustomEvent");
                        eventObject.initCustomEvent(XboxJS.UI.Hub._EventName.loadingStateChanged, true, false, { loadingState: state });
                        this._element.dispatchEvent(eventObject);
                    }
                },
                _parse: function hub_parse() {
                    var hubSections = []
                    var hubSectionEl = this.element.firstElementChild;

                    while (hubSectionEl !== this._viewportElement) {
                        WinJS.UI.processAll(hubSectionEl);

                        var hubSectionContent = hubSectionEl.winControl;
                        if (hubSectionContent) {
                            hubSections.push(hubSectionContent);
                        } else {
                            throw new WinJS.ErrorFromName("XboxJS.UI.Hub.InvalidContent", strings.invalidContent);
                        }

                        var nextSectionEl = hubSectionEl.nextElementSibling;
                        hubSectionEl = nextSectionEl;
                    }

                    this.sections = new WinJS.Binding.List(hubSections);
                },
                _fireEvent: function hub_fireEvent(type, detail) {
                    // Returns true if ev.preventDefault() was not called
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, true, true, detail);
                    return this.element.dispatchEvent(event);
                },

                _findHeaderTabStop: function hub_findHeaderTabStop(element) {
                    if (element.parentNode) {
                        if (element.msMatchesSelector(".win-hub-section-header-tabstop, .win-hub-section-header-tabstop *")) {
                            while (!WinJS.Utilities.hasClass(element, "win-hub-section-header-tabstop")) {
                                element = element.parentElement;
                            }
                            return element;
                        }
                    }
                    return null;
                },
                _isHeaderInteractive: function hub_isHeaderInteractive(element) {
                    // Helper method to skip keyboarding and clicks with a header's sub interactive content
                    if (element.parentNode) {
                        return element.msMatchesSelector(".win-interactive, .win-interactive *");
                    }
                    return false;
                },
                _clickHandler: function hub_clickHandler(ev) {
                    var headerTabStopElement = this._findHeaderTabStop(ev.srcElement);
                    if (headerTabStopElement && !this._isHeaderInteractive(ev.srcElement)) {
                        var section = headerTabStopElement.parentElement.parentElement.winControl;
                        if (!section.isHeaderStatic) {
                            var sectionIndex = this.sections.indexOf(section);
                            this._fireEvent(XboxJS.UI.Hub._EventName.headerInvoked, {
                                index: sectionIndex,
                                section: section
                            });
                        }
                    }
                },
                _resizeHandler: function hub_resizeHandler(ev) {
                    // Viewport needs to be measured
                    this._measured = false;
                    if (WinJS.Utilities.Scheduler) {
                        WinJS.Utilities.Scheduler.schedule(this._updateSnapList.bind(this), WinJS.Utilities.Scheduler.Priority.idle);
                    } else {
                        setImmediate(this._updateSnapList.bind(this));
                    }
                },
                _contentResizeHandler: function hub_contentResizeHandler(ev) {
                    // Sections and scroll length need to be measured
                    this._measured = false;
                    if (WinJS.Utilities.Scheduler) {
                        WinJS.Utilities.Scheduler.schedule(this._updateSnapList.bind(this), WinJS.Utilities.Scheduler.Priority.idle);
                    } else {
                        setImmediate(this._updateSnapList.bind(this));
                    }
                },
                _scrollHandler: function hub_scrollHandler(ev) {
                    // Scroll location needs to be retrieved
                    this._measured = false;

                    if (this._pendingSections) {
                        return;
                    }

                    // Scroll events caused by users overwrite pending API modifications to scrollposition.
                    this._pendingScrollLocation = null;
                    this._pendingSectionOnScreen = null;

                    if (!this._pendingScrollHandler) {
                        this._pendingScrollHandler = requestAnimationFrame(function () {
                            if (this._disposed) {
                                return;
                            }

                            this._pendingScrollHandler = null;

                            if (this._pendingSections) {
                                return;
                            }

                            if (this.loadingState !== XboxJS.UI.Hub.LoadingState.complete) {
                                this._loadSections();
                            } else {
                                if (XboxJS.UI.Voice) {
                                    XboxJS.UI.Voice.refreshVoiceElements();
                                    this._updatePreviousNextVoiceLabelsBind();
                                }

                                if (this._initialScrollPosition === -1 &&
                                    XboxJS.Utilities._isGestureEngaged) {
                                    this._initialScrollPosition = this.scrollPosition;
                                }
                                this._lastScrollPosition = this.scrollPosition;
                            }
                        }.bind(this));
                    }
                },
                // Determine if we need to show the previous / next voice labels
                _updatePreviousNextVoiceLabels: function hub_updatePreviousNextVoiceLabels() {
                    if (this._disposed) {
                        return;
                    }

                    if (!this._names) {
                        if (this.orientation === WinJS.UI.Orientation.vertical) {
                            this._names = verticalNames;
                        } else {
                            if (this._rtl) {
                                this._names = rtlHorizontalNames;
                            } else {
                                this._names = ltrHorizontalNames;
                            }
                        }
                    }

                    // If we have scrolled to the end, then we do not need to show next / previous page
                    var scrollPosition = this._viewportElement[this._names.scrollPos];
                    var scrollLength = this._viewportElement[this._names.scrollSize];
                    var viewportSize = this._viewportElement[this._names.offsetSize];
                    // We have a small offset that accounts for title safety. If the page is within 100px of the edge,
                    // then we consider it to be at the edge.
                    var titleSafeOffset = 100;

                    if (scrollPosition - titleSafeOffset <= 0) {
                        this._canPreviousPage = false;
                    } else {
                        this._canPreviousPage = true;
                    }

                    if (scrollPosition + viewportSize >= scrollLength - titleSafeOffset) {
                        this._canNextPage = false;
                    } else {
                        this._canNextPage = true;
                    }

                    if (!this._canPreviousPage &&
                        !this._canNextPage) {
                        WinJS.Utilities.addClass(this._previousPageVoiceLabelElement, "win-hidden");
                        WinJS.Utilities.addClass(this._nextPageVoiceLabelElement, "win-hidden");
                    } else if (this._canPreviousPage &&
                        !this._canNextPage) {
                        WinJS.Utilities.removeClass(this._previousPageVoiceLabelElement, "win-hidden");
                        WinJS.Utilities.removeClass(this._nextPageVoiceLabelElement, "win-hidden");

                        WinJS.Utilities.removeClass(this._previousPageVoiceLabelElement, "win-voice-disabledlabel");
                        WinJS.Utilities.addClass(this._nextPageVoiceLabelElement, "win-voice-disabledlabel");
                    } else if (!this._canPreviousPage &&
                        this._canNextPage) {
                        WinJS.Utilities.removeClass(this._previousPageVoiceLabelElement, "win-hidden");
                        WinJS.Utilities.removeClass(this._nextPageVoiceLabelElement, "win-hidden");

                        WinJS.Utilities.addClass(this._previousPageVoiceLabelElement, "win-voice-disabledlabel");
                        WinJS.Utilities.removeClass(this._nextPageVoiceLabelElement, "win-voice-disabledlabel");
                    } else {
                        WinJS.Utilities.removeClass(this._previousPageVoiceLabelElement, "win-hidden");
                        WinJS.Utilities.removeClass(this._nextPageVoiceLabelElement, "win-hidden");

                        WinJS.Utilities.removeClass(this._previousPageVoiceLabelElement, "win-voice-disabledlabel");
                        WinJS.Utilities.removeClass(this._nextPageVoiceLabelElement, "win-voice-disabledlabel");
                    }
                },
                _measure: function hub_measure() {
                    // Any time a size changes (section growing, window resizing, etc) cachedSizes should be set to false
                    // and any time the variables need to be read again we should measure the variables. To avoid a lot of
                    // seperate layouts we measure the variables in a single batch.
                    if (!this._measured || this._scrollLength === 0) {
                        this._writeProfilerMark("measure,StartTM");
                        this._measured = true;

                        this._rtl = getComputedStyle(this._element, null).direction === "rtl";

                        if (this.orientation === WinJS.UI.Orientation.vertical) {
                            this._names = verticalNames;
                        } else {
                            if (this._rtl) {
                                this._names = rtlHorizontalNames;
                            } else {
                                this._names = ltrHorizontalNames;
                            }
                        }

                        this._viewportStart = this._viewportElement.getBoundingClientRect()[this._names.start];
                        this._viewportSize = this._viewportElement[this._names.offsetSize];
                        this._viewportOppositeSize = this._viewportElement[this._names.oppositeOffsetSize];
                        this._scrollPosition = this._viewportElement[this._names.scrollPos];
                        this._scrollLength = this._viewportElement[this._names.scrollSize];

                        var surfaceElementComputedStyle = getComputedStyle(this._surfaceElement);
                        this._startSpacer = parseFloat(surfaceElementComputedStyle[this._names.marginStart]) + parseFloat(surfaceElementComputedStyle[this._names.borderStart]) + parseFloat(surfaceElementComputedStyle[this._names.paddingStart]);
                        this._endSpacer = parseFloat(surfaceElementComputedStyle[this._names.marginEnd]) + parseFloat(surfaceElementComputedStyle[this._names.borderEnd]) + parseFloat(surfaceElementComputedStyle[this._names.paddingEnd]);

                        this._sectionSizes = [];
                        for (var i = 0; i < this.sections.length; i++) {
                            var section = this.sections.getAt(i);
                            var computedSectionStyle = getComputedStyle(section.element);
                            this._sectionSizes[i] = {
                                offset: section.element[this._names.offsetPos],
                                // Reminder: offsetWidth doesn't include margins and also rounds.
                                size: section.element[this._names.offsetSize],
                                marginStart: parseFloat(computedSectionStyle[this._names.marginStart]),
                                marginEnd: parseFloat(computedSectionStyle[this._names.marginEnd]),
                                borderStart: parseFloat(computedSectionStyle[this._names.borderStart]),
                                borderEnd: parseFloat(computedSectionStyle[this._names.borderEnd]),
                                paddingStart: parseFloat(computedSectionStyle[this._names.paddingStart]),
                                paddingEnd: parseFloat(computedSectionStyle[this._names.paddingEnd])
                            };

                            if (this._rtl && this.orientation === WinJS.UI.Orientation.horizontal) {
                                this._sectionSizes[i].offset = this._viewportSize - (this._sectionSizes[i].offset + this._sectionSizes[i].size);
                            }
                        }

                        this._writeProfilerMark("measure,StopTM");
                    }
                },
                _updateSnapList: function hub_updateSnapList() {
                    if (XboxJS && this._disposed) {
                        return;
                    }

                    this._writeProfilerMark("updateSnapList,StartTM");
                    this._measure();

                    var snapList = "snapList(";
                    for (var i = 0; i < this._sectionSizes.length; i++) {
                        if (i > 0) {
                            snapList += ",";
                        }
                        var sectionSize = this._sectionSizes[i];
                        snapList += (sectionSize.offset - sectionSize.marginStart - this._startSpacer) + "px";
                    }
                    snapList += ")";

                    var snapListY = "";
                    var snapListX = "";
                    if (this.orientation === WinJS.UI.Orientation.vertical) {
                        snapListY = snapList;
                    } else {
                        snapListX = snapList;
                    }

                    if (this._lastSnapPointY !== snapListY) {
                        this._lastSnapPointY = snapListY;
                        this._viewportElement.style['-ms-scroll-snap-points-y'] = snapListY;
                    }

                    if (this._lastSnapPointX !== snapListX) {
                        this._lastSnapPointX = snapListX;
                        this._viewportElement.style['-ms-scroll-snap-points-x'] = snapListX;
                    }

                    this._writeProfilerMark("updateSnapList,StopTM");
                },
                _scrollToSection: function Hub_scrollToSection(index, withAnimation) {
                    this._measure();
                    var sectionSize = this._sectionSizes[index];
                    var scrollPositionToShowStartMargin = Math.min(this._scrollLength - this._viewportSize, sectionSize.offset - sectionSize.marginStart - this._startSpacer);

                    this._scrollTo(scrollPositionToShowStartMargin, withAnimation);
                },
                _ensureVisible: function hub_ensureVisible(index, withAnimation) {
                    this._measure();
                    var targetScrollPos = this._ensureVisibleMath(index, this._scrollPosition);
                    this._scrollTo(targetScrollPos, withAnimation);
                },
                _ensureVisibleMath: function hub_ensureVisibleMath(index, targetScrollPos) {
                    this._measure();
                    var sectionSize = this._sectionSizes[index];

                    var scrollPositionToShowStartMargin = Math.min(this._scrollLength - this._viewportSize, sectionSize.offset - sectionSize.marginStart - this._startSpacer);
                    var scrollPositionToShowEndMargin = Math.max(0, sectionSize.offset + sectionSize.size + sectionSize.marginEnd + this._endSpacer - this._viewportSize + 1);
                    if (targetScrollPos > scrollPositionToShowStartMargin) {
                        targetScrollPos = scrollPositionToShowStartMargin;
                    } else if (targetScrollPos < scrollPositionToShowEndMargin) {
                        targetScrollPos = Math.min(scrollPositionToShowStartMargin, scrollPositionToShowEndMargin);
                    }

                    return targetScrollPos;
                },
                _scrollTo: function hub_scrollTo(scrollPos, withAnimation) {
                    this._scrollPosition = scrollPos;
                    if (withAnimation && this._viewportElement.msZoomTo) {
                        if (this.orientation === WinJS.UI.Orientation.vertical) {
                            this._viewportElement.msZoomTo({ contentX: 0, contentY: this._scrollPosition, viewportX: 0, viewportY: 0 });
                        } else {
                            this._viewportElement.msZoomTo({ contentX: this._scrollPosition, contentY: 0, viewportX: 0, viewportY: 0 });
                        }
                    } else {
                        this._viewportElement[this._names.scrollPos] = this._scrollPosition;
                    }
                },
                _windowKeyDownHandler: function hub_windowKeyDownHandler(ev) {
                    // Include tab and shift tab. Note: Alt Key + Tab and Windows Key + Tab do not fire keydown with ev.key === "Tab".
                    if (ev.key === "Tab") {
                        this._tabSeenLast = true;

                        var that = this;
                        setImmediate(function () {
                            that._tabSeenLast = false;
                        });
                    }
                },
                _focusin: function hub_focusin(ev) {
                    // We attach an event listener to the "focuschanging" event to handle animated scrolling when the user navigates to
                    // either edge of a hub section. We add the event listener here instead of in the constructor, because if we add
                    // the event listener in the constructor, then if the previous page had a hub section, the event will be unregistered
                    // immediately after registering it when the previous hub control's dispose method is called.
                    if (!this._handleFocusChangingBind &&
                        XboxJS.UI.AutomaticFocus.focusRoot) {
                        this._handleFocusChangingBind = this._handleFocusChanging.bind(this);
                        XboxJS.UI.AutomaticFocus.addEventListener("focuschanging", this._handleFocusChangingBind, false);
                    }

                    // On focus we call ensureVisible to handle the tab or shift/tab to header. However if the
                    // focus was caused by a pointer down event we skip the focus.
                    if (this._tabSeenLast) {
                        var headerTabStopElement = this._findHeaderTabStop(ev.srcElement);
                        if (headerTabStopElement && !this._isHeaderInteractive(ev.srcElement)) {
                            var sectionIndex = this.sections.indexOf(headerTabStopElement.parentElement.parentElement.winControl);
                            if (sectionIndex > -1) {
                                this._ensureVisible(sectionIndex, true);
                            }
                        }
                    }

                    // Always remember the focused section for SemanticZoom.
                    var sectionElement = ev.srcElement;
                    while (sectionElement && !WinJS.Utilities.hasClass(sectionElement, XboxJS.UI.HubSection._ClassName.hubSection)) {
                        sectionElement = sectionElement.parentElement;
                    }
                    if (sectionElement) {
                        var sectionIndex = this.sections.indexOf(sectionElement.winControl);
                        if (sectionIndex > -1) {
                            this._currentIndexForSezo = sectionIndex;
                        }
                    }

                    if (ev.srcElement === this.element) {
                        var indexToFocus;
                        if (+this._sectionToFocus === this._sectionToFocus && this._sectionToFocus >= 0 && this._sectionToFocus < this.sections.length) {
                            indexToFocus = this._sectionToFocus;
                            this._sectionToFocus = null;
                        } else {
                            indexToFocus = this.sectionOnScreen;
                        }

                        this._moveFocusIn(indexToFocus);
                    }
                },
                _moveFocusIn: function hub_moveFocusIn(indexToFocus) {
                    if (indexToFocus >= 0) {
                        for (var i = indexToFocus; i < this.sections.length; i++) {
                            var section = this.sections.getAt(i);

                            var focusAttempt = WinJS.Utilities._trySetActive(section._headerTabStopElement);

                            if (focusAttempt) {
                                return;
                            }

                            if (WinJS.Utilities._setActiveFirstFocusableElement(section.contentElement)) {
                                return;
                            }
                        }

                        for (var i = indexToFocus - 1; i >= 0; i--) {
                            var section = this.sections.getAt(i);

                            if (WinJS.Utilities._setActiveFirstFocusableElement(section.contentElement)) {
                                return;
                            }

                            var focusAttempt = WinJS.Utilities._trySetActive(section._headerTabStopElement);

                            if (focusAttempt) {
                                return;
                            }
                        }
                    }
                },
                // If the user was previously engaged with gesture & panned the hub such that focus is off-screen,
                // then we put focus back on screen.
                _handleGestureDisengaged: function hub_handleGestureDisengaged() {
                    var activeElement = document.activeElement;
                    if (!activeElement ||
                        this._disposed) {
                        return;
                    }
                    var activeElementBoundingRect = activeElement.getBoundingClientRect();
                    if (this._element.contains(activeElement) &&
                        activeElementBoundingRect.left < 0 ||
                        activeElementBoundingRect.right > window.innerWidth ||
                        activeElementBoundingRect.top < 0 ||
                        activeElementBoundingRect.bottom > document.body.offsetHeight) {
                        var previousFocusRoot = XboxJS.UI.AutomaticFocus.focusRoot;
                        XboxJS.UI.AutomaticFocus.focusRoot = this._element;
                        var nextFocusElement = XboxJS.UI.AutomaticFocus.findNextFocusElement(WinJS.Utilities.Key.gamepadDPadRight, { top: 0, left: 0, width: 1, height: 1 });
                        if (nextFocusElement) {
                            nextFocusElement.focus();
                        }
                        XboxJS.UI.AutomaticFocus.focusRoot = previousFocusRoot;
                    }
                },
                _handleFocusChanging: function hub_handleFocusChanging(ev) {
                    var automaticFocus = XboxJS.UI.AutomaticFocus;
                    var key = WinJS.Utilities.Key;
                    if (automaticFocus) {
                        var keyCode = ev.detail.keyCode;
                        var nextFocusElement = ev.detail.nextFocusElement;
                        if (nextFocusElement) {

                            // Figure out if we are about to leave a hub section.
                            var nextFocusElementRect = nextFocusElement.getBoundingClientRect();
                            switch (keyCode) {
                                case key.leftArrow:
                                case key.gamepadDPadLeft:
                                case key.gamepadLeftThumbstickLeft:
                                    // Now figure out if we're skipping a section
                                    if (this._currentIndexForSezo > 0) {
                                        var nextSection = this.sections.getAt(this._currentIndexForSezo - 1).element;
                                        var nextSectionRect = nextSection.getBoundingClientRect();
                                        if (nextFocusElementRect.right < nextSectionRect.left) {

                                            // If we've skipped a section, we need to run the algorithm again, this time with the focusRoot
                                            // on the current hub section's element so that we'll either get nothing or an element within the
                                            // hub section.
                                            var previousFocusRoot = automaticFocus.focusRoot;
                                            automaticFocus.focusRoot = nextSection;
                                            var newNextFocusElement = automaticFocus.findNextFocusElement(keyCode);

                                            // If we still don't find anything (which means there's no interactive content in the curren hub section)
                                            // then we'll just focus on the nextFocusElement.
                                            if (newNextFocusElement) {
                                                newNextFocusElement.focus();
                                                // We replace nextFocusElement with the newNextFocusElement so the "scroll into view" code
                                                // below can act on the new element that should recieve focus.
                                                nextFocusElement = newNextFocusElement;
                                                nextFocusElementRect = newNextFocusElement.getBoundingClientRect();
                                                ev.preventDefault();

                                                // Choose one of the 4 focus sounds to play at random
                                                var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                                                switch (indexOfFocusSoundToPlay) {
                                                    case 1:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                            XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                        }
                                                        break;
                                                    case 2:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus2) {
                                                            XboxJS.UI.Hub._sounds.elementFocus2.play();
                                                        }
                                                        break;
                                                    case 3:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus3) {
                                                            XboxJS.UI.Hub._sounds.elementFocus3.play();
                                                        }
                                                        break;
                                                    case 4:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus4) {
                                                            XboxJS.UI.Hub._sounds.elementFocus4.play();
                                                        }
                                                        break;
                                                    default:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                            XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                        }
                                                        break;
                                                }
                                            }

                                            // Restore the focusRoot
                                            automaticFocus.focusRoot = previousFocusRoot;
                                        }
                                    }
                                    var elapsedTimeSinceLastKeydownLeft = new Date().getTime() - this._lastKeydownLeft;
                                    this._lastKeydownLeft = new Date().getTime();
                                    // Figure out if we've hit a "threshold" & need to play an animation
                                    // Note: This behavior does not happen if the user if holding down the left direction
                                    if (nextFocusElementRect.left < this._leftBoundaryToTriggerFixedFocusMode) {
                                        // Call the animation API to bring it into view
                                        if (WinJS.UI.isAnimationEnabled() &&
                                            this._viewportElement.msZoomTo &&
                                            this._viewportElement.contains(nextFocusElement) &&
                                            !XboxJS.Utilities._isSnapped()) {
                                            var xScrollAmount = -1 * (this._leftBoundaryToTriggerFixedFocusMode - nextFocusElementRect.left);
                                            var xScrollPos = Math.max(0, this._viewportElement[this._names.scrollPos] + xScrollAmount);
                                            if (elapsedTimeSinceLastKeydownLeft > 250) {
                                                this._viewportElement.msZoomTo({ contentX: xScrollPos, contentY: 0, viewportX: 0, viewportY: 0 });
                                            } else {
                                                // If the user is holding down or pressing right in rapid succession then skip the animation.
                                                this._viewportElement[this._names.scrollPos] = xScrollPos;
                                            }
                                            // setActive() is cheaper than calling focus() which is what automatic focus will do
                                            WinJS.Utilities._trySetActive(nextFocusElement);
                                            ev.preventDefault();

                                            // Choose one of the 4 focus sounds to play at random
                                            var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                                            switch (indexOfFocusSoundToPlay) {
                                                case 1:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                        XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                    }
                                                    break;
                                                case 2:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus2) {
                                                        XboxJS.UI.Hub._sounds.elementFocus2.play();
                                                    }
                                                    break;
                                                case 3:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus3) {
                                                        XboxJS.UI.Hub._sounds.elementFocus3.play();
                                                    }
                                                    break;
                                                case 4:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus4) {
                                                        XboxJS.UI.Hub._sounds.elementFocus4.play();
                                                    }
                                                    break;
                                                default:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                        XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                    }
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                                case key.rightArrow:
                                case key.gamepadDPadRight:
                                case key.gamepadLeftThumbstickRight:
                                    // Now figure out if we're skipping a section
                                    if (this._currentIndexForSezo + 1 < this.sections.length) {
                                        var nextSectionRect = this.sections.getAt(this._currentIndexForSezo + 1).element.getBoundingClientRect();
                                        if (nextFocusElementRect.left > nextSectionRect.right) {

                                            // If we've skipped a section, we need to run the algorithm again, this time with the focusRoot
                                            // on the current hub section's element so that we'll either get nothing or an element within the
                                            // hub section.
                                            var previousFocusRoot = automaticFocus.focusRoot;
                                            automaticFocus.focusRoot = this.sections.getAt(this._currentIndexForSezo + 1).element;
                                            var newNextFocusElement = automaticFocus.findNextFocusElement(keyCode);

                                            // If we still don't find anything (which means there's no interactive content in the curren hub section)
                                            // then we'll just focus on the nextFocusElement.
                                            if (newNextFocusElement) {
                                                newNextFocusElement.focus();
                                                // We replace nextFocusElement with the newNextFocusElement so the "scroll into view" code
                                                // below can act on the new element that should recieve focus.
                                                nextFocusElement = newNextFocusElement;
                                                nextFocusElementRect = newNextFocusElement.getBoundingClientRect();
                                                ev.preventDefault();

                                                // Choose one of the 4 focus sounds to play at random
                                                var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                                                switch (indexOfFocusSoundToPlay) {
                                                    case 1:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                            XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                        }
                                                        break;
                                                    case 2:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus2) {
                                                            XboxJS.UI.Hub._sounds.elementFocus2.play();
                                                        }
                                                        break;
                                                    case 3:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus3) {
                                                            XboxJS.UI.Hub._sounds.elementFocus3.play();
                                                        }
                                                        break;
                                                    case 4:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus4) {
                                                            XboxJS.UI.Hub._sounds.elementFocus4.play();
                                                        }
                                                        break;
                                                    default:
                                                        if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                            XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                        }
                                                        break;
                                                }
                                            }

                                            // Restore the focusRoot
                                            automaticFocus.focusRoot = previousFocusRoot;
                                        }
                                    }
                                    var elapsedTimeSinceLastKeydownRight = new Date().getTime() - this._lastKeydownRight;
                                    this._lastKeydownRight = new Date().getTime();
                                    // Figure out if we've hit a "threshold" & need to play an animation
                                    // Note: This behavior does not happen if the user if holding down the left direction
                                    if (nextFocusElementRect.right > this._rightBoundaryToTriggerFixedFocusMode) {
                                        // Call the animation API to bring it into view
                                        if (WinJS.UI.isAnimationEnabled() &&
                                            this._viewportElement.msZoomTo &&
                                            this._viewportElement.contains(nextFocusElement) &&
                                            !XboxJS.Utilities._isSnapped()) {
                                            var xScrollAmount = nextFocusElementRect.right - this._rightBoundaryToTriggerFixedFocusMode;
                                            var xScrollPos = Math.max(0, this._viewportElement[this._names.scrollPos] + xScrollAmount);
                                            if (elapsedTimeSinceLastKeydownRight > 250) {
                                                this._viewportElement.msZoomTo({ contentX: xScrollPos, contentY: 0, viewportX: 0, viewportY: 0 });
                                            } else {
                                                // If the user is holding down or pressing right in rapid succession then skip the animation.
                                                this._viewportElement[this._names.scrollPos] = xScrollPos;
                                            }

                                            // setActive() is cheaper than calling focus() which is what automatic focus will do
                                            WinJS.Utilities._trySetActive(nextFocusElement);
                                            ev.preventDefault();

                                            // Choose one of the 4 focus sounds to play at random
                                            var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                                            switch (indexOfFocusSoundToPlay) {
                                                case 1:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                        XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                    }
                                                    break;
                                                case 2:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus2) {
                                                        XboxJS.UI.Hub._sounds.elementFocus2.play();
                                                    }
                                                    break;
                                                case 3:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus3) {
                                                        XboxJS.UI.Hub._sounds.elementFocus3.play();
                                                    }
                                                    break;
                                                case 4:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus4) {
                                                        XboxJS.UI.Hub._sounds.elementFocus4.play();
                                                    }
                                                    break;
                                                default:
                                                    if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                        XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                    }
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                                case key.downArrow:
                                case key.gamepadDPadDown:
                                case key.gamepadLeftThumbstickDown:
                                    // We don't want to move to another section when moving down
                                    if (this._viewportElement.contains(document.activeElement)) {
                                        var currentSectionElement = this.sections.getAt(this._currentIndexForSezo).element;
                                        var currentSectionRect = currentSectionElement.getBoundingClientRect();
                                        if (nextFocusElementRect.right < currentSectionRect.left ||
                                            nextFocusElementRect.left > currentSectionRect.right) {
                                            // Note: We need code to check if the current focused item is in a flyout, because it's possible to embed a flyout
                                            // inside of a hub section. For instance, a ratingPicker. Developers shouldn't do this and once we fix the RatingPicker & 
                                            // other flyout-based controls to attach their flyouts to the body we can get rid of this code and always call preventDefault.
                                            var isFocusInFlyout = false;
                                            var overlays = currentSectionElement.querySelectorAll(".win-overlay");
                                            if (overlays.length) {
                                                for (var i = 0, len = overlays.length; i < len; i++) {
                                                    if (overlays[i].contains(nextFocusElement)) {
                                                        isFocusInFlyout = true;
                                                        break;
                                                    }
                                                }
                                            }
                                            if (!isFocusInFlyout) {
                                                ev.preventDefault();
                                            }
                                        } else {
                                            // Going down may also cause us to land on an element that is not entirely in the viewport. If it is not in the
                                            // viewport then we need to scroll it into view.
                                            if (nextFocusElementRect.left < this._leftBoundaryToTriggerFixedFocusMode) {
                                                // Call the animation API to bring it into view
                                                if (WinJS.UI.isAnimationEnabled() &&
                                                    this._viewportElement.msZoomTo &&
                                                    this._viewportElement.contains(nextFocusElement) &&
                                                    !XboxJS.Utilities._isSnapped()) {
                                                    var xScrollAmount = -1 * (this._leftBoundaryToTriggerFixedFocusMode - nextFocusElementRect.left);
                                                    var xScrollPos = Math.max(0, this._viewportElement[this._names.scrollPos] + xScrollAmount);
                                                    if (elapsedTimeSinceLastKeydownLeft > 250) {
                                                        this._viewportElement.msZoomTo({ contentX: xScrollPos, contentY: 0, viewportX: 0, viewportY: 0 });
                                                    } else {
                                                        // If the user is holding down or pressing right in rapid succession then skip the animation.
                                                        this._viewportElement[this._names.scrollPos] = xScrollPos;
                                                    }
                                                    // setActive() is cheaper than calling focus() which is what automatic focus will do
                                                    WinJS.Utilities._trySetActive(nextFocusElement);
                                                    ev.preventDefault();

                                                    // Choose one of the 4 focus sounds to play at random
                                                    var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                                                    switch (indexOfFocusSoundToPlay) {
                                                        case 1:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                                XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                            }
                                                            break;
                                                        case 2:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus2) {
                                                                XboxJS.UI.Hub._sounds.elementFocus2.play();
                                                            }
                                                            break;
                                                        case 3:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus3) {
                                                                XboxJS.UI.Hub._sounds.elementFocus3.play();
                                                            }
                                                            break;
                                                        case 4:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus4) {
                                                                XboxJS.UI.Hub._sounds.elementFocus4.play();
                                                            }
                                                            break;
                                                        default:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                                XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                            }
                                                            break;
                                                    }
                                                }
                                            } else if (nextFocusElementRect.right > this._rightBoundaryToTriggerFixedFocusMode) {
                                                // Call the animation API to bring it into view
                                                if (WinJS.UI.isAnimationEnabled() &&
                                                    this._viewportElement.msZoomTo &&
                                                    this._viewportElement.contains(nextFocusElement) &&
                                                    !XboxJS.Utilities._isSnapped()) {
                                                    var xScrollAmount = nextFocusElementRect.right - this._rightBoundaryToTriggerFixedFocusMode;
                                                    var xScrollPos = Math.max(0, this._viewportElement[this._names.scrollPos] + xScrollAmount);
                                                    if (elapsedTimeSinceLastKeydownRight > 250) {
                                                        this._viewportElement.msZoomTo({ contentX: xScrollPos, contentY: 0, viewportX: 0, viewportY: 0 });
                                                    } else {
                                                        // If the user is holding down or pressing right in rapid succession then skip the animation.
                                                        this._viewportElement[this._names.scrollPos] = xScrollPos;
                                                    }

                                                    // setActive() is cheaper than calling focus() which is what automatic focus will do
                                                    WinJS.Utilities._trySetActive(nextFocusElement);
                                                    ev.preventDefault();

                                                    // Choose one of the 4 focus sounds to play at random
                                                    var indexOfFocusSoundToPlay = Math.ceil(Math.random() * 4);
                                                    switch (indexOfFocusSoundToPlay) {
                                                        case 1:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                                XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                            }
                                                            break;
                                                        case 2:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus2) {
                                                                XboxJS.UI.Hub._sounds.elementFocus2.play();
                                                            }
                                                            break;
                                                        case 3:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus3) {
                                                                XboxJS.UI.Hub._sounds.elementFocus3.play();
                                                            }
                                                            break;
                                                        case 4:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus4) {
                                                                XboxJS.UI.Hub._sounds.elementFocus4.play();
                                                            }
                                                            break;
                                                        default:
                                                            if (XboxJS.UI.Hub._sounds.elementFocus1) {
                                                                XboxJS.UI.Hub._sounds.elementFocus1.play();
                                                            }
                                                            break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    break;
                                    // Note: There is no special logic for down. Also, at this time We do not support special focus handling for the 
                                    // hub control in vertical layout mode.
                                default:
                                    break;
                            }
                        }
                    }
                },
                _handleResize: function hub_handleResize() {
                    var that = this;
                    setImmediate(function afterDOMFinishedProcessing() {
                        if (that._disposed) {
                            return;
                        }
                        // 100 is the size of the title safe area in pixels
                        that._leftBoundaryToTriggerFixedFocusMode = 100;
                        that._rightBoundaryToTriggerFixedFocusMode = window.innerWidth - that._leftBoundaryToTriggerFixedFocusMode;
                    });
                },
                _keyDownHandler: function hub_keyDownHandler(ev) {
                    var leftKey = this._rtl ? "Right" : "Left";
                    var rightKey = this._rtl ? "Left" : "Right";


                    var keyCode = WinJS.Utilities.Key;
                    var dPadLeft = this._rtl ? keyCode.gamepadDPadRight : keyCode.gamepadDPadLeft;
                    var dPadRight = this._rtl ? keyCode.gamepadDPadLeft : keyCode.gamepadDPadRight;
                    var leftThumbStickLeft = this._rtl ? keyCode.gamepadLeftThumbstickRight : keyCode.gamepadLeftThumbstickLeft;
                    var leftThumbStickRight = this._rtl ? keyCode.gamepadLeftThumbstickLeft : keyCode.gamepadLeftThumbstickRight;
                    var dPadDown = keyCode.gamepadDPadDown;
                    var dPadUp = keyCode.gamepadDPadUp;
                    var leftThumbStickDown = keyCode.gamepadLeftThumbstickDown;
                    var leftThumbStickUp = keyCode.gamepadLeftThumbstickUp;

                    this._skipFocus = true;

                    if (ev.key === "Up" || ev.key === "Down" || ev.key === "Left" || ev.key === "Right" || ev.key === "PageUp" || ev.key === "PageDown" ||
                        ev.keyCode === dPadLeft || ev.keyCode === leftThumbStickLeft || ev.keyCode === dPadRight || ev.keyCode === leftThumbStickRight ||
                        ev.keyCode === dPadDown || ev.keyCode === dPadUp || ev.keyCode === leftThumbStickDown || ev.keyCode === leftThumbStickUp) {
                        var headerTabStopElement = this._findHeaderTabStop(ev.srcElement);
                        if (headerTabStopElement && !this._isHeaderInteractive(ev.srcElement)) {
                            var currentSection = this.sections.indexOf(headerTabStopElement.parentElement.parentElement.winControl);
                            var targetSectionIndex;
                            var useEnsureVisible = false;
                            // Page up/down go to the next/previous header and line it up with the app header. End/Home use
                            // default browser behavior (no focus change but scroll to start/end). Up/Right/Down/Left move 
                            // focus to the next/previous header and move it on screen (app header distance from either edge).
                            if (ev.key === "PageDown" ||
                                (this.orientation === WinJS.UI.Orientation.horizontal && (ev.key === rightKey || ev.keyCode === dPadRight || ev.keyCode === leftThumbStickRight)) ||
                                (this.orientation === WinJS.UI.Orientation.vertical && (ev.key === "Down" || ev.keyCode === dPadDown || ev.keyCode === leftThumbStickDown))) {
                                // Do not include hidden headers.
                                for (var i = currentSection + 1; i < this.sections.length; i++) {
                                    var section = this.sections.getAt(i);
                                    if (!XboxJS.UI.AutomaticFocus &&
                                        this._tryFocus(i)) {
                                        targetSectionIndex = i;
                                        break;
                                    }
                                }
                            } else if (ev.key === "PageUp" ||
                                (this.orientation === WinJS.UI.Orientation.horizontal && (ev.key === leftKey || ev.keyCode === dPadLeft || ev.keyCode === leftThumbStickLeft)) ||
                                (this.orientation === WinJS.UI.Orientation.vertical && (ev.key === "Up" || ev.keyCode === dPadUp || ev.keyCode === leftThumbStickUp))) {
                                // Do not include hidden headers.
                                for (var i = currentSection - 1; i >= 0; i--) {
                                    var section = this.sections.getAt(i);
                                    if (!XboxJS.UI.AutomaticFocus &&
                                        this._tryFocus(i)) {
                                        targetSectionIndex = i;
                                        break;
                                    }
                                }
                            }
                            if (ev.key === "Right" || ev.key === "Down" || ev.key === "Left" || ev.key === "Up" ||
                                ev.keyCode === dPadLeft || ev.keyCode === leftThumbStickLeft || ev.keyCode === dPadRight || ev.keyCode === leftThumbStickRight ||
                                ev.keyCode === dPadDown || ev.keyCode === dPadUp || ev.keyCode === leftThumbStickDown || ev.keyCode === leftThumbStickUp) {
                                useEnsureVisible = true;
                            }

                            if (+targetSectionIndex === targetSectionIndex) {
                                if (useEnsureVisible) {
                                    this._ensureVisible(targetSectionIndex, true);
                                } else {
                                    this._scrollToSection(targetSectionIndex, true);
                                }
                            }

                            ev.preventDefault();
                        }
                    }

                    if (XboxJS) {
                        if (ev.key === "GamepadLeftShoulder") {
                            this._previousPage();
                        } else if (ev.key === "GamepadRightShoulder") {
                            this._nextPage();
                        }
                    }
                    this._skipFocus = false;
                },
                _tryFocus: function hub_tryFocus(index) {
                    var targetSection = this.sections.getAt(index);

                    try {
                        targetSection._headerTabStopElement.setActive();
                    } catch (e) {
                    }

                    return document.activeElement === targetSection._headerTabStopElement;
                },
                _previousPage: function hub_previousPage() {
                    this._updatePreviousNextVoiceLabelsBind();
                    if (!this._canPreviousPage) {
                        return;
                    }

                    var keyCode = WinJS.Utilities.Key;

                    if (XboxJS.UI.Hub._sounds.pageTransitionLeft) {
                        XboxJS.UI.Hub._sounds.pageTransitionLeft.play();
                    }

                    var hubElementClientRect = this._element.getBoundingClientRect();
                    var leftBoundary = Math.max(0, hubElementClientRect.left);
                    var rightBoundary = Math.min(window.innerWidth, hubElementClientRect.right);

                    // Normally, we set focus to the rightmost element, but if we are on the first hub section, and the hub cannot
                    // scroll a full page width, then we set focus to the first element of the first hub section.
                    var nextFocusElement = null;
                    var currentFocusElementRect = null;
                    if (!document.activeElement) {
                        return;
                    }
                    currentFocusElementRect = document.activeElement.getBoundingClientRect();
                    var focusHintRectangle = {
                        top: currentFocusElementRect.top,
                        left: leftBoundary - 1,
                        width: 1,
                        height: currentFocusElementRect.height
                    };

                    var previousFocusRoot = XboxJS.UI.AutomaticFocus.focusRoot;
                    // Restrict to elements in the Hub
                    XboxJS.UI.AutomaticFocus.focusRoot = this._viewportElement;
                    // The next focusable element is supposed to be the last focusable element in view
                    var elementToKeepInView = XboxJS.UI.AutomaticFocus.findNextFocusElement(keyCode.gamepadDPadRight, focusHintRectangle);
                    var elementToKeepInViewRect = {};
                    if (elementToKeepInView) {
                        elementToKeepInViewRect = elementToKeepInView.getBoundingClientRect();
                    } else {
                        // If the focus algorithm didn't return a new element to focus on that means the current focused element is
                        // the element it found.
                        elementToKeepInViewRect = currentFocusElementRect;
                    }
                    XboxJS.UI.AutomaticFocus.focusRoot = previousFocusRoot;

                    // The '100' is for action safe
                    var scrollAmountX = -1 * (rightBoundary - leftBoundary - elementToKeepInViewRect.right - 100);

                    // Just scroll a page if an element is greater than the size of the page
                    if (scrollAmountX > 0) {
                        scrollAmountX = rightBoundary - leftBoundary - 100;
                    }
                    
                    var newScrollPosX = this._viewportElement[this._names.scrollPos] + scrollAmountX;
                    
                    if (elementToKeepInView) {
                        elementToKeepInView.focus();
                    }

                    if (this._viewportElement.msZoomTo) {
                        this._viewportElement.msZoomTo({ contentX: newScrollPosX, contentY: 0, viewportX: 0, viewportY: 0 });
                    }
                },
                _nextPage: function hub_nextPage() {
                    this._updatePreviousNextVoiceLabelsBind();
                    if (!this._canNextPage) {
                        return;
                    }

                    var keyCode = WinJS.Utilities.Key;

                    if (XboxJS.UI.Hub._sounds.pageTransitionRight) {
                        XboxJS.UI.Hub._sounds.pageTransitionRight.play();
                    }

                    // Figure out the amount to scroll. It's either the viewport width or the document width, whichever is smaller
                    //var rightHubEdge = Math.min(window.innerWidth , this._viewportSize);
                    var hubElementClientRect = this._element.getBoundingClientRect();
                    var leftBoundary = Math.max(0, hubElementClientRect.left);
                    var rightBoundary = Math.min(window.innerWidth, hubElementClientRect.right);

                    // Normally, we set focus to the leftmost element, but if we are on the last hub section, and the hub cannot
                    // scroll a full page width, then we set focus to the last element of the last hub section.
                    var nextFocusElement = null;
                    var currentFocusElementRect = null;
                    if (!document.activeElement) {
                        return;
                    }
                    currentFocusElementRect = document.activeElement.getBoundingClientRect();
                    var focusHintRectangle = {
                        top: currentFocusElementRect.top,
                        left: rightBoundary + 1,
                        width: 1,
                        height: currentFocusElementRect.height
                    };

                    var previousFocusRoot = XboxJS.UI.AutomaticFocus.focusRoot;
                    // Restrict to elements in the Hub
                    XboxJS.UI.AutomaticFocus.focusRoot = this._viewportElement;
                    // The next focusable element is supposed to be the last focusable element in view
                    var elementToKeepInView = XboxJS.UI.AutomaticFocus.findNextFocusElement(keyCode.gamepadDPadLeft, focusHintRectangle);
                    var elementToKeepInViewRect = {};
                    if (elementToKeepInView) {
                        elementToKeepInViewRect = elementToKeepInView.getBoundingClientRect();
                    } else {
                        // If the focus algorithm didn't return a new element to focus on that means the current focused element is
                        // the element it found.
                        elementToKeepInViewRect = currentFocusElementRect;
                    }
                    XboxJS.UI.AutomaticFocus.focusRoot = previousFocusRoot;

                    // The '100' is for action safe
                    var scrollAmountX = (rightBoundary - leftBoundary - (rightBoundary - elementToKeepInViewRect.left) - 100);

                    // Just scroll a page if an element is greater than the size of the page
                    if (scrollAmountX < 0) {
                        scrollAmountX = rightBoundary - leftBoundary - 100;
                    }

                    var newScrollPosX = this._viewportElement[this._names.scrollPos] + scrollAmountX;
                    
                    if (elementToKeepInView) {
                        elementToKeepInView.focus();
                    }

                    if (this._viewportElement.msZoomTo) {
                        this._viewportElement.msZoomTo({ contentX: newScrollPosX, contentY: 0, viewportX: 0, viewportY: 0 });
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.Hub.zoomableView" helpKeyword="XboxJS.UI.Hub.zoomableView" isAdvanced="true">
                /// Gets a ZoomableView. This API supports the SemanticZoom infrastructure
                /// and is not intended to be used directly from your code.
                /// </field>
                zoomableView: {
                    get: function zoomableView_get() {
                        if (!this._zoomableView) {
                            this._zoomableView = new ZoomableView(this);
                        }

                        return this._zoomableView;
                    }
                },
                _getPanAxis: function hub_getPanAxis() {
                    return this.orientation === WinJS.UI.Orientation.horizontal ? "horizontal" : "vertical";
                },
                _configureForZoom: function hub_configureForZoom(isZoomedOut, isCurrentView, triggerZoom, prefetchedPages) {
                    // Nothing to configure.
                },
                _setCurrentItem: function hub_setCurrentItem(x, y) {
                    var offset;
                    if (this.orientation === WinJS.UI.Orientation.horizontal) {
                        offset = x;
                    } else {
                        offset = y;
                    }

                    this._measure();
                    offset = offset + this._scrollPosition;
                    this._currentIndexForSezo = this._sectionSizes.length - 1;
                    for (var i = 1; i < this._sectionSizes.length; i++) {
                        var sectionSize = this._sectionSizes[i];
                        if (sectionSize.offset - sectionSize.marginStart > offset) {
                            this._currentIndexForSezo = i - 1;
                            break;
                        }
                    }
                },
                _getCurrentItem: function hub_getCurrentItem() {
                    var itemPosition;
                    if (this._sectionSizes.length > 0) {
                        this._measure();
                        var index = Math.max(0, Math.min(this._currentIndexForSezo, this._sectionSizes.length));
                        var sectionSize = this._sectionSizes[index];
                        if (this.orientation === WinJS.UI.Orientation.horizontal) {
                            itemPosition = {
                                left: Math.max(0, sectionSize.offset - sectionSize.marginStart - this._scrollPosition),
                                top: 0,
                                width: sectionSize.size,
                                height: this._viewportOppositeSize
                            };
                        } else {
                            itemPosition = {
                                left: 0,
                                top: Math.max(0, sectionSize.offset - sectionSize.marginStart - this._scrollPosition),
                                width: this._viewportOppositeSize,
                                height: sectionSize.size,
                            };
                        }

                        var section = this.sections.getAt(index);
                        // BUGBUG: 53301 ListView and Hub should document what they expect to be returned from the
                        // getCurrentItem so that positionItem apis line up. ListView zoomed out expects an object with
                        // groupIndexHint, groupKey, or groupDescription. Hub expects an object with index.
                        return WinJS.Promise.wrap({ item: { data: section, index: index, groupIndexHint: index }, position: itemPosition });
                    }
                },
                _beginZoom: function hub_beginZoom() {
                    // Hide scroll thumb.
                    this._viewportElement.style["-ms-overflow-style"] = "none";
                },
                _positionItem: function hub_positionItem(item, position) {
                    if (item.index >= 0 && item.index < this._sectionSizes.length) {
                        this._measure();
                        var sectionSize = this._sectionSizes[item.index];

                        var offsetFromViewport;
                        if (this.orientation === WinJS.UI.Orientation.horizontal) {
                            offsetFromViewport = position.left;
                        } else {
                            offsetFromViewport = position.top;
                        }

                        this._sectionToFocus = item.index;

                        var targetScrollPosition = sectionSize.offset - offsetFromViewport;
                        // clamp section: 
                        var targetScrollPosition = this._ensureVisibleMath(item.index, targetScrollPosition);

                        this._viewportElement[this._names.scrollPos] = this._scrollPosition = targetScrollPosition;
                    }
                },
                _endZoom: function hub_endZoom(isCurrentView) {
                    // Show scroll thumb.
                    this._viewportElement.style["-ms-overflow-style"] = "";
                },
                _writeProfilerMark: function hub_writeProfilerMark(text) {
                    var message = "XboxJS.UI.Hub:" + this._id + ":" + text;
                    msWriteProfilerMark(message);
                    WinJS.log && WinJS.log(message, null, "hubprofiler");
                },
                dispose: function hub_dispose() {
                    /// <signature helpKeyword="XboxJS.UI.Hub.dispose">
                    /// <summary locid="XboxJS.UI.Hub.dispose">
                    /// Disposes this control.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    window.removeEventListener('keydown', this._windowKeyDownHandlerBound);

                    this._updateEvents(this._sections);

                    for (var i = 0; i < this.sections.length; i++) {
                        this.sections.getAt(i).dispose();
                    }

                    if (XboxJS) {
                        XboxJS.UI.AutomaticFocus.removeEventListener("focuschanging", this._handleFocusChangingBind);
                        this._handleFocusChangingBind = null;

                        window.removeEventListener("gesturedisengaged", this._handleGestureDisengagedBind);
                        this._handleGestureDisengagedBind = null;
                        XboxJS.UI.Voice.removeEventListener("listeningstart", this._updatePreviousNextVoiceLabelsBind);

                        window.removeEventListener("resize", this._handleResizeBind);
                        this._handleResizeBind = null;

                        this._previousPageBind = null;
                        this._previousPageBind = null;
                        this._updatePreviousNextVoiceLabelsBind = null;
                        this._lastKeydownLeft = null;
                        this._lastKeydownRight = null;
                    }
                }
            }, {
                /// <field locid="XboxJS.UI.Hub.AnimationType" helpKeyword="XboxJS.UI.Hub.AnimationType">
                /// Specifies whether the Hub animation is an entrance animation or a transition animation.
                /// </field>
                AnimationType: {
                    /// <field locid="XboxJS.UI.Hub.AnimationType.entrance" helpKeyword="XboxJS.UI.Hub.AnimationType.entrance">
                    /// The animation plays when the Hub is first displayed.
                    /// </field>
                    entrance: "entrance",
                    /// <field locid="XboxJS.UI.Hub.AnimationType.contentTransition" helpKeyword="XboxJS.UI.Hub.AnimationType.contentTransition">
                    /// The animation plays when the Hub is changing its content.
                    /// </field>
                    contentTransition: "contentTransition",
                    /// <field locid="XboxJS.UI.Hub.AnimationType.insert" helpKeyword="XboxJS.UI.Hub.AnimationType.insert">
                    /// The animation plays when a section is inserted into the Hub.
                    /// </field>
                    insert: "insert",
                    /// <field locid="XboxJS.UI.Hub.AnimationType.remove" helpKeyword="XboxJS.UI.Hub.AnimationType.remove">
                    /// The animation plays when a section is removed into the Hub.
                    /// </field>
                    remove: "remove",
                },
                /// <field locid="XboxJS.UI.Hub.LoadingState" helpKeyword="XboxJS.UI.Hub.LoadingState">
                /// Specifies the current state of the Hub.
                /// </field>
                LoadingState: {
                    /// <field locid="XboxJS.UI.Hub.LoadingState.loading" helpKeyword="XboxJS.UI.Hub.LoadingState.loading">
                    /// The Hub is loading sections.
                    /// </field>
                    loading: "loading",
                    /// <field locid="XboxJS.UI.Hub.LoadingState.complete" helpKeyword="XboxJS.UI.Hub.LoadingState.complete">
                    /// All sections are loaded and animations are complete.
                    /// </field>
                    complete: "complete"
                },
                // Names of classes used by the Hub.
                _ClassName: {
                    hub: "win-hub",
                    hubSurface: "win-hub-surface",
                    // On Xbox, we use a ring to show progress in the hub control
                    hubProgress: "win-hub-progress win-ring",
                    hubViewport: "win-hub-viewport",
                    hubVertical: "win-hub-vertical",
                    hubHorizontal: "win-hub-horizontal",
                    previousNextVoiceContainer: "win-hub-previousnextvoicecontainer",
                    previousPageLabel: "win-hub-previouspagelabel",
                    nextPageLabel: "win-hub-nextpagelabel"
                },
                // Names of events fired by the Hub.
                _EventName: {
                    contentAnimating: eventNames.contentAnimating,
                    headerInvoked: eventNames.headerInvoked,
                    loadingStateChanged: eventNames.loadingStateChanged
                },
                _sounds: {
                    pageTransitionLeft: null,
                    pageTransitionRright: null,
                    elementFocus1: null,
                    elementFocus2: null,
                    elementFocus3: null,
                    elementFocus4: null,
                    initialized: false
                },
                isDeclarativeControlContainer: true
            });
            WinJS.Class.mix(Hub, WinJS.UI.DOMEventMixin);
            var ZoomableView = WinJS.Class.define(function ZoomableView_ctor(hub) {
                this._hub = hub;
            }, {
                getPanAxis: function () {
                    return this._hub._getPanAxis();
                },
                configureForZoom: function (isZoomedOut, isCurrentView, triggerZoom, prefetchedPages) {
                    this._hub._configureForZoom(isZoomedOut, isCurrentView, triggerZoom, prefetchedPages);
                },
                setCurrentItem: function (x, y) {
                    this._hub._setCurrentItem(x, y);
                },
                getCurrentItem: function () {
                    return this._hub._getCurrentItem();
                },
                beginZoom: function () {
                    this._hub._beginZoom();
                },
                positionItem: function (item, position) {
                    return this._hub._positionItem(item, position);
                },
                endZoom: function (isCurrentView) {
                    this._hub._endZoom(isCurrentView);
                }
            });

            var strings = {
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; },
                get duplicateSection() { return WinJS.Resources._getWinJSString("ui/duplicateSection").value; },
                get invalidContent() { return WinJS.Resources._getWinJSString("ui/invalidHubContent").value; },
                get hubViewportAriaLabel() { return WinJS.Resources._getWinJSString("ui/hubViewportAriaLabel").value; },
                get previousPage() { return WinJS.Resources._getWinJSString("tv/PREVIOUS_PAGE_COMMAND_VUI_ALM").value; },
                get nextPage() { return WinJS.Resources._getWinJSString("tv/NEXT_PAGE_COMMAND_VUI_ALM").value; }
            };
            return Hub;
        })
    });

})(this, WinJS);
(function hubSectionInit(global, WinJS, undefined) {
    "use strict";

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.HubSection">
        /// HubSection is single group of content for a Hub.
        /// </summary>
        /// <icon src="ui_xboxjs.ui.hubsection.12x12.png" width="12" height="12" />
        /// <icon src="ui_xboxjs.ui.hubsection.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.HubSection" data-win-options="{header: 'HubSection Header'}">HubSection Content</div>]]></htmlSnippet>
        /// <part name="hubsection" class="win-hub-section" locid="XboxJS.UI.HubSection_part:hubsection">The entire HubSection control.</part>
        /// <part name="header" class="win-hub-section-header" locid="XboxJS.UI.HubSection_part:header">The header region of the HubSection.</part>
        /// <part name="headertabstop" class="win-hub-section-header-tabstop" locid="XboxJS.UI.HubSection_part:headertabstop">The tab stop region of the header region of the HubSection.</part>
        /// <part name="headercontent" class="win-hub-section-header-content" locid="XboxJS.UI.HubSection_part:headercontent">The content region of the header region of the HubSection.</part>
        /// <part name="headerchevron" class="win-hub-section-header-chevron" locid="XboxJS.UI.HubSection_part:headerchevron">The chevron region of the header region of the HubSection.</part>
        /// <part name="content" class="win-hub-section-content" locid="XboxJS.UI.HubSection_part:content">The content region of the HubSection.</part>
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.Xbox.WinJS.1.0/css/ui-dark.css" shared="true" />
        HubSection: WinJS.Namespace._lazy(function() {
            var strings = {
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; }
            };

            return WinJS.Class.define(function HubSection_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.HubSection.HubSection">
                /// <summary locid="XboxJS.UI.HubSection.constructor">
                /// Creates a new HubSection.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.HubSection.constructor_p:element">
                /// The DOM element that hosts the HubSection control.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.HubSection.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.HubSection" locid="XboxJS.UI.HubSection.constructor_returnValue">
                /// The new HubSection.
                /// </returns>
                /// </signature>
                element = element || document.createElement("DIV");
                options = options || {};

                if (element.winControl) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.HubSection.DuplicateConstruction", strings.duplicateConstruction);
                }

                // Attaching JS control to DOM element
                element.winControl = this;
                this._element = element;
                WinJS.Utilities.addClass(this.element, XboxJS.UI.HubSection._ClassName.hubSection);
                WinJS.Utilities.addClass(this.element, "win-disposable");

                // Not using innerHTML here because there could have been some children already.
                this._headerElement = document.createElement("DIV");
                this._headerElement.className = XboxJS.UI.HubSection._ClassName.hubSectionHeader
                this._headerElement.innerHTML =
                    '<button type="button" role="link" class="' + XboxJS.UI.HubSection._ClassName.hubSectionInteractive + ' ' + XboxJS.UI.HubSection._ClassName.hubSectionHeaderTabStop + '">' +
                        '<h2 class="' + XboxJS.UI.HubSection._ClassName.hubSectionHeaderContent + ' ' + XboxJS.UI.HubSection._Constants.ellipsisTypeClassName + ' ' + XboxJS.UI.HubSection._Constants.xLargeTypeClassName + '"></h2>' +
                        '<span class="' + XboxJS.UI.HubSection._ClassName.hubSectionHeaderChevron + ' ' + XboxJS.UI.HubSection._Constants.ellipsisTypeClassName + ' ' + XboxJS.UI.HubSection._Constants.xLargeTypeClassName + '"></span>' +
                    '</button>';
                this._headerTabStopElement = this._headerElement.firstElementChild;
                this._headerContentElement = this._headerTabStopElement.firstElementChild;
                this._headerChevronElement = this._headerTabStopElement.lastElementChild;
                element.appendChild(this._headerElement);

                this._contentElement = document.createElement("DIV");
                this._contentElement.className = XboxJS.UI.HubSection._ClassName.hubSectionContent;
                this._contentElement.style.visibility = "hidden";
                element.appendChild(this._contentElement);

                // Reparent any existing elements inside the new hub section content element.
                var elementToMove = this.element.firstChild;
                while (elementToMove !== this._headerElement) {
                    var nextElement = elementToMove.nextSibling;
                    this._contentElement.appendChild(elementToMove);
                    elementToMove = nextElement;
                }

                this._dataWinVoiceOverride = null;

                this._processors = [WinJS.UI.processAll];

                WinJS.UI.setOptions(this, options);
            }, {
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.HubSection.element" helpKeyword="XboxJS.UI.HubSection.element">
                /// Gets the DOM element that hosts the HubSection.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },
                /// <field type="Boolean" locid="XboxJS.UI.HubSection.isHeaderStatic" helpKeyword="XboxJS.UI.HubSection.isHeaderStatic">
                /// Gets or sets the interactivity of the HubSection's header.
                /// </field>
                isHeaderStatic: {
                    get: function () {
                        return this._isHeaderStatic;
                    },
                    set: function (value) {
                        this._isHeaderStatic = value;
                        if (!this._isHeaderStatic) {
                            this._headerTabStopElement.setAttribute("role", "link");
                            WinJS.Utilities.addClass(this._headerTabStopElement, XboxJS.UI.HubSection._ClassName.hubSectionInteractive);
                        } else {
                            this._headerTabStopElement.setAttribute("role", "heading");
                            WinJS.Utilities.removeClass(this._headerTabStopElement, XboxJS.UI.HubSection._ClassName.hubSectionInteractive);

                            // If the header is non-interactive, then we set tabIndex to -1 so that it does not participate in automatic focus.
                            this._headerTabStopElement.tabIndex = -1;
                        }
                    }
                },
                /// <field type="HTMLElement" domElement="true" locid="XboxJS.UI.HubSection.contentElement" helpKeyword="XboxJS.UI.HubSection.contentElement">
                /// Gets the DOM element that hosts the HubSection's content.
                /// </field>
                contentElement: {
                    get: function () {
                        return this._contentElement;
                    }
                },
                /// <field type="Object" locid="XboxJS.UI.HubSection.header" helpKeyword="XboxJS.UI.HubSection.header">
                /// Get or set the object which represents the HubSection's header. When it is set the Hub renders the header again.
                /// </field>
                header: {
                    get: function () {
                        return this._header;
                    },
                    set: function (value) {
                        // Render again even if it is equal to itself.
                        this._header = value;
                        this._renderHeader();
                    }
                },
                _setHeaderTemplate: function HubSection_setHeaderTemplate(template) {
                    this._template = WinJS.Utilities._syncRenderer(template);
                    this._renderHeader();
                },
                _renderHeader: function HubSection_renderHeader(voiceOnly) {
                    if (this._template) {
                        if (!voiceOnly) {
                            WinJS.Utilities._disposeElement(this._headerContentElement);
                            WinJS.Utilities.empty(this._headerContentElement);
                            this._template(this, this._headerContentElement);
                        }

                        if (XboxJS.UI.Voice && !this._isHeaderStatic) {
                            XboxJS.UI.Voice.updateVoiceAttribute(this._headerElement, this._dataWinVoiceOverride, 'select(\".win-hub-section-header-content\")');
                            XboxJS.UI.Voice.refreshVoiceElements();
                        }
                    }
                },
                _process: function HubSection_process() {
                    var that = this;

                    this._processed = (this._processors || []).reduce(function (promise, processor) {
                        return promise.then(function () {
                            return processor(that.contentElement);
                        });
                    }, this._processed || WinJS.Promise.as());
                    this._processors = null;

                    return this._processed;
                },
                dispose: function HubSection_dispose() {
                    /// <signature helpKeyword="XboxJS.UI.HubSection.dispose">
                    /// <summary locid="XboxJS.UI.HubSection.dispose">
                    /// Disposes this control.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;
                    this._dataWinVoiceOverride = null;

                    WinJS.Utilities._disposeElement(this._headerContentElement);
                    WinJS.Utilities.disposeSubTree(this.contentElement);
                },
                /// <field type="Object" locid="XboxJS.UI.HubSection.dataWinVoiceOverride" helpKeyword="XboxJS.UI.HubSection.dataWinVoiceOverride">
                /// Get or set the object which represents the overrides for data-win-voice options for the Hub. When it is set the Tab renders the header again.
                /// </field>
                dataWinVoiceOverride: {
                    get: function () {
                        return this._dataWinVoiceOverride;
                    },
                    set: function (value) {
                        if ((this._dataWinVoiceOverride === value) ||
                            ((this._dataWinVoiceOverride && value) &&
                             (this._dataWinVoiceOverride.pronunciation === value.pronunciation) &&
                             (this._dataWinVoiceOverride.confidence === value.confidence) &&
                             (this._dataWinVoiceOverride.phrase === value.phrase) &&
                             (this._dataWinVoiceOverride.enumerate === value.enumerate))) {
                            return;
                        }

                        this._dataWinVoiceOverride = value;

                        this._renderHeader(true);
                    }
                }
            }, {
                // Names of classes used by the HubSection.
                _ClassName: {
                    hubSection: "win-hub-section",
                    hubSectionHeader: "win-hub-section-header",
                    hubSectionHeaderTabStop: "win-hub-section-header-tabstop",
                    hubSectionInteractive: "win-hub-section-header-interactive",
                    hubSectionHeaderContent: "win-hub-section-header-content",
                    hubSectionHeaderChevron: "win-hub-section-header-chevron",
                    hubSectionContent: "win-hub-section-content"
                },
                _Constants: {
                    ellipsisTypeClassName: "win-type-ellipsis",
                    xLargeTypeClassName: "win-type-x-large"
                },
                isDeclarativeControlContainer: WinJS.Utilities.markSupportedForProcessing(function (section, callback) {
                    if (callback === WinJS.UI.processAll) {
                        return;
                    }

                    section._processors = section._processors || [];
                    section._processors.push(callback);

                    // Once processed the first time synchronously queue up new processors as they come in
                    if (section._processed) {
                        section._process();
                    }
                })
            });
        })
    });

})(this, WinJS);
// Back Button
(function backButtonInit(WinJS) {
    "use strict";

    var nav = WinJS.Navigation;

    // Class Names
    var navigationBackButtonClass = 'win-navigation-backbutton';
    var glyphClass = "win-back";

    // CONSTANTS
    var KEY_LEFT = "Left";
    var KEY_BROWSER_BACK = "BrowserBack";
    var MOUSE_BACK_BUTTON = 3;

    // Create Singleton for global event registering/unregistering. This Singleton should only be created once.
    // Here the function 'returnBackButtonSingelton' is called immediateley and its result is the singleton object.
    var singleton = (function createBackButtonSingleton() {

        /* Step 1: Build JavaScript closure */

        function hookUpBackButtonGlobalEventHandlers() {
            // Subscribes to global events on the window object
            window.addEventListener('keyup', backButtonGlobalKeyUpHandler, false)
            window.addEventListener('MSPointerUp', backButtonGlobalMSPointerUpHandler, false);
        }

        function unHookBackButtonGlobalEventHandlers() {
            // Unsubscribes from global events on the window object
            window.removeEventListener('keyup', backButtonGlobalKeyUpHandler, false)
            window.removeEventListener('MSPointerUp', backButtonGlobalMSPointerUpHandler, false);
        }

        function backButtonGlobalKeyUpHandler(event) {
            // Navigates back when (alt + left) or BrowserBack keys are released.
            if ((event.key === KEY_LEFT && event.altKey && !event.shiftKey && !event.ctrlKey) || (event.key === KEY_BROWSER_BACK)) {
                nav.back();
            }
        }

        function backButtonGlobalMSPointerUpHandler(event) {
            // Responds to clicks to enable navigation using 'back' mouse buttons.
            if (event.button === MOUSE_BACK_BUTTON) {
                nav.back();
            }
        }

        // Singleton reference count for registering and unregistering global event handlers.
        var backButtonReferenceCount = 0; // 

        /* Step 2: Return Singleton object literal */
        return {
            addRef: function () {
                if (backButtonReferenceCount === 0) {
                    hookUpBackButtonGlobalEventHandlers();
                }
                backButtonReferenceCount++;
            },
            release: function () {
                if (backButtonReferenceCount > 0) { // Ensure count won't become negative.
                    backButtonReferenceCount--;
                    if (backButtonReferenceCount === 0) {
                        unHookBackButtonGlobalEventHandlers();
                    }
                }
            },
            getCount: function () { // Return the value of the reference count. Useful for unit testing.
                return backButtonReferenceCount;
            }
        };
    }()); // Immediate invoke creates and returns the Singleton

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.BackButton">
        /// BackButton provides back navigtion functionality Apps.
        /// </summary>
        /// <htmlSnippet><![CDATA[<button data-win-control="XboxJS.UI.Backbutton"></button>]]></htmlSnippet>
        /// <part name="BackButton" class="win-navigation-backbutton" locid="XboxJS.UI.BackButton_part:BackButton">The BackButton control itself</part>
        /// <part name="BackArrowGlyph" class="win-back" locid="XboxJS.UI.BackButton_part:BackArrowGlyph">The Back Arrow glyph</part>
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.Xbox.WinJS.1.0/css/ui-dark.css" shared="true" />
        BackButton: WinJS.Namespace._lazy(function () {
            // Statics
            var strings = {
                get ariaLabel() { return WinJS.Resources._getWinJSString("ui/backbuttonarialabel").value; },
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; },
                get badButtonElement() { return WinJS.Resources._getWinJSString("ui/badButtonElement").value; }
            };

            var BackButton = WinJS.Class.define(function BackButton_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.BackButton.BackButton">
                /// <summary locid="XboxJS.UI.BackButton.constructor">
                /// Constructs the BackButton control
                /// </summary>
                /// <param name="element" domElement="true" locid="XboxJS.UI.BackButton.constructor_p:element">
                /// The DOM element to be associated with the BackButton control.  BackButton will create one if null.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="WinJS.UI.MenuBackButtonCommand.constructor_p:options">
                /// The set of options to be applied initially to the BackButton control.
                /// </param>
                /// <returns type="XboxJS.UI.BackButton" locid="XboxJS.UI.BackButton.constructor_returnValue">
                /// A BackButton control.
                /// </returns>
                /// </signature>

                // Check to make sure we weren't duplicated
                if (element && element.winControl) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.BackButton.DuplicateConstruction", strings.duplicateConstruction);
                }

                this._element = element || document.createElement("button");
                options = options || {};

                this._initializeButton(); // This will also set the aria-label and tooltip

                this._disposed = false;

                // Remember ourselves
                this._element.winControl = this;

                WinJS.UI.setOptions(this, options);

                // Add event handlers for this back button instance
                this._buttonClickHandler = this._handleBackButtonClick.bind(this);
                this._element.addEventListener('click', this._buttonClickHandler, false);
                this._navigatedHandler = this._handleNavigatedEvent.bind(this);
                nav.addEventListener('navigated', this._navigatedHandler, false);

                if (XboxJS) {
                    this._handleGestureEngagedBind = this._handleGestureEngaged.bind(this);
                    this._handleGestureDisengagedBind = this._handleGestureDisengaged.bind(this);

                    window.addEventListener("gestureengaged", this._handleGestureEngagedBind, false);
                    window.addEventListener("gesturedisengaged", this._handleGestureDisengagedBind, false);
                }

                // Increment reference count / manage add global event handlers
                singleton.addRef();
            }, {

                /// <field type="HTMLElement" domElement="true" readonly="true" hidden="true" locid="XboxJS.UI.BackButton.element" helpKeyword="XboxJS.UI.BackButton.element">
                /// Gets the DOM element the BackButton is attached to</field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },

                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.BackButton.dispose">
                    /// <summary locid="XboxJS.UI.BackButton.dispose">
                    /// Prepare this BackButton control for garbage collection.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true; // Mark this control as disposed.

                    // Remove 'navigated' eventhandler for this BackButton
                    nav.removeEventListener('navigated', this._navigatedHandler, false);

                    if (XboxJS) {
                        window.removeEventListener("gestureengaged", this._handleGestureEngagedBind);
                        window.removeEventListener("gesturedisengaged", this._handleGestureDisengagedBind);
                    }

                    singleton.release(); // Decrement reference count.

                },

                refresh: function () {
                    /// <signature helpKeyword="XboxJS.UI.BackButton.refresh">
                    /// <summary locid="XboxJS.UI.BackButton.refresh">
                    /// Sets the 'disabled' attribute to correct the value based on the current navigation history stack.
                    /// </summary>
                    /// </signature>
                    if (nav.canGoBack) {
                        if (XboxJS) {
                            if (this._element.parentNode) {
                                WinJS.Utilities.removeClass(this._element, "win-hidden");
                                WinJS.Utilities.removeClass(this._element.parentNode, "win-backbuttonvisible");
                            }
                        } else {
                            this._element.disabled = false;
                        }
                    } else {
                        if (XboxJS) {
                            if (this._element.parentNode) {
                                WinJS.Utilities.addClass(this._element.parentNode, "win-backbuttonvisible");
                                WinJS.Utilities.addClass(this._element, "win-hidden");
                            }
                        } else {
                            this._element.disabled = true;
                        }
                    }
                },

                _initializeButton: function () {
                    //Final EN-US HTML should be: 
                    //<button class="win-navigation-backbutton" aria-label="Back" title="Back"><span class="win-back"></span></button> 
                    //Button will automatically be disabled if WinJS.Navigation.history.canGoBack is false.

                    // Verify the HTML is a button
                    if (this._element.tagName !== "BUTTON") {
                        throw new WinJS.ErrorFromName("XboxJS.UI.BackButton.BadButtonElement", strings.badButtonElement);
                    }

                    // Attach our css classes
                    WinJS.Utilities.addClass(this._element, XboxJS.UI.BackButton._ClassName.navigationBackButtonClass);

                    // Attach disposable class.
                    WinJS.Utilities.addClass(this._element, "win-disposable");

                    // The BackButton is not accesible via controller, only gesture or voice
                    this._element.tabIndex = -1;

                    // Create inner glyph element
                    if (XboxJS.UI.Voice) {
                        this._element.innerHTML = "<div data-win-voice=\"{ phrase: '" + XboxJS.UI.Voice.getWinJSStringName('ui/BACK_COMMAND_VUI_ALM') + "', confidence: '" + XboxJS.UI.Voice.getWinJSStringName('ui/BACK_COMMAND_VUI_CONF') + "', pronunciation: '" + XboxJS.UI.Voice.getWinJSStringName('ui/BACK_COMMAND_VUI_PRON') + "', targetElement: select('." + XboxJS.UI.BackButton._ClassName.voiceActivation + "')}\" tabIndex='0'>" +
                                                  "    <span class='" + XboxJS.UI.BackButton._ClassName.glyphClass + "'></span>" +
                                                  "    <span class='" + XboxJS.UI.BackButton._ClassName.voiceActivation + "'></span>" +
                                                  "</div>" +
                                                  "<div class='win-backbutton-attractionregion'></div>";
                    } else {
                        this._element.innerHTML = "<div>" +
                                                  "    <span class='" + XboxJS.UI.BackButton._ClassName.glyphClass + "'></span>" +
                                                  "</div>";
                    }

                    // Set the 'disabled' property to the correct value based on the current navigation history stack.
                    this.refresh();

                    // Set Aria-label and native tooltip to the same localized string equivalent of "Back"
                    this._element.setAttribute("aria-label", strings.ariaLabel);
                    this._element.setAttribute("title", strings.ariaLabel);

                    // Explicitly set type attribute to avoid the default <button> "submit" type.
                    this._element.setAttribute("type", "button");
                },
                _handleNavigatedEvent: function (event) {
                    // Handles WinJS.Navigation 'navigated' behavior
                    this.refresh();
                },

                _handleBackButtonClick: function (event) {
                    // Handles BackButton 'click' behavior
                    nav.back();
                },

                _handleGestureEngaged: function () {
                    // If voice is engaged we don't animate
                    if (XboxJS.Utilities._isVoiceEngaged) {
                        return;
                    }
                    WinJS.UI.executeAnimation(
                        this._element,
                        [{
                            property: "transform",
                            delay: 0,
                            duration: 200,
                            timing: "ease-out",
                            from: "translateX(-64px)",
                            to: "none"
                        },
                        {
                            property: "opacity",
                            delay: 0,
                            duration: 200,
                            timing: "ease-out",
                            from: 0,
                            to: 1
                        }]);
                },

                _handleGestureDisengaged: function () {
                    // If voice is engaged we don't animate
                    if (XboxJS.Utilities._isVoiceEngaged) {
                        return;
                    }
                    WinJS.UI.executeAnimation(
                        this._element,
                        [{
                            property: "transform",
                            delay: 100,
                            duration: 200,
                            timing: "ease-out",
                            from: "none",
                            to: "translateX(-64px)"
                        },
                        {
                            property: "opacity",
                            delay: 100,
                            duration: 200,
                            timing: "ease-out",
                            from: 1,
                            to: 0
                        }]);
                }
            }, {
                _ClassName: {
                    navigationBackButtonClass: 'win-navigation-backbutton',
                    glyphClass: "win-backbutton",
                    voiceActivation: "win-backbutton-voiceactivation",
                }
            });

            // Private Static Method.
            BackButton._getReferenceCount = function () {
                return singleton.getCount(); // Expose this for Unit testing.
            }
            WinJS.Class.mix(BackButton, WinJS.UI.DOMEventMixin);
            return BackButton;
        })
    });

})(WinJS);

// ItemContainer
(function itemContainerInit(global, WinJS, undefined) {
    "use strict";

    var utilities = WinJS.Utilities;
    var createEvent = utilities._createEventProperty;
    var eventNames = {
        invoked: "invoked"
    };

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.ItemContainer">
        /// Displays an item that can be invoked.
        /// </summary>
        /// <icon src="XboxJS.ui.itemcontainer.12x12.png" width="12" height="12" />
        /// <icon src="ui_xboxjs.ui.itemcontainer.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[
        /// <div data-win-control="XboxJS.UI.ItemContainer">HTML content</div>
        /// </div>]]></htmlSnippet>
        /// <event name="invoked" bubbles="true" locid="WinJS.UI.ItemContainer_e:invoked">Raised when the user taps or clicks the item.</event>
        /// <part name="itemcontainer" class="win-itemcontainer" locid="XboxJS.UI.ItemContainer_part:itemcontainer">Main container for the selection item control.</part>
        /// <part name="focusedoutline" class="win-focusedoutline" locid="XboxJS.UI.ItemContainer_part:focusedoutline">Used to display an outline when the main container has keyboard focus.</part>
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.Xbox.WinJS.1.0/css/ui-dark.css" shared="true" />
        ItemContainer: WinJS.Namespace._lazy(function () {
            var strings = {
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; }
            };

            var ItemContainer = WinJS.Class.define(function ItemContainer_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.ItemContainer.ItemContainer">
                /// <summary locid="XboxJS.UI.ItemContainer.constructor">
                /// Creates a new ItemContainer control.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.ItemContainer.constructor_p:element">
                /// The DOM element that hosts the ItemContainer control.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.ItemContainer.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="XboxJS.UI.ItemContainer" locid="XboxJS.UI.ItemContainer.constructor_returnValue">
                /// The new itemContainer control.
                /// </returns>
                /// </signature>
                element = element || document.createElement("DIV");
                this._id = element.id || element.uniqueID;
                this._writeProfilerMark("constructor,StartTM");

                options = options || {};

                if (element.winControl) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.ItemContainer.DuplicateConstruction", strings.duplicateConstruction);
                }

                // Attaching JS control to DOM element  
                element.winControl = this;

                this._element = element;
                WinJS.Utilities.addClass(this.element, "win-focusable win-disposable " + XboxJS.UI.ItemContainer._ClassName.itemContainer);

                // Div elements are not always focusable unless they have a tabIndex. Because the ItemContainer must always be focusable, we
                // assign a tabIndex if one does not already exist. We use a tabIndex of 0, which instructs Trident to choose the default tabbing
                // flow order for the control.
                if (!this.element.tabIndex) {
                    this.element.tabIndex = 0;
                }

                this._focusableIndicator = null;

                // Handler to route click events to children of the container first
                this._setupInternalTree();

                WinJS.UI.setOptions(this, options);

                var that = this;
                this._handleKeyDownBind = function _handleKeyDown(ev) {
                    if ((ev.key === "Spacebar" ||
                        ev.key === "Enter" ||
                        ev.key === "GamepadA") &&
                        !ev.repeat) {
                        WinJS.Utilities.addClass(that._element, "win-itemcontainer-active");
                    }
                };

                this._handleKeyUpBind = function _handleKeyUp(ev) {
                    if ((ev.key === "Spacebar" ||
                        ev.key === "Enter" ||
                        ev.key === "GamepadA") &&
                        !ev.repeat &&
                        WinJS.Utilities.hasClass(that._element, "win-itemcontainer-active")) {
                        that._fireInvokeEvent(ev.deviceSessionId);
                        WinJS.Utilities.removeClass(that._element, "win-itemcontainer-active");
                    }
                };

                this._handlePointerDownBind = function _handlePointerDown(ev) {
                    WinJS.Utilities.addClass(that._element, "win-itemcontainer-active");
                    if (XboxJS.UI.ItemContainer._sounds.selectButtonPressingKinect &&
                        ev.pressExtent !== 0) {
                        XboxJS.UI.ItemContainer._sounds.selectButtonPressingKinect.play();
                    }
                };

                this._handlePointerUpBind = function _handlePointerUp(ev) {
                    WinJS.Utilities.removeClass(that._element, "win-itemcontainer-active");
                };

                this._handlePointerOutBind = function _handlePointerOut(ev) {
                    WinJS.Utilities.removeClass(that._element, "win-itemcontainer-active");
                };

                this._handleClickBind = function _handleClick(ev) {
                    that._fireInvokeEvent(ev.deviceSessionId);
                };

                // We need to remove the active class when the ItemContainer loses focus otherwise, the user can
                // focus on an ItemContainer, press down on gamepadA, then press left to move to another element.
                // Because the user will never keyup on this ItemContainer, the ItemContainer will always be stuck
                // in the pressed visual state.
                this._handleBlurBind = function _handleBlur(ev) {
                    WinJS.Utilities.removeClass(that._element, "win-itemcontainer-active");
                };

                this._element.addEventListener("keydown", this._handleKeyDownBind, false);
                this._element.addEventListener("keyup", this._handleKeyUpBind, false);
                this._element.addEventListener("MSPointerDown", this._handlePointerDownBind, false);
                this._element.addEventListener("MSPointerUp", this._handlePointerUpBind, false);
                this._element.addEventListener("MSPointerOut", this._handlePointerOutBind, false);
                this._element.addEventListener("click", this._handleClickBind, false);
                this._element.addEventListener("blur", this._handleBlurBind, false);

                if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.ItemContainer._sounds.initialized) {
                    XboxJS.UI.ItemContainer._sounds.selectButtonClick = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///SelectButtonClick"));
                    XboxJS.UI.ItemContainer._sounds.selectButtonPressingKinect = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///SelectButtonPressingKinect"));
                    XboxJS.UI.ItemContainer._sounds.initialized = true;
                };

                this._writeProfilerMark("constructor,StopTM");
            }, {
                /// <field type="HTMLElement" domElement="true" hidden="true" locid="XboxJS.UI.ItemContainer.element" helpKeyword="XboxJS.UI.ItemContainer.element">
                /// Gets the DOM element that hosts the itemContainer control.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },

                /// <field type="Function" locid="XboxJS.UI.ItemCotrol.oninvoked" helpKeyword="XboxJS.UI.ItemCotrol.oninvoked">
                /// Raised when the user taps or clicks the item.
                /// </field>
                oninvoked: createEvent(eventNames.invoked),

                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.ItemContainer.dispose">
                    /// <summary locid="XboxJS.UI.ItemContainer.dispose">
                    /// Disposes this control.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    this._element.removeEventListener("keydown", this._handleKeyDownBind);
                    this._element.removeEventListener("keyup", this._handleKeyUpBind);
                    this._element.removeEventListener("MSPointerDown", this._handlePointerDownBind);
                    this._element.removeEventListener("MSPointerUp", this._handlePointerUpBind);
                    this._element.removeEventListener("MSPointerOut", this._handlePointerOutBind);
                    this._element.removeEventListener("click", this._handleClickBind);
                    this._element.removeEventListener("blur", this._handleBlurBind);

                    this._handleKeyDownBind = null;
                    this._handleKeyUpBind = null;
                    this._handlePointerDownBind = null;
                    this._handlePointerUpBind = null;
                    this._handlePointerOutBind = null;
                    this._handleClickBind = null;
                    this._voiceUIhost = null;

                    WinJS.Utilities.disposeSubTree(this.element);

                    this._element.winControl = null;
                    this._element = null;
                },

                _setupInternalTree: function ItemContainer_setupInternalTree() {
                    var item = document.createElement("div");
                    item.className = WinJS.UI._itemClass;
                    this._focusableIndicator = document.createElement("div");
                    this._focusableIndicator.className = XboxJS.UI.ItemContainer._ClassName.focusableIndicator;

                    this._captureProxy = document.createElement("div");
                    this._captureProxy.className = XboxJS.UI.ItemContainer._ClassName.captureProxy;

                    this._voiceUIhost = document.createElement("div");
                    this._voiceUIhost.className = XboxJS.UI.ItemContainer._ClassName.voiceUIhost;

                    var innerHTML = "<div class='" + XboxJS.UI.ItemContainer._ClassName.voiceUIContainer + "'>" +
                                    "  <div class='" + XboxJS.UI.ItemContainer._ClassName.voiceOverlay + "'></div>" +
                                    "  <div class='" + XboxJS.UI.ItemContainer._ClassName.voiceTextDisplay + "'></div>" +
                                    "</div>";
                    this._voiceUIhost.innerHTML += innerHTML;

                    this._itemBox = document.createElement("div");
                    this._itemBox.className = WinJS.UI._itemBoxClass;

                    var child = this.element.firstChild;
                    while (child) {
                        var sibling = child.nextSibling;
                        item.appendChild(child);
                        child = sibling;
                    }

                    this.element.appendChild(this._itemBox);
                    this._itemBox.appendChild(item);
                    this.element.appendChild(this._focusableIndicator);
                    this.element.appendChild(this._voiceUIhost);
                    this.element.appendChild(this._captureProxy);

                    this._voiceUIContainer = this._element.querySelector(XboxJS.UI.ItemContainer._ClassName.voiceUIContainer);
                    this._voiceOverlay = this._element.querySelector(XboxJS.UI.ItemContainer._ClassName.voiceOverlay);
                    this._voiceTextDisplay = this._element.querySelector(XboxJS.UI.ItemContainer._ClassName.voiceTextDisplay);
                },

                _fireInvokeEvent: function ItemContainer_fireInvokeEvent(deviceSessionId) {
                    var eventObject = document.createEvent("CustomEvent");
                    // We set the deviceSessionId to zero for unrecognized devices (eg. if the event that caused the invoke event doesn't
                    // have a deviceSessionId). Invokation via voice is one example. 0 is just a convention.
                    eventObject.initCustomEvent(eventNames.invoked, true, false, { deviceSessionId: deviceSessionId || 0 });
                    this.element.dispatchEvent(eventObject);

                    if (XboxJS.UI.ItemContainer._sounds.selectButtonClick) {
                        XboxJS.UI.ItemContainer._sounds.selectButtonClick.play();
                    }
                },

                _writeProfilerMark: function ItemContainer_writeProfilerMark(text) {
                    var message = "XboxJS.UI.ItemContainer:" + this._id + ":" + text;
                    msWriteProfilerMark(message);
                    WinJS.log && WinJS.log(message, null, "itemcontainerprofiler");
                }
            }, {

                // Names of classes used by the ItemContainer.  
                _ClassName: {
                    itemContainer: "win-itemcontainer",
                    focusableIndicator: "win-tile-focusindicator",
                    captureProxy: "win-itemcontainer-captureproxy",
                    voiceUIhost: "win-voice-host",
                    voiceUIContainer: "win-voice-container",
                    voiceOverlay: "win-voice-overlay",
                    voiceTextDisplay: "win-voice-textdisplay win-voice-activetext"
                },

                _sounds: {
                    initialized: false,
                    selectButtonClick: null,
                    selectButtonPressingKinect: null
                }
            });
            WinJS.Class.mix(ItemContainer, WinJS.UI.DOMEventMixin);
            return ItemContainer;
        }),
    });
})(this, WinJS);

(function repeaterInit(WinJS) {
    "use strict";

    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.Repeater">
        /// Repeaters iterate over a set of data to render templated HTML
        /// </summary>
        /// <icon src="ui_xboxjs.ui.repeater.12x12.png" width="12" height="12" />
        /// <icon src="ui_xboxjs.ui.repeater.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.Repeater" data-win-options="{data: listData, template: template}"></div>]]></htmlSnippet>
        /// <part name="repeater" class="win-repeater" locid="XboxJS.UI.Repeater_part:repeater">The Repeater control itself</part>
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.Xbox.WinJS.1.0/css/ui-dark.css" shared="true" />
        Repeater: WinJS.Namespace._lazy(function () {
            var UI = WinJS.UI;
            var Utilities = WinJS.Utilities;

            // Constants
            var ITEMSLOADED = "itemsloaded",
                ITEMCHANGING = "itemchanging",
                ITEMCHANGED = "itemchanged",
                ITEMINSERTING = "iteminserting",
                ITEMINSERTED = "iteminserted",
                ITEMMOVING = "itemmoving",
                ITEMMOVED = "itemmoved",
                ITEMREMOVING = "itemremoving",
                ITEMREMOVED = "itemremoved",
                ITEMSRELOADING = "itemsreloading",
                ITEMSRELOADED = "itemsreloaded";

            var createEvent = Utilities._createEventProperty;

            // Class Names
            var repeaterClass = "win-repeater";

            function stringifyItem(dataItem) {
                // Repeater uses this as its default renderer when no template is provided.
                var itemElement = document.createElement("div");
                itemElement.innerText = JSON.stringify(dataItem);
                return itemElement;
            }

            // Statics
            var strings = {
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; },
                get asynchronousRender() { return WinJS.Resources._getWinJSString("ui/asynchronousRender").value; },
                get repeaterReentrancy() { return WinJS.Resources._getWinJSString("ui/repeaterReentrancy").value; },
            };

            var Repeater = WinJS.Class.define(function Repeater_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.Repeater.Repeater">
                /// <summary locid="XboxJS.UI.Repeater.constructor">
                /// Constructs the Repeater control
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" isOptional="true" locid="XboxJS.UI.Repeater.constructor_p:element">
                /// The DOM element to be associated with the Repeater control. Repeater will create one if null.
                /// </param>
                /// <param name="options" type="Object" isOptional="true" locid="XboxJS.UI.Repeater.constructor_p:options">
                /// The set of options to be applied initially to the Repeater control.
                /// </param>
                /// <returns type="XboxJS.UI.Repeater" locid="XboxJS.UI.Repeater.constructor_returnValue">
                /// A Repeater control.
                /// </returns>
                /// </signature>

                // Check to make sure we weren't duplicated
                if (element && element.winControl) {
                    throw new WinJS.ErrorFromName("XboxJS.UI.Repeater.DuplicateConstruction", strings.duplicateConstruction);
                }

                this._element = element || document.createElement("div");
                this._id = this._element.id || this._element.uniqueID;
                this._writeProfilerMark("constructor,StartTM");
                options = options || {};
                Utilities.addClass(this._element, "win-repeater win-disposable");

                this._render = null;
                this._modifying = false;
                this._disposed = false;
                this._element.winControl = this;
                this._dataListeners = {
                    itemchanged: this._dataItemChangedHandler.bind(this),
                    iteminserted: this._dataItemInsertedHandler.bind(this),
                    itemmoved: this._dataItemMovedHandler.bind(this),
                    itemremoved: this._dataItemRemovedHandler.bind(this),
                    reload: this._dataReloadHandler.bind(this),
                };

                // Consume Repeater innerHTML and return a template.
                var inlineTemplate = this._extractInlineTemplate();
                this._initializing = true;
                // Use the inlinetemplate if a parameter was not given.
                // Either way, Repeater's innerHTML has now been consumed.
                this.template = options.template || inlineTemplate;

                this.data = options.data;
                this._initializing = false;

                UI._setOptions(this, options, true); // Events only

                this._repeatedDOM = [];
                this._renderAllItems();
                this.dispatchEvent(ITEMSLOADED, {});

                this._writeProfilerMark("constructor,StopTM");
            }, {

                /// <field type="HTMLElement" domElement="true" readonly="true" hidden="true" locid="XboxJS.UI.Repeater.element" helpKeyword="XboxJS.UI.Repeater.element">
                /// Gets the DOM element the Repeater control is attached to.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },

                /// <field type="WinJS.Binding.List" locid="XboxJS.UI.Repeater.data" helpKeyword="XboxJS.UI.Repeater.data">
                /// Gets or sets the WinJS.Binding.List that provides the Repeater Control with items to display.
                /// </field>
                data: {
                    get: function () { return this._data; },
                    set: function (data) {
                        this._writeProfilerMark("data.set,StartTM");
                        if (this._data) {
                            this._removeDataListeners();
                        };
                        this._data = data || new WinJS.Binding.List();
                        this._addDataListeners();
                        if (!this._initializing) {
                            this._reloadRepeater(true);
                            this.dispatchEvent(ITEMSLOADED, {});
                        }
                        this._writeProfilerMark("data.set,StopTM");
                    }
                },

                /// <field type="Object" locid="XboxJS.UI.Repeater.template" helpKeyword="XboxJS.UI.Repeater.template" potentialValueSelector="[data-win-control='WinJS.Binding.Template']">
                /// Gets or sets a Template or custom rendering function that defines the HTML of each item within the Repeater.
                /// </field>
                template: {
                    get: function () { return this._template; },
                    set: function (template) {
                        this._writeProfilerMark("template.set,StartTM");
                        this._template = (template || stringifyItem);
                        this._render = WinJS.Utilities._syncRenderer(this._template, this.element.tagName);
                        if (!this._initializing) {
                            this._reloadRepeater(true);
                            this.dispatchEvent(ITEMSLOADED, {});
                        }
                        this._writeProfilerMark("template.set,StopTM");
                    }
                },

                elementFromIndex: function Repeater_elementFromIndex(index) {
                    /// <signature helpKeyword="XboxJS.UI.Repeater.elementFromIndex">
                    /// <summary locid="XboxJS.UI.Repeater.elementFromIndex">
                    /// Returns an element from the view by the given index in the Repeater data.
                    /// </summary>
                    /// </signature>
                    return this._repeatedDOM[index];
                },

                dispose: function Repeater_dispose() {
                    /// <signature helpKeyword="XboxJS.UI.Repeater.dispose">
                    /// <summary locid="XboxJS.UI.Repeater.dispose">
                    /// Prepare this Repeater for garbage collection.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true; // Mark this control as disposed.
                    this._removeDataListeners();
                    this._data = null;
                    this._template = null;
                    for (var i = 0, len = this._repeatedDOM.length; i < len; i++) {
                        WinJS.Utilities._disposeElement(this._repeatedDOM[i]);
                    }
                },

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemsloaded" helpKeyword="XboxJS.UI.Repeater.onitemsloaded">
                /// Fired when the Repeater has finished loading a new set of data. This event is only fired on construction
                /// or when the Repeater's datasource/template is replaced.
                /// </field>
                onitemsloaded: createEvent(ITEMSLOADED),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemchanging" helpKeyword="XboxJS.UI.Repeater.onitemchanging">
                /// The value identified by the specified key has been replaced with a different value in the data list.
                /// The respective data bound DOM element is about to reflect this change.
                /// </field>
                onitemchanging: createEvent(ITEMCHANGING),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemchanged" helpKeyword="XboxJS.UI.Repeater.onitemchanged">
                /// Fired after the repeater has updated its innerHTML following an itemchanging event.
                /// </field>
                onitemchanged: createEvent(ITEMCHANGED),

                /// <field type="Function" locid="XboxJS.UI.Repeater.oniteminserting" helpKeyword="XboxJS.UI.Repeater.oniteminserting">
                /// A new value has been inserted into the data.
                /// The respective data bound element is about to be inserted into the Repeater's innerHTML.
                /// </field>
                oniteminserting: createEvent(ITEMINSERTING),

                /// <field type="Function" locid="XboxJS.UI.Repeater.oniteminserted" helpKeyword="XboxJS.UI.Repeater.oniteminserted">
                /// Fired after the repeater has updated its innerHTML following an iteminserting event.
                /// </field>
                oniteminserted: createEvent(ITEMINSERTED),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemmoving" helpKeyword="XboxJS.UI.Repeater.onitemmoving">
                /// The value identified by the specified key has been moved from one index in the list to another index.
                /// The data bound element is about to make the same move through the Repeaters innerHTML.
                /// </field>
                onitemmoving: createEvent(ITEMMOVING),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemmoved" helpKeyword="XboxJS.UI.Repeater.onitemmoved">
                /// Fired after the repeater has updated its innerHTML following an itemmoving event.
                /// </field>
                onitemmoved: createEvent(ITEMMOVED),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemremoving" helpKeyword="XboxJS.UI.Repeater.onitemremoving">
                /// The value identified by the specified key has been removed from the data source and its
                /// data bound element is about to be removed from the DOM.
                /// </field>
                onitemremoving: createEvent(ITEMREMOVING),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemremoved" helpKeyword="XboxJS.UI.Repeater.onitemremoved">
                /// Fired after the repeater has updated its innerHTML following an itemremoving event.
                /// </field>
                onitemremoved: createEvent(ITEMREMOVED),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemsreloading" helpKeyword="XboxJS.UI.Repeater.onitemsreloading">
                /// The list has been refreshed and any references to data in the list may be incorrect.
                /// The Repeater's innerHTML is about to be reloaded.
                /// </field>
                onitemsreloading: createEvent(ITEMSRELOADING),

                /// <field type="Function" locid="XboxJS.UI.Repeater.onitemsreloaded" helpKeyword="XboxJS.UI.Repeater.onitemsreloaded">
                /// Fired after the repeater has reloaded its innerHTML following an itemsreloaded event.
                /// </field>
                onitemsreloaded: createEvent(ITEMSRELOADED),

                _extractInlineTemplate: function Repeater_extractInlineTemplate() {
                    // Creates and returns a WinJS.BindingTemplate from the Repeater innerHTML.
                    if (this._element.firstElementChild) {
                        var templateElement = document.createElement(this._element.tagName);
                        while (this._element.firstElementChild) {
                            // Move each child element from the Repeater to the Template Element
                            templateElement.appendChild(this._element.firstElementChild);
                        }
                        return new WinJS.Binding.Template(templateElement, { extractChild: true });
                    }
                },

                _renderAllItems: function Repeater_renderAllItems() {
                    var root = this._element;
                    for (var i = 0, len = this._data.length; i < len; i++) {
                        var renderedItem = this._render(this._data.getAt(i));
                        if (!renderedItem) {
                            throw new WinJS.ErrorFromName("XboxJS.UI.Repeater.AsynchronousRender", strings.asynchronousRender);

                        }
                        root.appendChild(renderedItem);
                        this._repeatedDOM.push(renderedItem);
                    }
                },

                _reloadRepeater: function Repeater_reloadRepeater(shouldDisposeElements) {
                    this._unloadRepeatedDOM(shouldDisposeElements);
                    this._repeatedDOM = [];
                    this._renderAllItems();
                },

                _unloadRepeatedDOM: function Repeater_unloadRepeatedDOM(shouldDisposeElements) {
                    for (var i = 0, len = this._repeatedDOM.length; i < len; i++) {
                        if (!!shouldDisposeElements) {
                            // this_dataReloadHandler uses this to defer disposal until after animations have completed,
                            // at which point it manually disposes each element.
                            WinJS.Utilities._disposeElement(this._repeatedDOM[i]);
                        }
                        this._element.removeChild(this._repeatedDOM[i]);
                    }
                },

                _addDataListeners: function Repeater_addDataListeners() {
                    Object.keys(this._dataListeners).forEach(function (eventName) {
                        this._data.addEventListener(eventName, this._dataListeners[eventName], false);
                    }.bind(this));
                },

                _beginModification: function Repeater_beginModification() {
                    if (this._modifying) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Repeater.RepeaterModificationReentrancy", strings.repeaterReentrancy);
                    }
                    this._modifying = true;
                },

                _endModification: function Repeater_endModification() {
                    this._modifying = false;
                },

                _removeDataListeners: function Repeater_removeDataListeners() {
                    Object.keys(this._dataListeners).forEach(function (eventName) {
                        this._data.removeEventListener(eventName, this._dataListeners[eventName], false);
                    }.bind(this));
                },

                _dataItemChangedHandler: function Repeater_dataItemChangedHandler(eventInfo) {
                    // Handles the 'itemchanged' event fired by WinJS.Binding.List

                    this._beginModification();
                    var animationPromise;

                    var root = this._element;
                    var index = eventInfo.detail.index;
                    var renderedItem = this._render(eventInfo.detail.newValue);
                    if (!renderedItem) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Repeater.AsynchronousRender", strings.asynchronousRender);
                    }

                    // Append to the event object
                    if (this._repeatedDOM[index]) {
                        eventInfo.detail.oldElement = this._repeatedDOM[index];
                    }
                    eventInfo.detail.newElement = renderedItem;
                    eventInfo.detail.setPromise = function setPromise(delayPromise) {
                        animationPromise = delayPromise;
                    };

                    this._writeProfilerMark(ITEMCHANGING + ",info");
                    this.dispatchEvent(ITEMCHANGING, eventInfo.detail);

                    // Make the change
                    var oldItem = null;
                    if (index < this._repeatedDOM.length) {
                        oldItem = this._repeatedDOM[index];
                        root.replaceChild(renderedItem, oldItem);
                        this._repeatedDOM[index] = renderedItem;
                    } else {
                        root.appendChild(renderedItem);
                        this._repeatedDOM.push(renderedItem);
                    }

                    this._endModification();
                    this._writeProfilerMark(ITEMCHANGED + ",info");
                    this.dispatchEvent(ITEMCHANGED, eventInfo.detail);

                    if (oldItem) { // Give the option to delay element disposal.
                        WinJS.Promise.as(animationPromise).done(function () {
                            WinJS.Utilities._disposeElement(oldItem);
                        }.bind(this));
                    }
                },

                _dataItemInsertedHandler: function Repeater_dataItemInsertedHandler(eventInfo) {
                    // Handles the 'iteminserted' event fired by WinJS.Binding.List

                    this._beginModification();
                    var index = eventInfo.detail.index;
                    var renderedItem = this._render(eventInfo.detail.value);
                    if (!renderedItem) {
                        throw new WinJS.ErrorFromName("XboxJS.UI.Repeater.AsynchronousRender", strings.asynchronousRender);
                    }

                    var root = this._element;

                    eventInfo.detail.affectedElement = renderedItem;
                    this._writeProfilerMark(ITEMINSERTING + ",info");
                    this.dispatchEvent(ITEMINSERTING, eventInfo.detail);

                    if (index < this._repeatedDOM.length) {
                        var nextSibling = this._repeatedDOM[index];
                        root.insertBefore(renderedItem, nextSibling);
                    } else {
                        root.appendChild(renderedItem);
                    }

                    // Update collection of rendered elements
                    this._repeatedDOM.splice(index, 0, renderedItem);

                    this._endModification();
                    this._writeProfilerMark(ITEMINSERTED + ",info");
                    this.dispatchEvent(ITEMINSERTED, eventInfo.detail);

                },

                _dataItemMovedHandler: function Repeater_dataItemMovedHandler(eventInfo) {
                    // Handles the 'itemmoved' event fired by WinJS.Binding.List 

                    this._beginModification();

                    var movingItem = this._repeatedDOM[eventInfo.detail.oldIndex];

                    // Fire the event before we start the move.
                    eventInfo.detail.affectedElement = movingItem;
                    this._writeProfilerMark(ITEMMOVING + ",info");
                    this.dispatchEvent(ITEMMOVING, eventInfo.detail);

                    // Remove
                    this._repeatedDOM.splice(eventInfo.detail.oldIndex, 1)[0];
                    movingItem.parentNode.removeChild(movingItem);

                    // Insert
                    if (eventInfo.detail.newIndex < (this._data.length) - 1) {
                        var nextSibling = this._repeatedDOM[eventInfo.detail.newIndex];
                        this._element.insertBefore(movingItem, nextSibling);
                        this._repeatedDOM.splice(eventInfo.detail.newIndex, 0, movingItem);
                    } else {
                        this._repeatedDOM.push(movingItem);
                        this._element.appendChild(movingItem);
                    }

                    this._endModification();
                    this._writeProfilerMark(ITEMMOVED + ",info");
                    this.dispatchEvent(ITEMMOVED, eventInfo.detail);
                },

                _dataItemRemovedHandler: function Repeater_dataItemRemoveHandler(eventInfo) {
                    // Handles the 'itemremoved' event fired by WinJS.Binding.List

                    this._beginModification();
                    var animationPromise;
                    var oldItem = this._repeatedDOM[eventInfo.detail.index];

                    // Trim 'value' and 'key' from the eventInfo.details that Binding.List gave for the removal case,
                    // since both of those properties already exist inside of eventInfo.details.item.
                    var eventDetail = { affectedElement: oldItem, index: eventInfo.detail.index, item: eventInfo.detail.item };
                    eventDetail.setPromise = function setPromise(delayPromise) {
                        animationPromise = delayPromise;
                    }

                    this._writeProfilerMark(ITEMREMOVING + ",info");
                    this.dispatchEvent(ITEMREMOVING, eventDetail);

                    oldItem.parentNode.removeChild(oldItem);
                    this._repeatedDOM.splice(eventInfo.detail.index, 1);

                    this._endModification();
                    this._writeProfilerMark(ITEMREMOVED + ",info");
                    this.dispatchEvent(ITEMREMOVED, eventDetail);

                    WinJS.Promise.as(animationPromise).done(function () {
                        WinJS.Utilities._disposeElement(oldItem);
                    }.bind(this));
                },

                _dataReloadHandler: function Repeater_dataReloadHandler(eventInfo) {
                    // Handles the 'reload' event fired by WinJS.Binding.List whenever it performs operations such as reverse() or sort() 

                    this._beginModification();
                    var animationPromise;

                    var shallowCopyBefore = this._repeatedDOM.slice(0);
                    var eventDetail = { affectedElements: shallowCopyBefore };
                    eventDetail.setPromise = function (delayPromise) {
                        animationPromise = delayPromise;
                    }

                    this._writeProfilerMark(ITEMSRELOADING + ",info");
                    this.dispatchEvent(ITEMSRELOADING, eventDetail);
                    this._reloadRepeater(false /*shouldDisposeElements */);

                    var shallowCopyAfter = this._repeatedDOM.slice(0);
                    this._endModification();
                    this._writeProfilerMark(ITEMSRELOADED + ",info");
                    this.dispatchEvent(ITEMSRELOADED, { affectedElements: shallowCopyAfter });

                    WinJS.Promise.as(animationPromise).done(function () { // Gives the option to defer disposal.
                        for (var i = 0, len = shallowCopyBefore.length; i < len; i++) {
                            WinJS.Utilities._disposeElement(shallowCopyBefore[i]);
                        }
                    }.bind(this));
                },

                _writeProfilerMark: function Repeater_writeProfilerMark(text) {
                    msWriteProfilerMark("XboxJS.UI.Repeater:" + this._id + ":" + text);
                }
            });
            WinJS.Class.mix(Repeater, UI.DOMEventMixin);
            return Repeater;
        })
    });

})(WinJS);


// SearchBox
(function searchboxInit(global) {
    "use strict";
    WinJS.Namespace.define("XboxJS.UI", {
        /// <summary locid="XboxJS.UI.SearchBox">
        /// A control that allows the user to enter search queries.
        /// </summary>
        /// <icon src="ui_XboxJS.UI.SearchBox.12x12.png" width="12" height="12" />
        /// <icon src="ui_XboxJS.UI.SearchBox.16x16.png" width="16" height="16" />
        /// <htmlSnippet><![CDATA[<div data-win-control="XboxJS.UI.SearchBox"></div>]]></htmlSnippet>
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/base.js" shared="true" />
        /// <resource type="javascript" src="//Microsoft.Xbox.WinJS.1.0/js/ui.js" shared="true" />
        /// <resource type="css" src="//Microsoft.Xbox.WinJS.1.0/css/ui-dark.css" shared="true" />
        SearchBox: WinJS.Namespace._lazy(function () {
            var utilities = WinJS.Utilities;
            var createEvent = WinJS.Utilities._createEventProperty;
            var sg = null;
            var sgInternal = null;
            if (WinJS.Utilities.hasWinRT && Windows.Xbox) {
                sg = Windows.Xbox.SmartGlass;
                sgInternal = Windows.Xbox.SmartGlass.Internal
            }

            // Enums
            var ClassName = {
                searchBox: "win-searchbox",
                searchBoxInput: "win-searchbox-input",
                searchBoxButton: "win-searchbox-button",
                searchBoxFlyout: "win-searchbox-flyout",
                searchBoxSuggestionResult: "win-searchbox-suggestion-result",
                searchBoxSuggestionQuery: "win-searchbox-suggestion-query",
                searchBoxSuggestionSeparator: "win-searchbox-suggestion-separator",
                searchBoxSuggestionSelected: "win-searchbox-suggestion-selected",
                searchBoxFlyoutHighlightText: "win-searchbox-flyout-highlighttext",
                searchBoxButtonInputFocus: "win-searchbox-button-input-focus",
                searchBoxInputFocus: "win-searchbox-input-focus",
                searchBoxSuggestionResultText: "win-searchbox-suggestion-result-text",
                searchboxDisabled: "win-searchbox-disabled",
            };

            var EventName = {
                querychanged: "querychanged",
                querysubmitted: "querysubmitted",
                resultsuggestionchosen: "resultsuggestionchosen",
                suggestionsrequested: "suggestionsrequested",
                receivingfocusonkeyboardinput: "receivingfocusonkeyboardinput"
            };

            var SearchSuggestionKind = {
                Query: 0,
                Result: 1,
                Separator: 2
            };

            var strings = {
                get duplicateConstruction() { return WinJS.Resources._getWinJSString("ui/duplicateConstruction").value; },
                get letters() { return WinJS.Resources._getWinJSString("tv/searchBoxLetters").value; },
                get secondaryLetters() { return WinJS.Resources._getWinJSString("tv/searchBoxSecondaryLetters").value; },
                get numbers() { return WinJS.Resources._getWinJSString("tv/searchBoxNumbers").value; },
                get toggleNumbersAndLettersLabelNumbers() { return WinJS.Resources._getWinJSString("tv/searchBoxToggleLettersAndNumbersLabelNumbers").value; },
                get toggleNumbersAndLettersLabelLetters() { return WinJS.Resources._getWinJSString("tv/searchBoxToggleLettersAndNumbersLabelLetters").value; },
                get toggleNumbersAndLettersLabelSecondaryLetters() { return WinJS.Resources._getWinJSString("tv/toggleNumbersAndLettersLabelSecondaryLetters").value; }
            };

            var SearchBox = WinJS.Class.define(function SearchBox_ctor(element, options) {
                /// <signature helpKeyword="XboxJS.UI.SearchBox.SearchBox">
                /// <summary locid="XboxJS.UI.SearchBox.constructor">
                /// Creates a new SearchBox.
                /// </summary>
                /// <param name="element" domElement="true" locid="XboxJS.UI.SearchBox.constructor_p:element">
                /// The DOM element that hosts the SearchBox.
                /// </param>
                /// <param name="options" type="Object" locid="XboxJS.UI.SearchControl.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// Event names must begin with "on". For example, to provide a handler for the querychanged event,
                /// add a property named "onquerychanged" to the options object and set its value to the event handler.
                /// This parameter is optional.
                /// </param>
                /// <returns type="XboxJS.UI.SearchBox" locid="XboxJS.UI.SearchBox.constructor_returnValue">
                /// The new SearchBox.
                /// </returns>
                /// </signature>

                element = element || document.createElement("div");

                if (element.winControl) {
                    throw new WinJS.ErrorFromName("WinJS.UI.SearchBox.DuplicateConstruction", strings.duplicateConstruction);
                }
                element.winControl = this;

                // Elements
                this._domElement = null;
                this._inputElement = null;
                this._isShowingLettersNotSymbols = true;
                // This variable tracks which set of characters we are currently showing the user. For instance,
                // the control may be showing letters or numbers. In some cases, like Russian there are three options:
                // (1) Cyrillic characters, (2) Latin characters and (3) numbers.
                this._characterSetDisplayed = "primaryCharacterSet";
                this._firstCharacter = "";
                this._lastCharacter = "";
                this._secondaryAlphabetFirstCharacter = "";
                this._secondaryAlphabetLastCharacter = "";
                this._firstNumberIndex = -1;
                this._lastNumberIndex = -1;
                this._MAX_CHARACTERS_FOR_SMARTGLASS_MESSAGE = 314;
                // This variable is used for the scenario where the user dismisses the keyboard
                // on SmartGlass to enter into controller navigation mode (perhaps they want to select
                // search results). If that is the case, then we will end the text session. We will keep
                // SmartGlass in controller navigation mode while the user is on the SearchBox control.
                // The user can re-enter text mode on SmartGlass by moving focus off of the SearchBox control
                // and back onto the control. The variable below, enables this scenario by keeping track of
                // whether the text session was completed while the SearchBox had focus. If so, we will check
                // this variable the next time the control gets focus and put SmartGlass into text entry mode.
                this._textSessionCompletedAndControlHasFocus = false;
                this._toggleLettersOrSymbolsElement = null;

                // Variables
                this._disposed = false;

                options = options || {};

                // We perform the following check to see if we are running in a language that requires
                // three character sets. Most languages require only two: (1) alphabet and (2) numbers
                // and symbols. But languages like Russian require 3: (1) Cyrillic alphabet, (2) Latin
                // alphabet and (3) numbers and symbols.
                this._usesThreeCharacterSets = false;
                // Note: We check if the app display language is Russian *and* that the app supports
                // Russian. The most correct way to do this is check what language / locale strings WinJS
                // is using for the rest of the SearchBox strings. Otherwise, we could have an English-only 
                // localized app in Russia that doesn't support Russian and it would display 3 characters 
                // sets: English, English and numbers & symbols, which would be incorrect. It should just 
                // have English and numbers & symbols.
                var winJSResourceString = WinJS.Resources._getWinJSString("tv/searchBoxLetters");
                if (winJSResourceString &&
                    winJSResourceString.lang &&
                    winJSResourceString.lang.toLowerCase() === "ru-ru") {
                    this._usesThreeCharacterSets = true;
                }

                this._setElementBind = this._setElement.bind(this);
                this._setElementBind(element);
                WinJS.UI.setOptions(this, options);
                WinJS.Utilities.addClass(element, "win-disposable");

                if (sgInternal) {
                    this._smartGlassTextSessionFactory = sgInternal.SmartGlassTextSessionFactory();
                }

                this._keyDownHandlerBind = this._keyDownHandler.bind(this);
                this._domElement.addEventListener("keydown", this._keyDownHandlerBind, false);
                this._keyUpHandlerBind = this._keyUpHandler.bind(this);
                this._domElement.addEventListener("keyup", this._keyUpHandlerBind, false);

                this._handleFocusInBind = this._handleFocusIn.bind(this);
                this._domElement.addEventListener("focusin", this._handleFocusInBind, false);
                this._handleFocusOutBind = this._handleFocusOut.bind(this);
                this._domElement.addEventListener("focusout", this._handleFocusOutBind, false);

                this._handleSmartGlassTextSessionCompletedBind = this._handleSmartGlassTextSessionCompleted.bind(this);
                this._handleSmartGlassTextSessionTextChangedBind = this._handleSmartGlassTextSessionTextChanged.bind(this);

                if (WinJS.Utilities.hasWinRT && Windows.Xbox && Windows.Xbox.Audio && Windows.Xbox.Audio.SoundClip && !XboxJS.UI.SearchBox._sounds.initialized) {
                    XboxJS.UI.SearchBox._sounds.virtualKeyboardFocus = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///VirtualKeyboardFocus"));
                    XboxJS.UI.SearchBox._sounds.virtualKeyboardSelect = new Windows.Xbox.Audio.SoundClip(new Windows.Foundation.Uri("ms-winsoundevent:///VirtualKeyboardSelect"));
                    XboxJS.UI.SearchBox._sounds.initialized = true;
                };
            }, {
                /// <field type='HTMLElement' domElement='true' hidden='true' locid="WinJS.UI.SearchBox.element" helpKeyword="WinJS.UI.SearchBox.element">
                /// The DOM element that hosts the SearchBox.
                /// </field>
                element: {
                    get: function () {
                        return this._domElement;
                    }
                },

                /// <field type="String" locid="WinJS.UI.SearchBox.placeholderText" helpKeyword="WinJS.UI.SearchBox.placeholderText">
                /// Gets or sets the placeholder text for the SearchBox. This text is displayed if there is no
                /// text in the input box.
                /// </field>
                placeholderText: {
                    get: function () {
                        return this._inputElement.placeholder;
                    },
                    set: function (value) {
                        this._inputElement.placeholder = value;
                    }
                },

                /// <field type="String" locid="WinJS.UI.SearchBox.queryText" helpKeyword="WinJS.UI.SearchBox.queryText">
                /// Gets or sets the query text for the SearchBox.
                /// </field>
                queryText: {
                    get: function () {
                        return this._inputElement.value;
                    },
                    set: function (value) {
                        this._inputElement.value = value;
                        if (this._smartGlassTextSession &&
                            this._inputElement.value.length <= this._MAX_CHARACTERS_FOR_SMARTGLASS_MESSAGE) {
                            this._smartGlassTextSession.text = value;
                        }
                    }
                },
                dispose: function () {
                    /// <signature helpKeyword="XboxJS.UI.SearchBox.dispose">
                    /// <summary locid="XboxJS.UI.SearchBox.dispose">
                    /// Disposes the control.
                    /// </summary>
                    /// </signature>

                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    this._domElement.removeEventListener("keydown", this._keyDownHandlerBind);
                    this._keyDownHandlerBind = null;
                    this._domElement.removeEventListener("keyup", this._keyUpHandlerBind);
                    this._keyUpHandlerBind = null;

                    this._domElement.removeEventListener("focusin", this._handleFocusInBind);
                    this._handleFocusInBind = null;
                    this._domElement.removeEventListener("focusout", this._handleFocusOutBind);
                    this._handleFocusOutBind = null;

                    if (this._smartGlassTextSession) {
                        if (this._smartGlassTextSession.isActive) {
                            this._smartGlassTextSession.complete(sg.TextEntryResult.cancel);
                        }
                        this._smartGlassTextSession.removeEventListener("completed", this._handleSmartGlassTextSessionCompletedBind);
                        this._smartGlassTextSession.removeEventListener("textchanged", this._handleSmartGlassTextSessionTextChangedBind);
                    }

                    this._handleSmartGlassTextSessionCompletedBind = null;
                    this._handleSmartGlassTextSessionTextChangedBind = null;

                    var characters = this._domElement.querySelectorAll(".win-searchbox-character");
                    for (var i = 0; i < characters.length; i++) {
                        characters[i].removeEventListener("focus", this._playKeyboardFocus);
                    }

                    this._setElementBind = null;
                    this._inputElement = null;
                    this._isShowingLettersNotSymbols = null;
                    this._characterSetDisplayed = null;
                    this._spaceElement = null;
                    this._toggleLettersOrSymbolsElement = null;
                    this._usesThreeCharacterSets = null;

                    this._smartGlassTextSessionFactory = null;
                    this._smartGlassTextSession = null;

                    this._firstCharacter = null;
                    this._lastCharacter = null;
                    this._secondaryAlphabetFirstCharacter = null;
                    this._secondaryAlphabetLastCharacter = null;
                    this._firstNumberIndex = null;
                    this._lastNumberIndex = null;

                    this._domElement.winControl = null;
                    this._domElement = null;
                },
                /// <field type="Function" locid="XboxJS.UI.SearchBox.onquerychanged" helpKeyword="XboxJS.UI.SearchBox.onquerychanged">
                /// Raised when the user or app changes the query text.
                /// </field>
                onquerychanged: createEvent(EventName.querychanged),

                _setElement: function SearchBox_setElement(element) {
                    this._domElement = element;
                    utilities.addClass(this._domElement, ClassName.searchBox);

                    var characterArray = strings.letters;
                    var characterArrayLength = characterArray.length;
                    this._firstCharacter = characterArray[0];
                    this._lastCharacter = characterArray[characterArrayLength - 1];

                    var initialToggleLettersAndNumbersString = strings.toggleNumbersAndLettersLabelNumbers;
                    if (this._usesThreeCharacterSets) {
                        var initialToggleLettersAndNumbersString = strings.toggleNumbersAndLettersLabelSecondaryLetters;
                    }
                    var html = "<input class='" + ClassName.searchBoxInput + "' type='text' />" +
                               "<div class='win-searchbox-letterscontainer'>" +
                               "    <div id='togglecharacters' class='win-searchbox-character win-searchbox-toggleletters win-focusable' data-win-focus='{ right: \"#__ms_searchboxletter_" + this._firstCharacter + "\" }'>" + initialToggleLettersAndNumbersString + "</div>" +
                               "    <div class='win-searchbox-alphabetical'>";

                    for (var i = 0; i < characterArrayLength; i++) {
                        var focusLeftSelector = "";
                        var focusRightSelector = "";
                        if (i === 0) {
                            focusLeftSelector = "#togglecharacters";
                            focusRightSelector = "#__ms_searchboxletter_" + characterArray[i + 1];
                        } else if (i === characterArray.length - 1) {
                            focusLeftSelector = "#__ms_searchboxletter_" + characterArray[i - 1];
                            focusRightSelector = "#space";
                        } else {
                            focusLeftSelector = "#__ms_searchboxletter_" + characterArray[i - 1];
                            focusRightSelector = "#__ms_searchboxletter_" + characterArray[i + 1];
                        }
                        html += "<div id='__ms_searchboxletter_" + characterArray[i] + "' class='win-focusable win-searchbox-character' data-win-focus='{ left: \"" + focusLeftSelector + "\", right: \"" + focusRightSelector + "\"}'>" + characterArray[i] + "</div>";
                    }

                    // Create an additional set of letters if we are in a language that requires three character sets.
                    if (this._usesThreeCharacterSets) {
                        var secondaryAlphabetArray = strings.secondaryLetters;
                        var secondaryAlphabetArrayLength = secondaryAlphabetArray.length;
                        this._secondaryAlphabetFirstCharacter = secondaryAlphabetArray[0];
                        this._secondaryAlphabetLastCharacter = secondaryAlphabetArray[secondaryAlphabetArrayLength - 1];
                        html += "</div><div class='win-searchbox-secondaryalphabet win-hidden'>";
                        for (var i = 0; i < secondaryAlphabetArrayLength; i++) {
                            var focusLeftSelector = "";
                            var focusRightSelector = "";
                            if (i === this._firstNumberIndex) {
                                focusLeftSelector = "#togglecharacters";
                                focusRightSelector = "#__ms_searchboxletter_" + secondaryAlphabetArray[i + 1];
                            } else if (i === this._lastNumberIndex) {
                                focusLeftSelector = "#__ms_searchboxletter_" + secondaryAlphabetArray[i - 1];
                                focusRightSelector = "#space";
                            } else {
                                focusLeftSelector = "#__ms_searchboxletter_" + secondaryAlphabetArray[i - 1];
                                focusRightSelector = "#__ms_searchboxletter_" + secondaryAlphabetArray[i + 1];
                            }
                            html += "<div id='__ms_searchboxletter_" + secondaryAlphabetArray[i] + "' class='win-focusable win-searchbox-character' data-win-focus='{ left: \"" + focusLeftSelector + "\", right: \"" + focusRightSelector + "\"}'>" + secondaryAlphabetArray[i] + "</div>";
                        }
                    }

                    var numbersAndSymbolsArray = strings.numbers;
                    var numbersAndSymbolsArrayLength = numbersAndSymbolsArray.length;
                    this._firstNumberIndex = 0;
                    this._lastNumberIndex = numbersAndSymbolsArrayLength - 1;
                    html += "</div><div class='win-searchbox-numericandsymbols win-hidden'>";
                    for (var i = 0; i < numbersAndSymbolsArrayLength; i++) {
                        var focusLeftSelector = "";
                        var focusRightSelector = "";
                        if (i === this._firstNumberIndex) {
                            focusLeftSelector = "#togglecharacters";
                            focusRightSelector = "#__ms_searchboxsymbol_" + (i + 1);
                        } else if (i === this._lastNumberIndex) {
                            focusLeftSelector = "#__ms_searchboxsymbol_" + (i - 1);
                            focusRightSelector = "#space";
                        } else {
                            focusLeftSelector = "#__ms_searchboxsymbol_" + (i - 1);
                            focusRightSelector = "#__ms_searchboxsymbol_" + (i + 1);
                        }
                        html += "<div id='__ms_searchboxsymbol_" + i + "' class='win-focusable win-searchbox-character' data-win-focus='{ left: \"" + focusLeftSelector + "\", right: \"" + focusRightSelector + "\"}'>" + numbersAndSymbolsArray[i] + "</div>";
                    }

                    html += "    </div>" +
                            "    <div class='win-searchbox-secondaryletters'>" +
                            "        <div id='space' class='win-focusable win-searchbox-character win-spaceicon' data-win-focus='{ left: \"#__ms_searchboxletter_" + this._lastCharacter + "\", right: \"#backspace\" }'></div>" +
                            "        <div id='backspace' class='win-focusable win-searchbox-character win-backspaceicon' data-win-focus='{ left: \"#space\" }'></div>" +
                            "    </div>" +
                            "</div>";
                    this._domElement.innerHTML = html;

                    this._inputElement = this._domElement.querySelector(".win-searchbox-input");
                    this._spaceElement = this._domElement.querySelector("#space");
                    this._toggleLettersOrSymbolsElement = this._domElement.querySelector(".win-searchbox-toggleletters");

                    // We do not want the input textbox to be non-focusable
                    this._inputElement.tabIndex = -1;
                    this._aphabetCharactersElement = this._domElement.querySelector(".win-searchbox-alphabetical");
                    this._secondaryAphabetCharactersElement = this._domElement.querySelector(".win-searchbox-secondaryalphabet");
                    this._numbersAndSymbolsElement = this._domElement.querySelector(".win-searchbox-numericandsymbols");

                    var characters = this._domElement.querySelectorAll(".win-searchbox-character");
                    for (var i = 0; i < characters.length; i++) {
                        characters[i].addEventListener("focus", this._playKeyboardFocus, false);
                    }

                    // Animate the SearchBox in
                    WinJS.UI.Animation.fadeIn(this._element);
                },
                _fireEvent: function SearchBox_fireEvent(type, detail) {
                    // Returns true if ev.preventDefault() was not called
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, true, true, detail);
                    return this.element.dispatchEvent(event);
                },
                _handleFocusIn: function SearchBox_handleFocusIn() {
                    if (!sg) {
                        return;
                    }

                    if (!this._smartGlassTextSession &&
                        !this._textSessionCompletedAndControlHasFocus) {
                        this._startSmartGlassTextSession();
                    }
                },
                _handleFocusOut: function SearchBox_handleFocusOut(ev) {
                    if (!sg) {
                        return;
                    }

                    if (!this._domElement.contains(ev.relatedTarget)) {
                        if (this._smartGlassTextSession) {
                            this._endSmartGlassTextSession();
                        }
                        this._textSessionCompletedAndControlHasFocus = false;
                    }
                },
                _startSmartGlassTextSession: function SearchBox_startSmartGlassTextSession() {
                    if (!sg) {
                        return;
                    }

                    this._smartGlassTextSession = this._smartGlassTextSessionFactory.createTextSession();
                    this._smartGlassTextSession.addEventListener("completed", this._handleSmartGlassTextSessionCompletedBind, false);
                    this._smartGlassTextSession.addEventListener("textchanged", this._handleSmartGlassTextSessionTextChangedBind, false);
                    this._smartGlassTextSession.text = this._inputElement.value;
                },
                _endSmartGlassTextSession: function SearchBox_endSmartGlassTextSession() {
                    if (!sg ||
                        !this._smartGlassTextSession) {
                        return;
                    }

                    if (this._smartGlassTextSession.isActive) {
                        this._smartGlassTextSession.complete(sg.TextEntryResult.cancel);
                    }
                    this._smartGlassTextSession.removeEventListener("completed", this._handleSmartGlassTextSessionCompletedBind);
                    this._smartGlassTextSession.removeEventListener("textchanged", this._handleSmartGlassTextSessionTextChangedBind);
                    this._smartGlassTextSession = null;
                },
                _handleSmartGlassTextSessionCompleted: function SearchBox_handleSmartGlassTextSessionCompleted(ev) {
                    if (!sg) {
                        return;
                    }

                    var result = ev.detail[0];
                    if (result === sg.TextEntryResult.accept) {
                        // This means the user has pressed the enter button on the textbox. Since this has no relevance to
                        // to the Rune control, we show the textbox again.
                        this._endSmartGlassTextSession();
                        this._startSmartGlassTextSession();
                    } else if (result === sg.TextEntryResult.cancel) {
                        // This means the user has dismissed the keyboard and they want to use SmartGlass
                        // as a gamepad
                        this._endSmartGlassTextSession();
                    }
                    this._textSessionCompletedAndControlHasFocus = true;
                },
                _handleSmartGlassTextSessionTextChanged: function SearchBox_handleSmartGlassTextSessionCompleted(ev) {
                    if (!sg) {
                        return;
                    }

                    this._inputElement.value = this._smartGlassTextSession.text;
                    this._fireEvent(XboxJS.UI.SearchBox._EventName.querychanged, {
                        queryText: this._inputElement.value
                    });

                    // For SmartGlass, we send a fake keydown, keypressed and keyup event whenever 
                    // the text changes.This is because some app developers look for keydown events 
                    // in order to update the search results.
                    var fakeKeydownEvent = document.createEvent('MouseEvents');
                    fakeKeydownEvent.initEvent("keydown", true, true);
                    fakeKeydownEvent.key = "Shift";
                    fakeKeydownEvent.keyCode = WinJS.Utilities.Key.shift;
                    this._domElement.dispatchEvent(fakeKeydownEvent);

                    var fakeKeypressedEvent = document.createEvent('MouseEvents');
                    fakeKeypressedEvent.initEvent("keypressed", true, true);
                    fakeKeypressedEvent.key = "Shift";
                    fakeKeypressedEvent.keyCode = WinJS.Utilities.Key.shift;
                    this._domElement.dispatchEvent(fakeKeypressedEvent);

                    var fakeKeyupEvent = document.createEvent('MouseEvents');
                    fakeKeyupEvent.initEvent("keyup", true, true);
                    fakeKeyupEvent.key = "Shift";
                    fakeKeyupEvent.keyCode = WinJS.Utilities.Key.shift;
                    this._domElement.dispatchEvent(fakeKeyupEvent);
                },
                _keyDownHandler: function (ev) {
                    // Update the textbox
                    var shouldFireQueryChanged = false;
                    if (ev.key === "GamepadA" ||
                        ev.key === "Spacebar" ||
                        ev.key === "Enter") {
                        var upperCaseKey = ev.srcElement.id;
                        // Convert the key to lowercase
                        var key = upperCaseKey.toLowerCase();
                        // Because the id of the letters and symbols start with "__ms_searchboxletter_*",
                        // we are only interested in the last letter to use for comparison which will be
                        // the letter. The reason the ids aren't just the letter and are longer strings is
                        // because we want to avoid name collisions with other ids in the document.
                        var adjustedKey = "";
                        if (this._isShowingLettersNotSymbols) {
                            adjustedKey = key[key.length - 1];
                        } else {
                            var adjustedKeyIndex = key.split("__ms_searchboxsymbol_")[1];
                            adjustedKey = strings.numbers[adjustedKeyIndex];
                        }
                        if (key === 'space') {
                            this._inputElement.value += ' ';
                            shouldFireQueryChanged = true;
                            this._playSelectionAnimationAndSounds(ev.srcElement);
                        } else if (key === 'backspace') {
                            this._inputElement.value = this._inputElement.value.substring(0, this._inputElement.value.length - 1);
                            shouldFireQueryChanged = true;
                            this._playSelectionAnimationAndSounds(ev.srcElement);
                        } else if (key === 'togglecharacters') {
                            var firstCharacter = "";
                            var lastCharacter = "";
                            if (this._characterSetDisplayed === "primaryCharacterSet" &&
                                this._usesThreeCharacterSets) {
                                WinJS.Utilities.addClass(this._aphabetCharactersElement, "win-hidden");
                                if (this._secondaryAphabetCharactersElement) {
                                    WinJS.Utilities.removeClass(this._secondaryAphabetCharactersElement, "win-hidden");
                                }
                                WinJS.Utilities.addClass(this._numbersAndSymbolsElement, "win-hidden");
                                this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelNumbers;
                                this._characterSetDisplayed = "secondaryCharacterSet";
                                firstCharacter = "#__ms_searchboxletter_" + this._secondaryAlphabetFirstCharacter;
                                lastCharacter = "#__ms_searchboxletter_" + this._secondaryAlphabetLastCharacter;
                                this._isShowingLettersNotSymbols = true;
                            } else if ((!this._usesThreeCharacterSets && this._characterSetDisplayed === "primaryCharacterSet") ||
                                (this._usesThreeCharacterSets && this._characterSetDisplayed === "secondaryCharacterSet")) {
                                WinJS.Utilities.addClass(this._aphabetCharactersElement, "win-hidden");
                                if (this._secondaryAphabetCharactersElement) {
                                    WinJS.Utilities.addClass(this._secondaryAphabetCharactersElement, "win-hidden");
                                }
                                WinJS.Utilities.removeClass(this._numbersAndSymbolsElement, "win-hidden");
                                this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelLetters;
                                this._characterSetDisplayed = "thirdCharacterSet";
                                firstCharacter = "#__ms_searchboxsymbol_" + this._firstNumberIndex;
                                lastCharacter = "#__ms_searchboxsymbol_" + this._lastNumberIndex;
                                this._isShowingLettersNotSymbols = false;
                            } else {
                                WinJS.Utilities.removeClass(this._aphabetCharactersElement, "win-hidden");
                                if (this._secondaryAphabetCharactersElement) {
                                    WinJS.Utilities.addClass(this._secondaryAphabetCharactersElement, "win-hidden");
                                }
                                WinJS.Utilities.addClass(this._numbersAndSymbolsElement, "win-hidden");
                                if (this._usesThreeCharacterSets) {
                                    this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelSecondaryLetters;
                                } else {
                                    this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelNumbers;
                                }
                                this._characterSetDisplayed = "primaryCharacterSet";
                                firstCharacter = "#__ms_searchboxletter_" + this._firstCharacter;
                                lastCharacter = "#__ms_searchboxletter_" + this._lastCharacter;
                                this._isShowingLettersNotSymbols = true;
                            }
                            this._spaceElement.setAttribute("data-win-focus", "{ left: \"" + lastCharacter + "\", right: \"#backspace\" }");
                            this._toggleLettersOrSymbolsElement.setAttribute("data-win-focus", "{ right: \"" + firstCharacter + "\" }");
                            this._playSelectionAnimationAndSounds(ev.srcElement);
                        } else {
                            // This must mean the key was a symbol
                            this._inputElement.value += adjustedKey;
                            shouldFireQueryChanged = true;
                            this._playSelectionAnimationAndSounds(ev.srcElement);
                        }
                        // Gamepad shortcuts
                    } else if (ev.key === "GamepadX") {
                        if (XboxJS.UI.SearchBox._sounds.virtualKeyboardSelect) {
                            XboxJS.UI.SearchBox._sounds.virtualKeyboardSelect.play();
                        }
                        this._inputElement.value = this._inputElement.value.substring(0, this._inputElement.value.length - 1);
                        shouldFireQueryChanged = true;
                        this._playSelectionAnimationAndSounds(this._domElement.querySelector("#backspace"));
                    } else if (ev.key === "GamepadY") {
                        this._inputElement.value += ' ';
                        shouldFireQueryChanged = true;
                        this._playSelectionAnimationAndSounds(this._domElement.querySelector("#space"));
                    } else if (ev.key === "GamepadLeftTrigger") {
                        var firstCharacter = "";
                        var lastCharacter = "";
                        if (this._characterSetDisplayed === "primaryCharacterSet" &&
                            this._usesThreeCharacterSets) {
                            WinJS.Utilities.addClass(this._aphabetCharactersElement, "win-hidden");
                            if (this._secondaryAphabetCharactersElement) {
                                WinJS.Utilities.removeClass(this._secondaryAphabetCharactersElement, "win-hidden");
                            }
                            WinJS.Utilities.addClass(this._numbersAndSymbolsElement, "win-hidden");
                            this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelNumbers;
                            this._characterSetDisplayed = "secondaryCharacterSet";
                            firstCharacter = "#__ms_searchboxletter_" + this._secondaryAlphabetFirstCharacter;
                            lastCharacter = "#__ms_searchboxletter_" + this._secondaryAlphabetLastCharacter;
                            this._isShowingLettersNotSymbols = true;
                        } else if ((!this._usesThreeCharacterSets && this._characterSetDisplayed === "primaryCharacterSet") ||
                            (this._usesThreeCharacterSets && this._characterSetDisplayed === "secondaryCharacterSet")) {
                            WinJS.Utilities.addClass(this._aphabetCharactersElement, "win-hidden");
                            if (this._secondaryAphabetCharactersElement) {
                                WinJS.Utilities.addClass(this._secondaryAphabetCharactersElement, "win-hidden");
                            }
                            WinJS.Utilities.removeClass(this._numbersAndSymbolsElement, "win-hidden");
                            this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelLetters;
                            this._characterSetDisplayed = "thirdCharacterSet";
                            firstCharacter = "#__ms_searchboxsymbol_" + this._firstNumberIndex;
                            lastCharacter = "#__ms_searchboxsymbol_" + this._lastNumberIndex;
                            this._isShowingLettersNotSymbols = false;
                        } else {
                            WinJS.Utilities.removeClass(this._aphabetCharactersElement, "win-hidden");
                            if (this._secondaryAphabetCharactersElement) {
                                WinJS.Utilities.addClass(this._secondaryAphabetCharactersElement, "win-hidden");
                            }
                            WinJS.Utilities.addClass(this._numbersAndSymbolsElement, "win-hidden");
                            if (this._usesThreeCharacterSets) {
                                this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelSecondaryLetters;
                            } else {
                                this._toggleLettersOrSymbolsElement.textContent = strings.toggleNumbersAndLettersLabelNumbers;
                            }
                            this._characterSetDisplayed = "primaryCharacterSet";
                            firstCharacter = "#__ms_searchboxletter_" + this._firstCharacter;
                            lastCharacter = "#__ms_searchboxletter_" + this._lastCharacter;
                            this._isShowingLettersNotSymbols = true;
                        }
                        this._spaceElement.setAttribute("data-win-focus", "{ left: \"" + lastCharacter + "\", right: \"#backspace\" }");
                        this._toggleLettersOrSymbolsElement.setAttribute("data-win-focus", "{ right: \"" + firstCharacter + "\" }");
                        this._playSelectionAnimationAndSounds(this._domElement.querySelector("#togglecharacters"));
                    }

                    if (shouldFireQueryChanged) {
                        this._fireEvent(XboxJS.UI.SearchBox._EventName.querychanged, {
                            queryText: this._inputElement.value
                        });
                        if (this._smartGlassTextSession &&
                            this._inputElement.value.length <= this._MAX_CHARACTERS_FOR_SMARTGLASS_MESSAGE) {
                            this._smartGlassTextSession.text = this._inputElement.value;
                        }
                    }
                },
                _keyUpHandler: function SearchBox_keyUpHander(ev) {
                    var pressedElements = this._domElement.querySelectorAll(".win-pressed");
                    for (var i = 0, len = pressedElements.length; i < len; i++) {
                        WinJS.Utilities.removeClass(pressedElements[i], "win-pressed");
                    }
                },
                _playKeyboardFocus: function SearchBox_playKeyboardFocus() {
                    if (XboxJS.UI.SearchBox._sounds.virtualKeyboardFocus) {
                        XboxJS.UI.SearchBox._sounds.virtualKeyboardFocus.play();
                    }
                },
                _playSelectionAnimationAndSounds: function SearchBox_playKeyboardFocus(element) {
                    if (XboxJS.UI.SearchBox._sounds.virtualKeyboardSelect) {
                        XboxJS.UI.SearchBox._sounds.virtualKeyboardSelect.play();
                    }
                    WinJS.Utilities.addClass(element, "win-pressed");
                }
            }, {
                _EventName: {
                    querychanged: EventName.querychanged
                },
                _sounds: {
                    initialized: false,
                    virtualKeyboardFocus: null,
                    virtualKeyboardSelect: null
                }
            });
            WinJS.Class.mix(SearchBox, WinJS.UI.DOMEventMixin);
            return SearchBox;
        })
    });

})(this, WinJS);

